(globalThis["webpackChunk_stlite_mountable"] = globalThis["webpackChunk_stlite_mountable"] || []).push([["vendors-node_modules_glideapps_glide-data-grid_dist_index_css-node_modules_glideapps_glide-da-1c06b4"],{

/***/ "../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/sheet */ "../../node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Middleware.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Serializer.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! stylis */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Parser.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/weak-memoize */ "../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/memoize */ "../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");




var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;
  while (true) {
    previous = character;
    character = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }
    if ((0,stylis__WEBPACK_IMPORTED_MODULE_3__.token)(character)) {
      break;
    }
    (0,stylis__WEBPACK_IMPORTED_MODULE_3__.next)();
  }
  return (0,stylis__WEBPACK_IMPORTED_MODULE_3__.slice)(begin, stylis__WEBPACK_IMPORTED_MODULE_3__.position);
};
var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;
  do {
    switch ((0,stylis__WEBPACK_IMPORTED_MODULE_3__.token)(character)) {
      case 0:
        // &\f
        if (character === 38 && (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(stylis__WEBPACK_IMPORTED_MODULE_3__.position - 1, points, index);
        break;
      case 2:
        parsed[index] += (0,stylis__WEBPACK_IMPORTED_MODULE_3__.delimit)(character);
        break;
      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.peek)() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += (0,stylis__WEBPACK_IMPORTED_MODULE_4__.from)(character);
    }
  } while (character = (0,stylis__WEBPACK_IMPORTED_MODULE_3__.next)());
  return parsed;
};
var getRules = function getRules(value, points) {
  return (0,stylis__WEBPACK_IMPORTED_MODULE_3__.dealloc)(toRules((0,stylis__WEBPACK_IMPORTED_MODULE_3__.alloc)(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent ||
  // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value,
    parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case

  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */ && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;
    if (
    // charcode for l
    value.charCodeAt(0) === 108 &&
    // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';
var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? children[0].children :
      // global rule at the root level
      children;
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];
        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version

        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};
var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user

var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};
var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
var defaultStylisPlugins = [stylis__WEBPACK_IMPORTED_MODULE_5__.prefixer];
var createCache = function createCache(options) {
  var key = options.key;
  if ( true && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');
      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if (true) {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }
      nodesToHydrate.push(node);
    });
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stylis__WEBPACK_IMPORTED_MODULE_6__.stringify,  true ? function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== stylis__WEBPACK_IMPORTED_MODULE_7__.COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } : 0];
    var serializer = (0,stylis__WEBPACK_IMPORTED_MODULE_5__.middleware)(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis(styles) {
      return (0,stylis__WEBPACK_IMPORTED_MODULE_6__.serialize)((0,stylis__WEBPACK_IMPORTED_MODULE_8__.compile)(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if ( true && serialized.map !== undefined) {
        currentSheet = {
          insert: function insert(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key,
    sheet: new _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__.StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCache);

/***/ }),

/***/ "../../node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleSheet": () => (/* binding */ StyleSheet)
/* harmony export */ });
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */

  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);
  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }
  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}
var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;
    this._insertTag = function (tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === undefined ? "development" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if ( true && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet;
}();


/***/ }),

/***/ "../../node_modules/lodash/_arrayAggregator.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_arrayAggregator.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
    length = array == null ? 0 : array.length;
  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
module.exports = arrayAggregator;

/***/ }),

/***/ "../../node_modules/lodash/_arrayIncludes.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_arrayIncludes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "../../node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}
module.exports = arrayIncludes;

/***/ }),

/***/ "../../node_modules/lodash/_arrayIncludesWith.js":
/*!*******************************************************!*\
  !*** ../../node_modules/lodash/_arrayIncludesWith.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
    length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
module.exports = arrayIncludesWith;

/***/ }),

/***/ "../../node_modules/lodash/_baseAggregator.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_baseAggregator.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "../../node_modules/lodash/_baseEach.js");

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function (value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}
module.exports = baseAggregator;

/***/ }),

/***/ "../../node_modules/lodash/_baseClamp.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseClamp.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
module.exports = baseClamp;

/***/ }),

/***/ "../../node_modules/lodash/_baseFindIndex.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_baseFindIndex.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
    index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
module.exports = baseFindIndex;

/***/ }),

/***/ "../../node_modules/lodash/_baseFlatten.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_baseFlatten.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../../node_modules/lodash/_arrayPush.js"),
  isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "../../node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
    length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
module.exports = baseFlatten;

/***/ }),

/***/ "../../node_modules/lodash/_baseHas.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_baseHas.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}
module.exports = baseHas;

/***/ }),

/***/ "../../node_modules/lodash/_baseIndexOf.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_baseIndexOf.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "../../node_modules/lodash/_baseFindIndex.js"),
  baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "../../node_modules/lodash/_baseIsNaN.js"),
  strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "../../node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
module.exports = baseIndexOf;

/***/ }),

/***/ "../../node_modules/lodash/_baseIsNaN.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseIsNaN.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}
module.exports = baseIsNaN;

/***/ }),

/***/ "../../node_modules/lodash/_baseRange.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseRange.js ***!
  \***********************************************/
/***/ ((module) => {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
  nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
    length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
    result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}
module.exports = baseRange;

/***/ }),

/***/ "../../node_modules/lodash/_baseTrim.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseTrim.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "../../node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}
module.exports = baseTrim;

/***/ }),

/***/ "../../node_modules/lodash/_baseUniq.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseUniq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "../../node_modules/lodash/_SetCache.js"),
  arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "../../node_modules/lodash/_arrayIncludes.js"),
  arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "../../node_modules/lodash/_arrayIncludesWith.js"),
  cacheHas = __webpack_require__(/*! ./_cacheHas */ "../../node_modules/lodash/_cacheHas.js"),
  createSet = __webpack_require__(/*! ./_createSet */ "../../node_modules/lodash/_createSet.js"),
  setToArray = __webpack_require__(/*! ./_setToArray */ "../../node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
    includes = arrayIncludes,
    length = array.length,
    isCommon = true,
    result = [],
    seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
      computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}
module.exports = baseUniq;

/***/ }),

/***/ "../../node_modules/lodash/_createAggregator.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_createAggregator.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayAggregator = __webpack_require__(/*! ./_arrayAggregator */ "../../node_modules/lodash/_arrayAggregator.js"),
  baseAggregator = __webpack_require__(/*! ./_baseAggregator */ "../../node_modules/lodash/_baseAggregator.js"),
  baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "../../node_modules/lodash/_baseIteratee.js"),
  isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js");

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function (collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
      accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}
module.exports = createAggregator;

/***/ }),

/***/ "../../node_modules/lodash/_createRange.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_createRange.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRange = __webpack_require__(/*! ./_baseRange */ "../../node_modules/lodash/_baseRange.js"),
  isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "../../node_modules/lodash/_isIterateeCall.js"),
  toFinite = __webpack_require__(/*! ./toFinite */ "../../node_modules/lodash/toFinite.js");

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function (start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}
module.exports = createRange;

/***/ }),

/***/ "../../node_modules/lodash/_createSet.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_createSet.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(/*! ./_Set */ "../../node_modules/lodash/_Set.js"),
  noop = __webpack_require__(/*! ./noop */ "../../node_modules/lodash/noop.js"),
  setToArray = __webpack_require__(/*! ./_setToArray */ "../../node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),

/***/ "../../node_modules/lodash/_isFlattenable.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_isFlattenable.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js"),
  isArguments = __webpack_require__(/*! ./isArguments */ "../../node_modules/lodash/isArguments.js"),
  isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
module.exports = isFlattenable;

/***/ }),

/***/ "../../node_modules/lodash/_strictIndexOf.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_strictIndexOf.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
    length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
module.exports = strictIndexOf;

/***/ }),

/***/ "../../node_modules/lodash/_trimmedEndIndex.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_trimmedEndIndex.js ***!
  \*****************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}
module.exports = trimmedEndIndex;

/***/ }),

/***/ "../../node_modules/lodash/clamp.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/clamp.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClamp = __webpack_require__(/*! ./_baseClamp */ "../../node_modules/lodash/_baseClamp.js"),
  toNumber = __webpack_require__(/*! ./toNumber */ "../../node_modules/lodash/toNumber.js");

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
module.exports = clamp;

/***/ }),

/***/ "../../node_modules/lodash/debounce.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/debounce.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
  now = __webpack_require__(/*! ./now */ "../../node_modules/lodash/now.js"),
  toNumber = __webpack_require__(/*! ./toNumber */ "../../node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
  nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
module.exports = debounce;

/***/ }),

/***/ "../../node_modules/lodash/flatten.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/flatten.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "../../node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
module.exports = flatten;

/***/ }),

/***/ "../../node_modules/lodash/groupBy.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/groupBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js"),
  createAggregator = __webpack_require__(/*! ./_createAggregator */ "../../node_modules/lodash/_createAggregator.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function (result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});
module.exports = groupBy;

/***/ }),

/***/ "../../node_modules/lodash/has.js":
/*!****************************************!*\
  !*** ../../node_modules/lodash/has.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(/*! ./_baseHas */ "../../node_modules/lodash/_baseHas.js"),
  hasPath = __webpack_require__(/*! ./_hasPath */ "../../node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}
module.exports = has;

/***/ }),

/***/ "../../node_modules/lodash/noop.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/noop.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}
module.exports = noop;

/***/ }),

/***/ "../../node_modules/lodash/now.js":
/*!****************************************!*\
  !*** ../../node_modules/lodash/now.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function () {
  return root.Date.now();
};
module.exports = now;

/***/ }),

/***/ "../../node_modules/lodash/range.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/range.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createRange = __webpack_require__(/*! ./_createRange */ "../../node_modules/lodash/_createRange.js");

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();
module.exports = range;

/***/ }),

/***/ "../../node_modules/lodash/throttle.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/throttle.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debounce = __webpack_require__(/*! ./debounce */ "../../node_modules/lodash/debounce.js"),
  isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
module.exports = throttle;

/***/ }),

/***/ "../../node_modules/lodash/toFinite.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/toFinite.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "../../node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
  MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
module.exports = toFinite;

/***/ }),

/***/ "../../node_modules/lodash/toNumber.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/toNumber.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "../../node_modules/lodash/_baseTrim.js"),
  isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
  isSymbol = __webpack_require__(/*! ./isSymbol */ "../../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = toNumber;

/***/ }),

/***/ "../../node_modules/lodash/uniq.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/uniq.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseUniq = __webpack_require__(/*! ./_baseUniq */ "../../node_modules/lodash/_baseUniq.js");

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}
module.exports = uniq;

/***/ }),

/***/ "../../node_modules/react-easy-swipe/lib/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/react-easy-swipe/lib/index.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./react-swipe */ "../../node_modules/react-easy-swipe/lib/react-swipe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (exports, _reactSwipe) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _reactSwipe2 = _interopRequireDefault(_reactSwipe);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = _reactSwipe2.default;
});

/***/ }),

/***/ "../../node_modules/react-easy-swipe/lib/react-swipe.js":
/*!**************************************************************!*\
  !*** ../../node_modules/react-easy-swipe/lib/react-swipe.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! react */ "../../node_modules/react/index.js"), __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (exports, _react, _propTypes) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;
  var _react2 = _interopRequireDefault(_react);
  var _propTypes2 = _interopRequireDefault(_propTypes);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function _objectWithoutProperties(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }
    return target;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var supportsCaptureOption = false;
  function setHasSupportToCaptureOption(hasSupport) {
    supportsCaptureOption = hasSupport;
  }
  try {
    addEventListener('test', null, Object.defineProperty({}, 'capture', {
      get: function get() {
        setHasSupportToCaptureOption(true);
      }
    }));
  } catch (e) {} // eslint-disable-line no-empty

  function getSafeEventHandlerOpts() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      capture: true
    };
    return supportsCaptureOption ? options : options.capture;
  }

  /**
   * [getPosition returns a position element that works for mouse or touch events]
   * @param  {[Event]} event [the received event]
   * @return {[Object]}      [x and y coords]
   */
  function getPosition(event) {
    if ('touches' in event) {
      var _event$touches$ = event.touches[0],
        pageX = _event$touches$.pageX,
        pageY = _event$touches$.pageY;
      return {
        x: pageX,
        y: pageY
      };
    }
    var screenX = event.screenX,
      screenY = event.screenY;
    return {
      x: screenX,
      y: screenY
    };
  }
  var ReactSwipe = function (_Component) {
    _inherits(ReactSwipe, _Component);
    function ReactSwipe() {
      var _ref;
      _classCallCheck(this, ReactSwipe);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));
      _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);
      _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);
      _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);
      _this._onMouseDown = _this._onMouseDown.bind(_this);
      _this._onMouseMove = _this._onMouseMove.bind(_this);
      _this._onMouseUp = _this._onMouseUp.bind(_this);
      _this._setSwiperRef = _this._setSwiperRef.bind(_this);
      return _this;
    }
    _createClass(ReactSwipe, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.swiper) {
          this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({
            capture: true,
            passive: false
          }));
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.swiper) {
          this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({
            capture: true,
            passive: false
          }));
        }
      }
    }, {
      key: '_onMouseDown',
      value: function _onMouseDown(event) {
        if (!this.props.allowMouseEvents) {
          return;
        }
        this.mouseDown = true;
        document.addEventListener('mouseup', this._onMouseUp);
        document.addEventListener('mousemove', this._onMouseMove);
        this._handleSwipeStart(event);
      }
    }, {
      key: '_onMouseMove',
      value: function _onMouseMove(event) {
        if (!this.mouseDown) {
          return;
        }
        this._handleSwipeMove(event);
      }
    }, {
      key: '_onMouseUp',
      value: function _onMouseUp(event) {
        this.mouseDown = false;
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('mousemove', this._onMouseMove);
        this._handleSwipeEnd(event);
      }
    }, {
      key: '_handleSwipeStart',
      value: function _handleSwipeStart(event) {
        var _getPosition = getPosition(event),
          x = _getPosition.x,
          y = _getPosition.y;
        this.moveStart = {
          x: x,
          y: y
        };
        this.props.onSwipeStart(event);
      }
    }, {
      key: '_handleSwipeMove',
      value: function _handleSwipeMove(event) {
        if (!this.moveStart) {
          return;
        }
        var _getPosition2 = getPosition(event),
          x = _getPosition2.x,
          y = _getPosition2.y;
        var deltaX = x - this.moveStart.x;
        var deltaY = y - this.moveStart.y;
        this.moving = true;

        // handling the responsability of cancelling the scroll to
        // the component handling the event
        var shouldPreventDefault = this.props.onSwipeMove({
          x: deltaX,
          y: deltaY
        }, event);
        if (shouldPreventDefault && event.cancelable) {
          event.preventDefault();
        }
        this.movePosition = {
          deltaX: deltaX,
          deltaY: deltaY
        };
      }
    }, {
      key: '_handleSwipeEnd',
      value: function _handleSwipeEnd(event) {
        this.props.onSwipeEnd(event);
        var tolerance = this.props.tolerance;
        if (this.moving && this.movePosition) {
          if (this.movePosition.deltaX < -tolerance) {
            this.props.onSwipeLeft(1, event);
          } else if (this.movePosition.deltaX > tolerance) {
            this.props.onSwipeRight(1, event);
          }
          if (this.movePosition.deltaY < -tolerance) {
            this.props.onSwipeUp(1, event);
          } else if (this.movePosition.deltaY > tolerance) {
            this.props.onSwipeDown(1, event);
          }
        }
        this.moveStart = null;
        this.moving = false;
        this.movePosition = null;
      }
    }, {
      key: '_setSwiperRef',
      value: function _setSwiperRef(node) {
        this.swiper = node;
        this.props.innerRef(node);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
          tagName = _props.tagName,
          className = _props.className,
          style = _props.style,
          children = _props.children,
          allowMouseEvents = _props.allowMouseEvents,
          onSwipeUp = _props.onSwipeUp,
          onSwipeDown = _props.onSwipeDown,
          onSwipeLeft = _props.onSwipeLeft,
          onSwipeRight = _props.onSwipeRight,
          onSwipeStart = _props.onSwipeStart,
          onSwipeMove = _props.onSwipeMove,
          onSwipeEnd = _props.onSwipeEnd,
          innerRef = _props.innerRef,
          tolerance = _props.tolerance,
          props = _objectWithoutProperties(_props, ['tagName', 'className', 'style', 'children', 'allowMouseEvents', 'onSwipeUp', 'onSwipeDown', 'onSwipeLeft', 'onSwipeRight', 'onSwipeStart', 'onSwipeMove', 'onSwipeEnd', 'innerRef', 'tolerance']);
        return _react2.default.createElement(this.props.tagName, _extends({
          ref: this._setSwiperRef,
          onMouseDown: this._onMouseDown,
          onTouchStart: this._handleSwipeStart,
          onTouchEnd: this._handleSwipeEnd,
          className: className,
          style: style
        }, props), children);
      }
    }]);
    return ReactSwipe;
  }(_react.Component);
  ReactSwipe.displayName = 'ReactSwipe';
  ReactSwipe.propTypes = {
    tagName: _propTypes2.default.string,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.node,
    allowMouseEvents: _propTypes2.default.bool,
    onSwipeUp: _propTypes2.default.func,
    onSwipeDown: _propTypes2.default.func,
    onSwipeLeft: _propTypes2.default.func,
    onSwipeRight: _propTypes2.default.func,
    onSwipeStart: _propTypes2.default.func,
    onSwipeMove: _propTypes2.default.func,
    onSwipeEnd: _propTypes2.default.func,
    innerRef: _propTypes2.default.func,
    tolerance: _propTypes2.default.number.isRequired
  };
  ReactSwipe.defaultProps = {
    tagName: 'div',
    allowMouseEvents: false,
    onSwipeUp: function onSwipeUp() {},
    onSwipeDown: function onSwipeDown() {},
    onSwipeLeft: function onSwipeLeft() {},
    onSwipeRight: function onSwipeRight() {},
    onSwipeStart: function onSwipeStart() {},
    onSwipeMove: function onSwipeMove() {},
    onSwipeEnd: function onSwipeEnd() {},
    innerRef: function innerRef() {},
    tolerance: 0
  };
  exports.default = ReactSwipe;
});

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/CSSTranslate.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/CSSTranslate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = function _default(position, metric, axis) {
  var positionPercent = position === 0 ? position : position + metric;
  var positionCss = axis === 'horizontal' ? [positionPercent, 0, 0] : [0, positionPercent, 0];
  var transitionProp = 'translate3d';
  var translatedPosition = '(' + positionCss.join(',') + ')';
  return transitionProp + translatedPosition;
};
exports["default"] = _default;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fadeAnimationHandler = exports.slideStopSwipingHandler = exports.slideSwipeAnimationHandler = exports.slideAnimationHandler = void 0;
var _react = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
var _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../../CSSTranslate */ "../../node_modules/react-responsive-carousel/lib/js/CSSTranslate.js"));
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/**
 * Main animation handler for the default 'sliding' style animation
 * @param props
 * @param state
 */
var slideAnimationHandler = function slideAnimationHandler(props, state) {
  var returnStyles = {};
  var selectedItem = state.selectedItem;
  var previousItem = selectedItem;
  var lastPosition = _react.Children.count(props.children) - 1;
  var needClonedSlide = props.infiniteLoop && (selectedItem < 0 || selectedItem > lastPosition); // Handle list position if it needs a clone

  if (needClonedSlide) {
    if (previousItem < 0) {
      if (props.centerMode && props.centerSlidePercentage && props.axis === 'horizontal') {
        returnStyles.itemListStyle = (0, _utils.setPosition)(-(lastPosition + 2) * props.centerSlidePercentage - (100 - props.centerSlidePercentage) / 2, props.axis);
      } else {
        returnStyles.itemListStyle = (0, _utils.setPosition)(-(lastPosition + 2) * 100, props.axis);
      }
    } else if (previousItem > lastPosition) {
      returnStyles.itemListStyle = (0, _utils.setPosition)(0, props.axis);
    }
    return returnStyles;
  }
  var currentPosition = (0, _utils.getPosition)(selectedItem, props); // if 3d is available, let's take advantage of the performance of transform

  var transformProp = (0, _CSSTranslate.default)(currentPosition, '%', props.axis);
  var transitionTime = props.transitionTime + 'ms';
  returnStyles.itemListStyle = {
    WebkitTransform: transformProp,
    msTransform: transformProp,
    OTransform: transformProp,
    transform: transformProp
  };
  if (!state.swiping) {
    returnStyles.itemListStyle = _objectSpread(_objectSpread({}, returnStyles.itemListStyle), {}, {
      WebkitTransitionDuration: transitionTime,
      MozTransitionDuration: transitionTime,
      OTransitionDuration: transitionTime,
      transitionDuration: transitionTime,
      msTransitionDuration: transitionTime
    });
  }
  return returnStyles;
};
/**
 * Swiping animation handler for the default 'sliding' style animation
 * @param delta
 * @param props
 * @param state
 * @param setState
 */

exports.slideAnimationHandler = slideAnimationHandler;
var slideSwipeAnimationHandler = function slideSwipeAnimationHandler(delta, props, state, setState) {
  var returnStyles = {};
  var isHorizontal = props.axis === 'horizontal';
  var childrenLength = _react.Children.count(props.children);
  var initialBoundry = 0;
  var currentPosition = (0, _utils.getPosition)(state.selectedItem, props);
  var finalBoundry = props.infiniteLoop ? (0, _utils.getPosition)(childrenLength - 1, props) - 100 : (0, _utils.getPosition)(childrenLength - 1, props);
  var axisDelta = isHorizontal ? delta.x : delta.y;
  var handledDelta = axisDelta; // prevent user from swiping left out of boundaries

  if (currentPosition === initialBoundry && axisDelta > 0) {
    handledDelta = 0;
  } // prevent user from swiping right out of boundaries

  if (currentPosition === finalBoundry && axisDelta < 0) {
    handledDelta = 0;
  }
  var position = currentPosition + 100 / (state.itemSize / handledDelta);
  var hasMoved = Math.abs(axisDelta) > props.swipeScrollTolerance;
  if (props.infiniteLoop && hasMoved) {
    // When allowing infinite loop, if we slide left from position 0 we reveal the cloned last slide that appears before it
    // if we slide even further we need to jump to other side so it can continue - and vice versa for the last slide
    if (state.selectedItem === 0 && position > -100) {
      position -= childrenLength * 100;
    } else if (state.selectedItem === childrenLength - 1 && position < -childrenLength * 100) {
      position += childrenLength * 100;
    }
  }
  if (!props.preventMovementUntilSwipeScrollTolerance || hasMoved || state.swipeMovementStarted) {
    if (!state.swipeMovementStarted) {
      setState({
        swipeMovementStarted: true
      });
    }
    returnStyles.itemListStyle = (0, _utils.setPosition)(position, props.axis);
  } //allows scroll if the swipe was within the tolerance

  if (hasMoved && !state.cancelClick) {
    setState({
      cancelClick: true
    });
  }
  return returnStyles;
};
/**
 * Default 'sliding' style animination handler for when a swipe action stops.
 * @param props
 * @param state
 */

exports.slideSwipeAnimationHandler = slideSwipeAnimationHandler;
var slideStopSwipingHandler = function slideStopSwipingHandler(props, state) {
  var currentPosition = (0, _utils.getPosition)(state.selectedItem, props);
  var itemListStyle = (0, _utils.setPosition)(currentPosition, props.axis);
  return {
    itemListStyle: itemListStyle
  };
};
/**
 * Main animation handler for the default 'fade' style animation
 * @param props
 * @param state
 */

exports.slideStopSwipingHandler = slideStopSwipingHandler;
var fadeAnimationHandler = function fadeAnimationHandler(props, state) {
  var transitionTime = props.transitionTime + 'ms';
  var transitionTimingFunction = 'ease-in-out';
  var slideStyle = {
    position: 'absolute',
    display: 'block',
    zIndex: -2,
    minHeight: '100%',
    opacity: 0,
    top: 0,
    right: 0,
    left: 0,
    bottom: 0,
    transitionTimingFunction: transitionTimingFunction,
    msTransitionTimingFunction: transitionTimingFunction,
    MozTransitionTimingFunction: transitionTimingFunction,
    WebkitTransitionTimingFunction: transitionTimingFunction,
    OTransitionTimingFunction: transitionTimingFunction
  };
  if (!state.swiping) {
    slideStyle = _objectSpread(_objectSpread({}, slideStyle), {}, {
      WebkitTransitionDuration: transitionTime,
      MozTransitionDuration: transitionTime,
      OTransitionDuration: transitionTime,
      transitionDuration: transitionTime,
      msTransitionDuration: transitionTime
    });
  }
  return {
    slideStyle: slideStyle,
    selectedStyle: _objectSpread(_objectSpread({}, slideStyle), {}, {
      opacity: 1,
      position: 'relative'
    }),
    prevStyle: _objectSpread({}, slideStyle)
  };
};
exports.fadeAnimationHandler = fadeAnimationHandler;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _reactEasySwipe = _interopRequireDefault(__webpack_require__(/*! react-easy-swipe */ "../../node_modules/react-easy-swipe/lib/index.js"));
var _cssClasses = _interopRequireDefault(__webpack_require__(/*! ../../cssClasses */ "../../node_modules/react-responsive-carousel/lib/js/cssClasses.js"));
var _Thumbs = _interopRequireDefault(__webpack_require__(/*! ../Thumbs */ "../../node_modules/react-responsive-carousel/lib/js/components/Thumbs.js"));
var _document = _interopRequireDefault(__webpack_require__(/*! ../../shims/document */ "../../node_modules/react-responsive-carousel/lib/js/shims/document.js"));
var _window = _interopRequireDefault(__webpack_require__(/*! ../../shims/window */ "../../node_modules/react-responsive-carousel/lib/js/shims/window.js"));
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js");
var _animations = __webpack_require__(/*! ./animations */ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();
  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };
  return cache;
}
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache();
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Carousel = /*#__PURE__*/function (_React$Component) {
  _inherits(Carousel, _React$Component);
  var _super = _createSuper(Carousel);

  // @ts-ignore
  function Carousel(props) {
    var _this;
    _classCallCheck(this, Carousel);
    _this = _super.call(this, props);
    _defineProperty(_assertThisInitialized(_this), "thumbsRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "carouselWrapperRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "listRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "itemsRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "timer", void 0);
    _defineProperty(_assertThisInitialized(_this), "animationHandler", void 0);
    _defineProperty(_assertThisInitialized(_this), "setThumbsRef", function (node) {
      _this.thumbsRef = node;
    });
    _defineProperty(_assertThisInitialized(_this), "setCarouselWrapperRef", function (node) {
      _this.carouselWrapperRef = node;
    });
    _defineProperty(_assertThisInitialized(_this), "setListRef", function (node) {
      _this.listRef = node;
    });
    _defineProperty(_assertThisInitialized(_this), "setItemsRef", function (node, index) {
      if (!_this.itemsRef) {
        _this.itemsRef = [];
      }
      _this.itemsRef[index] = node;
    });
    _defineProperty(_assertThisInitialized(_this), "autoPlay", function () {
      if (_react.Children.count(_this.props.children) <= 1) {
        return;
      }
      _this.clearAutoPlay();
      if (!_this.props.autoPlay) {
        return;
      }
      _this.timer = setTimeout(function () {
        _this.increment();
      }, _this.props.interval);
    });
    _defineProperty(_assertThisInitialized(_this), "clearAutoPlay", function () {
      if (_this.timer) clearTimeout(_this.timer);
    });
    _defineProperty(_assertThisInitialized(_this), "resetAutoPlay", function () {
      _this.clearAutoPlay();
      _this.autoPlay();
    });
    _defineProperty(_assertThisInitialized(_this), "stopOnHover", function () {
      _this.setState({
        isMouseEntered: true
      }, _this.clearAutoPlay);
    });
    _defineProperty(_assertThisInitialized(_this), "startOnLeave", function () {
      _this.setState({
        isMouseEntered: false
      }, _this.autoPlay);
    });
    _defineProperty(_assertThisInitialized(_this), "isFocusWithinTheCarousel", function () {
      if (!_this.carouselWrapperRef) {
        return false;
      }
      if ((0, _document.default)().activeElement === _this.carouselWrapperRef || _this.carouselWrapperRef.contains((0, _document.default)().activeElement)) {
        return true;
      }
      return false;
    });
    _defineProperty(_assertThisInitialized(_this), "navigateWithKeyboard", function (e) {
      if (!_this.isFocusWithinTheCarousel()) {
        return;
      }
      var axis = _this.props.axis;
      var isHorizontal = axis === 'horizontal';
      var keyNames = {
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        ArrowLeft: 37
      };
      var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;
      var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;
      if (nextKey === e.keyCode) {
        _this.increment();
      } else if (prevKey === e.keyCode) {
        _this.decrement();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "updateSizes", function () {
      if (!_this.state.initialized || !_this.itemsRef || _this.itemsRef.length === 0) {
        return;
      }
      var isHorizontal = _this.props.axis === 'horizontal';
      var firstItem = _this.itemsRef[0];
      if (!firstItem) {
        return;
      }
      var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;
      _this.setState({
        itemSize: itemSize
      });
      if (_this.thumbsRef) {
        _this.thumbsRef.updateSizes();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "setMountState", function () {
      _this.setState({
        hasMount: true
      });
      _this.updateSizes();
    });
    _defineProperty(_assertThisInitialized(_this), "handleClickItem", function (index, item) {
      if (_react.Children.count(_this.props.children) === 0) {
        return;
      }
      if (_this.state.cancelClick) {
        _this.setState({
          cancelClick: false
        });
        return;
      }
      _this.props.onClickItem(index, item);
      if (index !== _this.state.selectedItem) {
        _this.setState({
          selectedItem: index
        });
      }
    });
    _defineProperty(_assertThisInitialized(_this), "handleOnChange", function (index, item) {
      if (_react.Children.count(_this.props.children) <= 1) {
        return;
      }
      _this.props.onChange(index, item);
    });
    _defineProperty(_assertThisInitialized(_this), "handleClickThumb", function (index, item) {
      _this.props.onClickThumb(index, item);
      _this.moveTo(index);
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeStart", function (event) {
      _this.setState({
        swiping: true
      });
      _this.props.onSwipeStart(event);
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeEnd", function (event) {
      _this.setState({
        swiping: false,
        cancelClick: false,
        swipeMovementStarted: false
      });
      _this.props.onSwipeEnd(event);
      _this.clearAutoPlay();
      if (_this.state.autoPlay) {
        _this.autoPlay();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeMove", function (delta, event) {
      _this.props.onSwipeMove(event);
      var animationHandlerResponse = _this.props.swipeAnimationHandler(delta, _this.props, _this.state, _this.setState.bind(_assertThisInitialized(_this)));
      _this.setState(_objectSpread({}, animationHandlerResponse)); // If we have not moved, we should have an empty object returned
      // Return false to allow scrolling when not swiping

      return !!Object.keys(animationHandlerResponse).length;
    });
    _defineProperty(_assertThisInitialized(_this), "decrement", function () {
      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      _this.moveTo(_this.state.selectedItem - (typeof positions === 'number' ? positions : 1));
    });
    _defineProperty(_assertThisInitialized(_this), "increment", function () {
      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      _this.moveTo(_this.state.selectedItem + (typeof positions === 'number' ? positions : 1));
    });
    _defineProperty(_assertThisInitialized(_this), "moveTo", function (position) {
      if (typeof position !== 'number') {
        return;
      }
      var lastPosition = _react.Children.count(_this.props.children) - 1;
      if (position < 0) {
        position = _this.props.infiniteLoop ? lastPosition : 0;
      }
      if (position > lastPosition) {
        position = _this.props.infiniteLoop ? 0 : lastPosition;
      }
      _this.selectItem({
        // if it's not a slider, we don't need to set position here
        selectedItem: position
      }); // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once
      // and will result in the interval function not being cleared correctly.

      if (_this.state.autoPlay && _this.state.isMouseEntered === false) {
        _this.resetAutoPlay();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onClickNext", function () {
      _this.increment(1);
    });
    _defineProperty(_assertThisInitialized(_this), "onClickPrev", function () {
      _this.decrement(1);
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeForward", function () {
      _this.increment(1);
      if (_this.props.emulateTouch) {
        _this.setState({
          cancelClick: true
        });
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeBackwards", function () {
      _this.decrement(1);
      if (_this.props.emulateTouch) {
        _this.setState({
          cancelClick: true
        });
      }
    });
    _defineProperty(_assertThisInitialized(_this), "changeItem", function (newIndex) {
      return function (e) {
        if (!(0, _utils.isKeyboardEvent)(e) || e.key === 'Enter') {
          _this.moveTo(newIndex);
        }
      };
    });
    _defineProperty(_assertThisInitialized(_this), "selectItem", function (state) {
      // Merge in the new state while updating updating previous item
      _this.setState(_objectSpread({
        previousItem: _this.state.selectedItem
      }, state), function () {
        // Run animation handler and update styles based on it
        _this.setState(_this.animationHandler(_this.props, _this.state));
      });
      _this.handleOnChange(state.selectedItem, _react.Children.toArray(_this.props.children)[state.selectedItem]);
    });
    _defineProperty(_assertThisInitialized(_this), "getInitialImage", function () {
      var selectedItem = _this.props.selectedItem;
      var item = _this.itemsRef && _this.itemsRef[selectedItem];
      var images = item && item.getElementsByTagName('img') || [];
      return images[0];
    });
    _defineProperty(_assertThisInitialized(_this), "getVariableItemHeight", function (position) {
      var item = _this.itemsRef && _this.itemsRef[position];
      if (_this.state.hasMount && item && item.children.length) {
        var slideImages = item.children[0].getElementsByTagName('img') || [];
        if (slideImages.length > 0) {
          var image = slideImages[0];
          if (!image.complete) {
            // if the image is still loading, the size won't be available so we trigger a new render after it's done
            var onImageLoad = function onImageLoad() {
              _this.forceUpdate();
              image.removeEventListener('load', onImageLoad);
            };
            image.addEventListener('load', onImageLoad);
          }
        } // try to get img first, if img not there find first display tag

        var displayItem = slideImages[0] || item.children[0];
        var height = displayItem.clientHeight;
        return height > 0 ? height : null;
      }
      return null;
    });
    var initState = {
      initialized: false,
      previousItem: props.selectedItem,
      selectedItem: props.selectedItem,
      hasMount: false,
      isMouseEntered: false,
      autoPlay: props.autoPlay,
      swiping: false,
      swipeMovementStarted: false,
      cancelClick: false,
      itemSize: 1,
      itemListStyle: {},
      slideStyle: {},
      selectedStyle: {},
      prevStyle: {}
    };
    _this.animationHandler = typeof props.animationHandler === 'function' && props.animationHandler || props.animationHandler === 'fade' && _animations.fadeAnimationHandler || _animations.slideAnimationHandler;
    _this.state = _objectSpread(_objectSpread({}, initState), _this.animationHandler(props, initState));
    return _this;
  }
  _createClass(Carousel, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.props.children) {
        return;
      }
      this.setupCarousel();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (!prevProps.children && this.props.children && !this.state.initialized) {
        this.setupCarousel();
      }
      if (!prevProps.autoFocus && this.props.autoFocus) {
        this.forceFocus();
      }
      if (prevState.swiping && !this.state.swiping) {
        // We stopped swiping, ensure we are heading to the new/current slide and not stuck
        this.setState(_objectSpread({}, this.props.stopSwipingHandler(this.props, this.state)));
      }
      if (prevProps.selectedItem !== this.props.selectedItem || prevProps.centerMode !== this.props.centerMode) {
        this.updateSizes();
        this.moveTo(this.props.selectedItem);
      }
      if (prevProps.autoPlay !== this.props.autoPlay) {
        if (this.props.autoPlay) {
          this.setupAutoPlay();
        } else {
          this.destroyAutoPlay();
        }
        this.setState({
          autoPlay: this.props.autoPlay
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.destroyCarousel();
    }
  }, {
    key: "setupCarousel",
    value: function setupCarousel() {
      var _this2 = this;
      this.bindEvents();
      if (this.state.autoPlay && _react.Children.count(this.props.children) > 1) {
        this.setupAutoPlay();
      }
      if (this.props.autoFocus) {
        this.forceFocus();
      }
      this.setState({
        initialized: true
      }, function () {
        var initialImage = _this2.getInitialImage();
        if (initialImage && !initialImage.complete) {
          // if it's a carousel of images, we set the mount state after the first image is loaded
          initialImage.addEventListener('load', _this2.setMountState);
        } else {
          _this2.setMountState();
        }
      });
    }
  }, {
    key: "destroyCarousel",
    value: function destroyCarousel() {
      if (this.state.initialized) {
        this.unbindEvents();
        this.destroyAutoPlay();
      }
    }
  }, {
    key: "setupAutoPlay",
    value: function setupAutoPlay() {
      this.autoPlay();
      var carouselWrapper = this.carouselWrapperRef;
      if (this.props.stopOnHover && carouselWrapper) {
        carouselWrapper.addEventListener('mouseenter', this.stopOnHover);
        carouselWrapper.addEventListener('mouseleave', this.startOnLeave);
      }
    }
  }, {
    key: "destroyAutoPlay",
    value: function destroyAutoPlay() {
      this.clearAutoPlay();
      var carouselWrapper = this.carouselWrapperRef;
      if (this.props.stopOnHover && carouselWrapper) {
        carouselWrapper.removeEventListener('mouseenter', this.stopOnHover);
        carouselWrapper.removeEventListener('mouseleave', this.startOnLeave);
      }
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      // as the widths are calculated, we need to resize
      // the carousel when the window is resized
      (0, _window.default)().addEventListener('resize', this.updateSizes); // issue #2 - image loading smaller

      (0, _window.default)().addEventListener('DOMContentLoaded', this.updateSizes);
      if (this.props.useKeyboardArrows) {
        (0, _document.default)().addEventListener('keydown', this.navigateWithKeyboard);
      }
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      // removing listeners
      (0, _window.default)().removeEventListener('resize', this.updateSizes);
      (0, _window.default)().removeEventListener('DOMContentLoaded', this.updateSizes);
      var initialImage = this.getInitialImage();
      if (initialImage) {
        initialImage.removeEventListener('load', this.setMountState);
      }
      if (this.props.useKeyboardArrows) {
        (0, _document.default)().removeEventListener('keydown', this.navigateWithKeyboard);
      }
    }
  }, {
    key: "forceFocus",
    value: function forceFocus() {
      var _this$carouselWrapper;
      (_this$carouselWrapper = this.carouselWrapperRef) === null || _this$carouselWrapper === void 0 ? void 0 : _this$carouselWrapper.focus();
    }
  }, {
    key: "renderItems",
    value: function renderItems(isClone) {
      var _this3 = this;
      if (!this.props.children) {
        return [];
      }
      return _react.Children.map(this.props.children, function (item, index) {
        var isSelected = index === _this3.state.selectedItem;
        var isPrevious = index === _this3.state.previousItem;
        var style = isSelected && _this3.state.selectedStyle || isPrevious && _this3.state.prevStyle || _this3.state.slideStyle || {};
        if (_this3.props.centerMode && _this3.props.axis === 'horizontal') {
          style = _objectSpread(_objectSpread({}, style), {}, {
            minWidth: _this3.props.centerSlidePercentage + '%'
          });
        }
        if (_this3.state.swiping && _this3.state.swipeMovementStarted) {
          style = _objectSpread(_objectSpread({}, style), {}, {
            pointerEvents: 'none'
          });
        }
        var slideProps = {
          ref: function ref(e) {
            return _this3.setItemsRef(e, index);
          },
          key: 'itemKey' + index + (isClone ? 'clone' : ''),
          className: _cssClasses.default.ITEM(true, index === _this3.state.selectedItem, index === _this3.state.previousItem),
          onClick: _this3.handleClickItem.bind(_this3, index, item),
          style: style
        };
        return /*#__PURE__*/_react.default.createElement("li", slideProps, _this3.props.renderItem(item, {
          isSelected: index === _this3.state.selectedItem,
          isPrevious: index === _this3.state.previousItem
        }));
      });
    }
  }, {
    key: "renderControls",
    value: function renderControls() {
      var _this4 = this;
      var _this$props = this.props,
        showIndicators = _this$props.showIndicators,
        labels = _this$props.labels,
        renderIndicator = _this$props.renderIndicator,
        children = _this$props.children;
      if (!showIndicators) {
        return null;
      }
      return /*#__PURE__*/_react.default.createElement("ul", {
        className: "control-dots"
      }, _react.Children.map(children, function (_, index) {
        return renderIndicator && renderIndicator(_this4.changeItem(index), index === _this4.state.selectedItem, index, labels.item);
      }));
    }
  }, {
    key: "renderStatus",
    value: function renderStatus() {
      if (!this.props.showStatus) {
        return null;
      }
      return /*#__PURE__*/_react.default.createElement("p", {
        className: "carousel-status"
      }, this.props.statusFormatter(this.state.selectedItem + 1, _react.Children.count(this.props.children)));
    }
  }, {
    key: "renderThumbs",
    value: function renderThumbs() {
      if (!this.props.showThumbs || !this.props.children || _react.Children.count(this.props.children) === 0) {
        return null;
      }
      return /*#__PURE__*/_react.default.createElement(_Thumbs.default, {
        ref: this.setThumbsRef,
        onSelectItem: this.handleClickThumb,
        selectedItem: this.state.selectedItem,
        transitionTime: this.props.transitionTime,
        thumbWidth: this.props.thumbWidth,
        labels: this.props.labels,
        emulateTouch: this.props.emulateTouch
      }, this.props.renderThumbs(this.props.children));
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;
      if (!this.props.children || _react.Children.count(this.props.children) === 0) {
        return null;
      }
      var isSwipeable = this.props.swipeable && _react.Children.count(this.props.children) > 1;
      var isHorizontal = this.props.axis === 'horizontal';
      var canShowArrows = this.props.showArrows && _react.Children.count(this.props.children) > 1; // show left arrow?

      var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop) || false; // show right arrow

      var hasNext = canShowArrows && (this.state.selectedItem < _react.Children.count(this.props.children) - 1 || this.props.infiniteLoop) || false;
      var itemsClone = this.renderItems(true);
      var firstClone = itemsClone.shift();
      var lastClone = itemsClone.pop();
      var swiperProps = {
        className: _cssClasses.default.SLIDER(true, this.state.swiping),
        onSwipeMove: this.onSwipeMove,
        onSwipeStart: this.onSwipeStart,
        onSwipeEnd: this.onSwipeEnd,
        style: this.state.itemListStyle,
        tolerance: this.props.swipeScrollTolerance
      };
      var containerStyles = {};
      if (isHorizontal) {
        swiperProps.onSwipeLeft = this.onSwipeForward;
        swiperProps.onSwipeRight = this.onSwipeBackwards;
        if (this.props.dynamicHeight) {
          var itemHeight = this.getVariableItemHeight(this.state.selectedItem); // swiperProps.style.height = itemHeight || 'auto';

          containerStyles.height = itemHeight || 'auto';
        }
      } else {
        swiperProps.onSwipeUp = this.props.verticalSwipe === 'natural' ? this.onSwipeBackwards : this.onSwipeForward;
        swiperProps.onSwipeDown = this.props.verticalSwipe === 'natural' ? this.onSwipeForward : this.onSwipeBackwards;
        swiperProps.style = _objectSpread(_objectSpread({}, swiperProps.style), {}, {
          height: this.state.itemSize
        });
        containerStyles.height = this.state.itemSize;
      }
      return /*#__PURE__*/_react.default.createElement("div", {
        "aria-label": this.props.ariaLabel,
        className: _cssClasses.default.ROOT(this.props.className),
        ref: this.setCarouselWrapperRef,
        tabIndex: this.props.useKeyboardArrows ? 0 : undefined
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: _cssClasses.default.CAROUSEL(true),
        style: {
          width: this.props.width
        }
      }, this.renderControls(), this.props.renderArrowPrev(this.onClickPrev, hasPrev, this.props.labels.leftArrow), /*#__PURE__*/_react.default.createElement("div", {
        className: _cssClasses.default.WRAPPER(true, this.props.axis),
        style: containerStyles
      }, isSwipeable ? /*#__PURE__*/_react.default.createElement(_reactEasySwipe.default, _extends({
        tagName: "ul",
        innerRef: this.setListRef
      }, swiperProps, {
        allowMouseEvents: this.props.emulateTouch
      }), this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone) : /*#__PURE__*/_react.default.createElement("ul", {
        className: _cssClasses.default.SLIDER(true, this.state.swiping),
        ref: function ref(node) {
          return _this5.setListRef(node);
        },
        style: this.state.itemListStyle || {}
      }, this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone)), this.props.renderArrowNext(this.onClickNext, hasNext, this.props.labels.rightArrow), this.renderStatus()), this.renderThumbs());
    }
  }]);
  return Carousel;
}(_react.default.Component);
exports["default"] = Carousel;
_defineProperty(Carousel, "displayName", 'Carousel');
_defineProperty(Carousel, "defaultProps", {
  ariaLabel: undefined,
  axis: 'horizontal',
  centerSlidePercentage: 80,
  interval: 3000,
  labels: {
    leftArrow: 'previous slide / item',
    rightArrow: 'next slide / item',
    item: 'slide item'
  },
  onClickItem: _utils.noop,
  onClickThumb: _utils.noop,
  onChange: _utils.noop,
  onSwipeStart: function onSwipeStart() {},
  onSwipeEnd: function onSwipeEnd() {},
  onSwipeMove: function onSwipeMove() {
    return false;
  },
  preventMovementUntilSwipeScrollTolerance: false,
  renderArrowPrev: function renderArrowPrev(onClickHandler, hasPrev, label) {
    return /*#__PURE__*/_react.default.createElement("button", {
      type: "button",
      "aria-label": label,
      className: _cssClasses.default.ARROW_PREV(!hasPrev),
      onClick: onClickHandler
    });
  },
  renderArrowNext: function renderArrowNext(onClickHandler, hasNext, label) {
    return /*#__PURE__*/_react.default.createElement("button", {
      type: "button",
      "aria-label": label,
      className: _cssClasses.default.ARROW_NEXT(!hasNext),
      onClick: onClickHandler
    });
  },
  renderIndicator: function renderIndicator(onClickHandler, isSelected, index, label) {
    return /*#__PURE__*/_react.default.createElement("li", {
      className: _cssClasses.default.DOT(isSelected),
      onClick: onClickHandler,
      onKeyDown: onClickHandler,
      value: index,
      key: index,
      role: "button",
      tabIndex: 0,
      "aria-label": "".concat(label, " ").concat(index + 1)
    });
  },
  renderItem: function renderItem(item) {
    return item;
  },
  renderThumbs: function renderThumbs(children) {
    var images = _react.Children.map(children, function (item) {
      var img = item; // if the item is not an image, try to find the first image in the item's children.

      if (item.type !== 'img') {
        img = _react.Children.toArray(item.props.children).find(function (children) {
          return children.type === 'img';
        });
      }
      if (!img) {
        return undefined;
      }
      return img;
    });
    if (images.filter(function (image) {
      return image;
    }).length === 0) {
      console.warn("No images found! Can't build the thumb list without images. If you don't need thumbs, set showThumbs={false} in the Carousel. Note that it's not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md");
      return [];
    }
    return images;
  },
  statusFormatter: _utils.defaultStatusFormatter,
  selectedItem: 0,
  showArrows: true,
  showIndicators: true,
  showStatus: true,
  showThumbs: true,
  stopOnHover: true,
  swipeScrollTolerance: 5,
  swipeable: true,
  transitionTime: 350,
  verticalSwipe: 'standard',
  width: '100%',
  animationHandler: 'slide',
  swipeAnimationHandler: _animations.slideSwipeAnimationHandler,
  stopSwipingHandler: _animations.slideStopSwipingHandler
});

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js ***!
  \****************************************************************************************/
/***/ (() => {

"use strict";


/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setPosition = exports.getPosition = exports.isKeyboardEvent = exports.defaultStatusFormatter = exports.noop = void 0;
var _react = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
var _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../../CSSTranslate */ "../../node_modules/react-responsive-carousel/lib/js/CSSTranslate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var noop = function noop() {};
exports.noop = noop;
var defaultStatusFormatter = function defaultStatusFormatter(current, total) {
  return "".concat(current, " of ").concat(total);
};
exports.defaultStatusFormatter = defaultStatusFormatter;
var isKeyboardEvent = function isKeyboardEvent(e) {
  return e ? e.hasOwnProperty('key') : false;
};
/**
 * Gets the list 'position' relative to a current index
 * @param index
 */

exports.isKeyboardEvent = isKeyboardEvent;
var getPosition = function getPosition(index, props) {
  if (props.infiniteLoop) {
    // index has to be added by 1 because of the first cloned slide
    ++index;
  }
  if (index === 0) {
    return 0;
  }
  var childrenLength = _react.Children.count(props.children);
  if (props.centerMode && props.axis === 'horizontal') {
    var currentPosition = -index * props.centerSlidePercentage;
    var lastPosition = childrenLength - 1;
    if (index && (index !== lastPosition || props.infiniteLoop)) {
      currentPosition += (100 - props.centerSlidePercentage) / 2;
    } else if (index === lastPosition) {
      currentPosition += 100 - props.centerSlidePercentage;
    }
    return currentPosition;
  }
  return -index * 100;
};
/**
 * Sets the 'position' transform for sliding animations
 * @param position
 * @param forceReflow
 */

exports.getPosition = getPosition;
var setPosition = function setPosition(position, axis) {
  var style = {};
  ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {
    // @ts-ignore
    style[prop] = (0, _CSSTranslate.default)(position, '%', axis);
  });
  return style;
};
exports.setPosition = setPosition;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/components/Thumbs.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/components/Thumbs.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _cssClasses = _interopRequireDefault(__webpack_require__(/*! ../cssClasses */ "../../node_modules/react-responsive-carousel/lib/js/cssClasses.js"));
var _dimensions = __webpack_require__(/*! ../dimensions */ "../../node_modules/react-responsive-carousel/lib/js/dimensions.js");
var _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../CSSTranslate */ "../../node_modules/react-responsive-carousel/lib/js/CSSTranslate.js"));
var _reactEasySwipe = _interopRequireDefault(__webpack_require__(/*! react-easy-swipe */ "../../node_modules/react-easy-swipe/lib/index.js"));
var _window = _interopRequireDefault(__webpack_require__(/*! ../shims/window */ "../../node_modules/react-responsive-carousel/lib/js/shims/window.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();
  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };
  return cache;
}
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache();
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var isKeyboardEvent = function isKeyboardEvent(e) {
  return e.hasOwnProperty('key');
};
var Thumbs = /*#__PURE__*/function (_Component) {
  _inherits(Thumbs, _Component);
  var _super = _createSuper(Thumbs);
  function Thumbs(_props) {
    var _this;
    _classCallCheck(this, Thumbs);
    _this = _super.call(this, _props);
    _defineProperty(_assertThisInitialized(_this), "itemsWrapperRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "itemsListRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "thumbsRef", void 0);
    _defineProperty(_assertThisInitialized(_this), "setItemsWrapperRef", function (node) {
      _this.itemsWrapperRef = node;
    });
    _defineProperty(_assertThisInitialized(_this), "setItemsListRef", function (node) {
      _this.itemsListRef = node;
    });
    _defineProperty(_assertThisInitialized(_this), "setThumbsRef", function (node, index) {
      if (!_this.thumbsRef) {
        _this.thumbsRef = [];
      }
      _this.thumbsRef[index] = node;
    });
    _defineProperty(_assertThisInitialized(_this), "updateSizes", function () {
      if (!_this.props.children || !_this.itemsWrapperRef || !_this.thumbsRef) {
        return;
      }
      var total = _react.Children.count(_this.props.children);
      var wrapperSize = _this.itemsWrapperRef.clientWidth;
      var itemSize = _this.props.thumbWidth ? _this.props.thumbWidth : (0, _dimensions.outerWidth)(_this.thumbsRef[0]);
      var visibleItems = Math.floor(wrapperSize / itemSize);
      var showArrows = visibleItems < total;
      var lastPosition = showArrows ? total - visibleItems : 0;
      _this.setState(function (_state, props) {
        return {
          itemSize: itemSize,
          visibleItems: visibleItems,
          firstItem: showArrows ? _this.getFirstItem(props.selectedItem) : 0,
          lastPosition: lastPosition,
          showArrows: showArrows
        };
      });
    });
    _defineProperty(_assertThisInitialized(_this), "handleClickItem", function (index, item, e) {
      if (!isKeyboardEvent(e) || e.key === 'Enter') {
        var handler = _this.props.onSelectItem;
        if (typeof handler === 'function') {
          handler(index, item);
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeStart", function () {
      _this.setState({
        swiping: true
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeEnd", function () {
      _this.setState({
        swiping: false
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onSwipeMove", function (delta) {
      var deltaX = delta.x;
      if (!_this.state.itemSize || !_this.itemsWrapperRef || !_this.state.visibleItems) {
        return false;
      }
      var leftBoundary = 0;
      var childrenLength = _react.Children.count(_this.props.children);
      var currentPosition = -(_this.state.firstItem * 100) / _this.state.visibleItems;
      var lastLeftItem = Math.max(childrenLength - _this.state.visibleItems, 0);
      var lastLeftBoundary = -lastLeftItem * 100 / _this.state.visibleItems; // prevent user from swiping left out of boundaries

      if (currentPosition === leftBoundary && deltaX > 0) {
        deltaX = 0;
      } // prevent user from swiping right out of boundaries

      if (currentPosition === lastLeftBoundary && deltaX < 0) {
        deltaX = 0;
      }
      var wrapperSize = _this.itemsWrapperRef.clientWidth;
      var position = currentPosition + 100 / (wrapperSize / deltaX); // if 3d isn't available we will use left to move

      if (_this.itemsListRef) {
        ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {
          _this.itemsListRef.style[prop] = (0, _CSSTranslate.default)(position, '%', _this.props.axis);
        });
      }
      return true;
    });
    _defineProperty(_assertThisInitialized(_this), "slideRight", function (positions) {
      _this.moveTo(_this.state.firstItem - (typeof positions === 'number' ? positions : 1));
    });
    _defineProperty(_assertThisInitialized(_this), "slideLeft", function (positions) {
      _this.moveTo(_this.state.firstItem + (typeof positions === 'number' ? positions : 1));
    });
    _defineProperty(_assertThisInitialized(_this), "moveTo", function (position) {
      // position can't be lower than 0
      position = position < 0 ? 0 : position; // position can't be higher than last postion

      position = position >= _this.state.lastPosition ? _this.state.lastPosition : position;
      _this.setState({
        firstItem: position
      });
    });
    _this.state = {
      selectedItem: _props.selectedItem,
      swiping: false,
      showArrows: false,
      firstItem: 0,
      visibleItems: 0,
      lastPosition: 0
    };
    return _this;
  }
  _createClass(Thumbs, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setupThumbs();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.selectedItem !== this.state.selectedItem) {
        this.setState({
          selectedItem: this.props.selectedItem,
          firstItem: this.getFirstItem(this.props.selectedItem)
        });
      }
      if (this.props.children === prevProps.children) {
        return;
      } // This will capture any size changes for arrow adjustments etc.
      // usually in the same render cycle so we don't see any flickers

      this.updateSizes();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.destroyThumbs();
    }
  }, {
    key: "setupThumbs",
    value: function setupThumbs() {
      // as the widths are calculated, we need to resize
      // the carousel when the window is resized
      (0, _window.default)().addEventListener('resize', this.updateSizes); // issue #2 - image loading smaller

      (0, _window.default)().addEventListener('DOMContentLoaded', this.updateSizes); // when the component is rendered we need to calculate
      // the container size to adjust the responsive behaviour

      this.updateSizes();
    }
  }, {
    key: "destroyThumbs",
    value: function destroyThumbs() {
      // removing listeners
      (0, _window.default)().removeEventListener('resize', this.updateSizes);
      (0, _window.default)().removeEventListener('DOMContentLoaded', this.updateSizes);
    }
  }, {
    key: "getFirstItem",
    value: function getFirstItem(selectedItem) {
      var firstItem = selectedItem;
      if (selectedItem >= this.state.lastPosition) {
        firstItem = this.state.lastPosition;
      }
      if (selectedItem < this.state.firstItem + this.state.visibleItems) {
        firstItem = this.state.firstItem;
      }
      if (selectedItem < this.state.firstItem) {
        firstItem = selectedItem;
      }
      return firstItem;
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this2 = this;
      return this.props.children.map(function (img, index) {
        var itemClass = _cssClasses.default.ITEM(false, index === _this2.state.selectedItem);
        var thumbProps = {
          key: index,
          ref: function ref(e) {
            return _this2.setThumbsRef(e, index);
          },
          className: itemClass,
          onClick: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index]),
          onKeyDown: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index]),
          'aria-label': "".concat(_this2.props.labels.item, " ").concat(index + 1),
          style: {
            width: _this2.props.thumbWidth
          }
        };
        return /*#__PURE__*/_react.default.createElement("li", _extends({}, thumbProps, {
          role: "button",
          tabIndex: 0
        }), img);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      if (!this.props.children) {
        return null;
      }
      var isSwipeable = _react.Children.count(this.props.children) > 1; // show left arrow?

      var hasPrev = this.state.showArrows && this.state.firstItem > 0; // show right arrow

      var hasNext = this.state.showArrows && this.state.firstItem < this.state.lastPosition; // obj to hold the transformations and styles

      var itemListStyles = {};
      var currentPosition = -this.state.firstItem * (this.state.itemSize || 0);
      var transformProp = (0, _CSSTranslate.default)(currentPosition, 'px', this.props.axis);
      var transitionTime = this.props.transitionTime + 'ms';
      itemListStyles = {
        WebkitTransform: transformProp,
        MozTransform: transformProp,
        MsTransform: transformProp,
        OTransform: transformProp,
        transform: transformProp,
        msTransform: transformProp,
        WebkitTransitionDuration: transitionTime,
        MozTransitionDuration: transitionTime,
        MsTransitionDuration: transitionTime,
        OTransitionDuration: transitionTime,
        transitionDuration: transitionTime,
        msTransitionDuration: transitionTime
      };
      return /*#__PURE__*/_react.default.createElement("div", {
        className: _cssClasses.default.CAROUSEL(false)
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: _cssClasses.default.WRAPPER(false),
        ref: this.setItemsWrapperRef
      }, /*#__PURE__*/_react.default.createElement("button", {
        type: "button",
        className: _cssClasses.default.ARROW_PREV(!hasPrev),
        onClick: function onClick() {
          return _this3.slideRight();
        },
        "aria-label": this.props.labels.leftArrow
      }), isSwipeable ? /*#__PURE__*/_react.default.createElement(_reactEasySwipe.default, {
        tagName: "ul",
        className: _cssClasses.default.SLIDER(false, this.state.swiping),
        onSwipeLeft: this.slideLeft,
        onSwipeRight: this.slideRight,
        onSwipeMove: this.onSwipeMove,
        onSwipeStart: this.onSwipeStart,
        onSwipeEnd: this.onSwipeEnd,
        style: itemListStyles,
        innerRef: this.setItemsListRef,
        allowMouseEvents: this.props.emulateTouch
      }, this.renderItems()) : /*#__PURE__*/_react.default.createElement("ul", {
        className: _cssClasses.default.SLIDER(false, this.state.swiping),
        ref: function ref(node) {
          return _this3.setItemsListRef(node);
        },
        style: itemListStyles
      }, this.renderItems()), /*#__PURE__*/_react.default.createElement("button", {
        type: "button",
        className: _cssClasses.default.ARROW_NEXT(!hasNext),
        onClick: function onClick() {
          return _this3.slideLeft();
        },
        "aria-label": this.props.labels.rightArrow
      })));
    }
  }]);
  return Thumbs;
}(_react.Component);
exports["default"] = Thumbs;
_defineProperty(Thumbs, "displayName", 'Thumbs');
_defineProperty(Thumbs, "defaultProps", {
  axis: 'horizontal',
  labels: {
    leftArrow: 'previous slide / item',
    rightArrow: 'next slide / item',
    item: 'slide item'
  },
  selectedItem: 0,
  thumbWidth: 80,
  transitionTime: 350
});

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/cssClasses.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/cssClasses.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ "../../node_modules/react-responsive-carousel/node_modules/classnames/index.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _default = {
  ROOT: function ROOT(customClassName) {
    return (0, _classnames.default)(_defineProperty({
      'carousel-root': true
    }, customClassName || '', !!customClassName));
  },
  CAROUSEL: function CAROUSEL(isSlider) {
    return (0, _classnames.default)({
      carousel: true,
      'carousel-slider': isSlider
    });
  },
  WRAPPER: function WRAPPER(isSlider, axis) {
    return (0, _classnames.default)({
      'thumbs-wrapper': !isSlider,
      'slider-wrapper': isSlider,
      'axis-horizontal': axis === 'horizontal',
      'axis-vertical': axis !== 'horizontal'
    });
  },
  SLIDER: function SLIDER(isSlider, isSwiping) {
    return (0, _classnames.default)({
      thumbs: !isSlider,
      slider: isSlider,
      animated: !isSwiping
    });
  },
  ITEM: function ITEM(isSlider, selected, previous) {
    return (0, _classnames.default)({
      thumb: !isSlider,
      slide: isSlider,
      selected: selected,
      previous: previous
    });
  },
  ARROW_PREV: function ARROW_PREV(disabled) {
    return (0, _classnames.default)({
      'control-arrow control-prev': true,
      'control-disabled': disabled
    });
  },
  ARROW_NEXT: function ARROW_NEXT(disabled) {
    return (0, _classnames.default)({
      'control-arrow control-next': true,
      'control-disabled': disabled
    });
  },
  DOT: function DOT(selected) {
    return (0, _classnames.default)({
      dot: true,
      selected: selected
    });
  }
};
exports["default"] = _default;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/dimensions.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/dimensions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.outerWidth = void 0;
var outerWidth = function outerWidth(el) {
  var width = el.offsetWidth;
  var style = getComputedStyle(el);
  width += parseInt(style.marginLeft) + parseInt(style.marginRight);
  return width;
};
exports.outerWidth = outerWidth;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Carousel", ({
  enumerable: true,
  get: function get() {
    return _Carousel.default;
  }
}));
Object.defineProperty(exports, "CarouselProps", ({
  enumerable: true,
  get: function get() {
    return _types.CarouselProps;
  }
}));
Object.defineProperty(exports, "Thumbs", ({
  enumerable: true,
  get: function get() {
    return _Thumbs.default;
  }
}));
var _Carousel = _interopRequireDefault(__webpack_require__(/*! ./components/Carousel */ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js"));
var _types = __webpack_require__(/*! ./components/Carousel/types */ "../../node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js");
var _Thumbs = _interopRequireDefault(__webpack_require__(/*! ./components/Thumbs */ "../../node_modules/react-responsive-carousel/lib/js/components/Thumbs.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/shims/document.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/shims/document.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = function _default() {
  return document;
};
exports["default"] = _default;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/lib/js/shims/window.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/lib/js/shims/window.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = function _default() {
  return window;
};
exports["default"] = _default;

/***/ }),

/***/ "../../node_modules/react-responsive-carousel/node_modules/classnames/index.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/react-responsive-carousel/node_modules/classnames/index.js ***!
  \*************************************************************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;
  function classNames() {
    var classes = [];
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;
      var argType = typeof arg;
      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg)) {
        if (arg.length) {
          var inner = classNames.apply(null, arg);
          if (inner) {
            classes.push(inner);
          }
        }
      } else if (argType === 'object') {
        if (arg.toString === Object.prototype.toString) {
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        } else {
          classes.push(arg.toString());
        }
      }
    }
    return classes.join(' ');
  }
  if ( true && module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else if (true) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/***/ }),

/***/ "../../node_modules/react-select/dist/Select-54ac8379.esm.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-select/dist/Select-54ac8379.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ Select),
/* harmony export */   "a": () => (/* binding */ getOptionLabel$1),
/* harmony export */   "b": () => (/* binding */ defaultProps),
/* harmony export */   "c": () => (/* binding */ createFilter),
/* harmony export */   "d": () => (/* binding */ defaultTheme),
/* harmony export */   "g": () => (/* binding */ getOptionValue$1),
/* harmony export */   "m": () => (/* binding */ mergeStyles)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./index-a7690a33.esm.js */ "../../node_modules/react-select/dist/index-a7690a33.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @emotion/react */ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! memoize-one */ "../../node_modules/react-select/node_modules/memoize-one/dist/memoize-one.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");











function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref =  false ? 0 : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
var A11yText = function A11yText(props) {
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)("span", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: _ref
  }, props));
};
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable,
      isMulti = props.isMulti,
      isDisabled = props.isDisabled,
      tabSelectsValue = props.tabSelectsValue,
      context = props.context;
    switch (context) {
      case 'menu':
        return "Use Up and Down to choose options".concat(isDisabled ? '' : ', press Enter to select the currently focused option', ", press Escape to exit the menu").concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");
      case 'input':
        return "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '');
      case 'value':
        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';
      default:
        return '';
    }
  },
  onChange: function onChange(props) {
    var action = props.action,
      _props$label = props.label,
      label = _props$label === void 0 ? '' : _props$label,
      labels = props.labels,
      isDisabled = props.isDisabled;
    switch (action) {
      case 'deselect-option':
      case 'pop-value':
      case 'remove-value':
        return "option ".concat(label, ", deselected.");
      case 'clear':
        return 'All selected options have been cleared.';
      case 'initial-input-focus':
        return "option".concat(labels.length > 1 ? 's' : '', " ").concat(labels.join(','), ", selected.");
      case 'select-option':
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return '';
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context,
      focused = props.focused,
      options = props.options,
      _props$label2 = props.label,
      label = _props$label2 === void 0 ? '' : _props$label2,
      selectValue = props.selectValue,
      isDisabled = props.isDisabled,
      isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
    };
    if (context === 'value' && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === 'menu') {
      var disabled = isDisabled ? ' disabled' : '';
      var status = "".concat(isSelected ? 'selected' : 'focused').concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options, focused), ".");
    }
    return '';
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue,
      resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
  }
};
var LiveRegion = function LiveRegion(props) {
  var ariaSelection = props.ariaSelection,
    focusedOption = props.focusedOption,
    focusedValue = props.focusedValue,
    focusableOptions = props.focusableOptions,
    isFocused = props.isFocused,
    selectValue = props.selectValue,
    selectProps = props.selectProps,
    id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages,
    getOptionLabel = selectProps.getOptionLabel,
    inputValue = selectProps.inputValue,
    isMulti = selectProps.isMulti,
    isOptionDisabled = selectProps.isOptionDisabled,
    isSearchable = selectProps.isSearchable,
    menuIsOpen = selectProps.menuIsOpen,
    options = selectProps.options,
    screenReaderStatus = selectProps.screenReaderStatus,
    tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps['aria-label'];
  var ariaLive = selectProps['aria-live']; // Update aria live message configuration when prop changes

  var messages = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(function () {
    return (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]); // Update aria live selected option when prop changes

  var ariaSelected = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(function () {
    var message = '';
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option,
        selectedOptions = ariaSelection.options,
        removedValue = ariaSelection.removedValue,
        removedValues = ariaSelection.removedValues,
        value = ariaSelection.value; // select-option when !isMulti does not return option so we assume selected option is value

      var asOption = function asOption(val) {
        return !Array.isArray(val) ? val : null;
      }; // If there is just one item from the action then get its label

      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel(selected) : ''; // If there are multiple items from the action then return an array of labels

      var multiSelected = selectedOptions || removedValues || undefined;
      var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];
      var onChangeProps = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled(selected, selectValue),
        label: label,
        labels: labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel]);
  var ariaFocused = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(function () {
    var focusMsg = '';
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused: focused,
        label: getOptionLabel(focused),
        isDisabled: isOptionDisabled(focused, selectValue),
        isSelected: isSelected,
        options: options,
        context: focused === focusedOption ? 'menu' : 'value',
        selectValue: selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, options, selectValue]);
  var ariaResults = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(function () {
    var resultsMsg = '';
    if (menuIsOpen && options.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue: inputValue,
        resultsMessage: resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus]);
  var ariaGuidance = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(function () {
    var guidanceMsg = '';
    if (messages.guidance) {
      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
      guidanceMsg = messages.guidance({
        'aria-label': ariaLabel,
        context: context,
        isDisabled: focusedOption && isOptionDisabled(focusedOption, selectValue),
        isMulti: isMulti,
        isSearchable: isSearchable,
        tabSelectsValue: tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)("span", {
    id: "aria-selection"
  }, ariaSelected), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus';
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)(A11yText, {
    id: id
  }, isInitialFocus && ScreenReaderText), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var diacritics = [{
  base: 'A',
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: 'AA',
  letters: "\uA732"
}, {
  base: 'AE',
  letters: "\xC6\u01FC\u01E2"
}, {
  base: 'AO',
  letters: "\uA734"
}, {
  base: 'AU',
  letters: "\uA736"
}, {
  base: 'AV',
  letters: "\uA738\uA73A"
}, {
  base: 'AY',
  letters: "\uA73C"
}, {
  base: 'B',
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: 'C',
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: 'D',
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: 'DZ',
  letters: "\u01F1\u01C4"
}, {
  base: 'Dz',
  letters: "\u01F2\u01C5"
}, {
  base: 'E',
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: 'F',
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: 'G',
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: 'H',
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: 'I',
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: 'J',
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: 'K',
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: 'L',
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: 'LJ',
  letters: "\u01C7"
}, {
  base: 'Lj',
  letters: "\u01C8"
}, {
  base: 'M',
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: 'N',
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: 'NJ',
  letters: "\u01CA"
}, {
  base: 'Nj',
  letters: "\u01CB"
}, {
  base: 'O',
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: 'OI',
  letters: "\u01A2"
}, {
  base: 'OO',
  letters: "\uA74E"
}, {
  base: 'OU',
  letters: "\u0222"
}, {
  base: 'P',
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: 'Q',
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: 'R',
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: 'S',
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: 'T',
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: 'TZ',
  letters: "\uA728"
}, {
  base: 'U',
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: 'V',
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: 'VY',
  letters: "\uA760"
}, {
  base: 'W',
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: 'X',
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: 'Y',
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: 'Z',
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: 'a',
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: 'aa',
  letters: "\uA733"
}, {
  base: 'ae',
  letters: "\xE6\u01FD\u01E3"
}, {
  base: 'ao',
  letters: "\uA735"
}, {
  base: 'au',
  letters: "\uA737"
}, {
  base: 'av',
  letters: "\uA739\uA73B"
}, {
  base: 'ay',
  letters: "\uA73D"
}, {
  base: 'b',
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: 'c',
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: 'd',
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: 'dz',
  letters: "\u01F3\u01C6"
}, {
  base: 'e',
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: 'f',
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: 'g',
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: 'h',
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: 'hv',
  letters: "\u0195"
}, {
  base: 'i',
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: 'j',
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: 'k',
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: 'l',
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: 'lj',
  letters: "\u01C9"
}, {
  base: 'm',
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: 'n',
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: 'nj',
  letters: "\u01CC"
}, {
  base: 'o',
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: 'oi',
  letters: "\u01A3"
}, {
  base: 'ou',
  letters: "\u0223"
}, {
  base: 'oo',
  letters: "\uA74F"
}, {
  base: 'p',
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: 'q',
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: 'r',
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: 's',
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: 't',
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: 'tz',
  letters: "\uA729"
}, {
  base: 'u',
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: 'v',
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: 'vy',
  letters: "\uA761"
}, {
  base: 'w',
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: 'x',
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: 'y',
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: 'z',
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
  return d.letters;
}).join('') + ']', 'g');
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics(str) {
  return str.replace(anyDiacritic, function (match) {
    return diacriticToBase[match];
  });
};
var memoizedStripDiacriticsForInput = (0,memoize_one__WEBPACK_IMPORTED_MODULE_9__["default"])(stripDiacritics);
var trimString = function trimString(str) {
  return str.replace(/^\s+|\s+$/g, '');
};
var defaultStringify = function defaultStringify(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter(config) {
  return function (option, rawInput) {
    // eslint-disable-next-line no-underscore-dangle
    if (option.data.__isNew__) return true;
    var _ignoreCase$ignoreAcc = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({
        ignoreCase: true,
        ignoreAccents: true,
        stringify: defaultStringify,
        trim: true,
        matchFrom: 'any'
      }, config),
      ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
      ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
      stringify = _ignoreCase$ignoreAcc.stringify,
      trim = _ignoreCase$ignoreAcc.trim,
      matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim ? trimString(rawInput) : rawInput;
    var candidate = trim ? trimString(stringify(option)) : stringify(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded = ["innerRef"];
function DummyInput(_ref) {
  var innerRef = _ref.innerRef,
    props = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_6__["default"])(_ref, _excluded);

  // Remove animation props not meant for HTML elements
  var filteredProps = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.r)(props, 'onExited', 'in', 'enter', 'exit', 'appear');
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    ref: innerRef
  }, filteredProps, {
    css: /*#__PURE__*/(0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.css)({
      label: 'dummyInput',
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: 'transparent',
      fontSize: 'inherit',
      gridArea: '1 / 1 / 2 / 3',
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: 'transparent',
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: 'relative',
      transform: 'scale(.01)'
    },  false ? 0 : ";label:DummyInput;",  false ? 0 : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref) {
  var isEnabled = _ref.isEnabled,
    onBottomArrive = _ref.onBottomArrive,
    onBottomLeave = _ref.onBottomLeave,
    onTopArrive = _ref.onTopArrive,
    onTopLeave = _ref.onTopLeave;
  var isBottom = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(false);
  var isTop = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(false);
  var touchStart = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(0);
  var scrollTarget = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);
  var handleEventDelta = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current,
      scrollTop = _scrollTarget$current.scrollTop,
      scrollHeight = _scrollTarget$current.scrollHeight,
      clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false; // reset bottom/top flags

    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    } // bottom limit

    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true; // top limit
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    } // cancel scroll

    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (event) {
    // set touch start so we can calculate touchmove delta
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (el) {
    // bail early if no element is available to attach to
    if (!el) return;
    var notPassive = _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.s ? {
      passive: false
    } : false;
    el.addEventListener('wheel', onWheel, notPassive);
    el.addEventListener('touchstart', onTouchStart, notPassive);
    el.addEventListener('touchmove', onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (el) {
    // bail early if no element is available to detach from
    if (!el) return;
    el.removeEventListener('wheel', onWheel, false);
    el.removeEventListener('touchstart', onTouchStart, false);
    el.removeEventListener('touchmove', onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function () {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function (element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
var LOCK_STYLES = {
  boxSizing: 'border-box',
  // account for possible declaration `width: 100%;` on body
  overflow: 'hidden',
  position: 'relative',
  height: '100%'
};
function preventTouchMove(e) {
  e.preventDefault();
}
function allowTouchMove(e) {
  e.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
} // `ontouchstart` check works on most browsers
// `maxTouchPoints` works on IE10/11 and Surface

function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref) {
  var isEnabled = _ref.isEnabled,
    _ref$accountForScroll = _ref.accountForScrollbars,
    accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)({});
  var scrollTarget = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);
  var addScrollLock = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      // store any styles already applied to the body
      STYLE_KEYS.forEach(function (key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    } // apply the lock styles and padding if this is the first scroll lock

    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function (key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    } // account for touch devices

    if (target && isTouchDevice()) {
      // Mobile Safari ignores { overflow: hidden } declaration on the body.
      target.addEventListener('touchmove', preventTouchMove, listenerOptions); // Allow scroll on provided target

      if (touchScrollTarget) {
        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    } // increment active scroll locks

    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style; // safely decrement active scroll locks

    activeScrollLocks = Math.max(activeScrollLocks - 1, 0); // reapply original body styles, if any

    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function (key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    } // remove touch listeners

    if (target && isTouchDevice()) {
      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function () {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function (element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2 =  false ? 0 : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
function ScrollManager(_ref) {
  var children = _ref.children,
    lockEnabled = _ref.lockEnabled,
    _ref$captureEnabled = _ref.captureEnabled,
    captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
    onBottomArrive = _ref.onBottomArrive,
    onBottomLeave = _ref.onBottomLeave,
    onTopArrive = _ref.onTopArrive,
    onTopLeave = _ref.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive: onBottomArrive,
    onBottomLeave: onBottomLeave,
    onTopArrive: onTopArrive,
    onTopLeave: onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, lockEnabled && (0,_emotion_react__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    onClick: blurSelectInput,
    css: _ref2
  }), children(targetRef));
}
var formatGroupLabel = function formatGroupLabel(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.b,
  container: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.d,
  control: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.e,
  dropdownIndicator: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.f,
  group: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.g,
  groupHeading: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.h,
  indicatorsContainer: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.i,
  indicatorSeparator: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.j,
  input: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.k,
  loadingIndicator: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.l,
  loadingMessage: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.m,
  menu: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.n,
  menuList: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.o,
  menuPortal: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.p,
  multiValue: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.q,
  multiValueLabel: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.t,
  multiValueRemove: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.u,
  noOptionsMessage: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.v,
  option: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.w,
  placeholder: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.x,
  singleValue: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.y,
  valueContainer: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.z
}; // Merge Utility
// Allows consumers to extend a base Select with additional styles

function mergeStyles(source) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // initialize with source styles
  var styles = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({}, source); // massage in target styles

  Object.keys(target).forEach(function (keyAsString) {
    var key = keyAsString;
    if (source[key]) {
      styles[key] = function (rsCss, props) {
        return target[key](source[key](rsCss, props), props);
      };
    } else {
      styles[key] = target[key];
    }
  });
  return styles;
}
var colors = {
  primary: '#2684FF',
  primary75: '#4C9AFF',
  primary50: '#B2D4FF',
  primary25: '#DEEBFF',
  danger: '#DE350B',
  dangerLight: '#FFBDAD',
  neutral0: 'hsl(0, 0%, 100%)',
  neutral5: 'hsl(0, 0%, 95%)',
  neutral10: 'hsl(0, 0%, 90%)',
  neutral20: 'hsl(0, 0%, 80%)',
  neutral30: 'hsl(0, 0%, 70%)',
  neutral40: 'hsl(0, 0%, 60%)',
  neutral50: 'hsl(0, 0%, 50%)',
  neutral60: 'hsl(0, 0%, 40%)',
  neutral70: 'hsl(0, 0%, 30%)',
  neutral80: 'hsl(0, 0%, 20%)',
  neutral90: 'hsl(0, 0%, 10%)'
};
var borderRadius = 4; // Used to calculate consistent margin/padding on elements

var baseUnit = 4; // The minimum height of the control

var controlHeight = 38; // The amount of space between the control and menu */

var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit: baseUnit,
  controlHeight: controlHeight,
  menuGutter: menuGutter
};
var defaultTheme = {
  borderRadius: borderRadius,
  colors: colors,
  spacing: spacing
};
var defaultProps = {
  'aria-live': 'polite',
  backspaceRemovesValue: true,
  blurInputOnSelect: (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.A)(),
  captureMenuScroll: !(0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.A)(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel: formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !(0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.B)(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true
};
function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel(props, option);
  var value = getOptionValue(props, option);
  return {
    type: 'option',
    data: option,
    isDisabled: isDisabled,
    isSelected: isSelected,
    label: label,
    value: value,
    index: index
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
    if ('options' in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function (categorizedOption) {
        return isFocusable(props, categorizedOption);
      });
      return categorizedOptions.length > 0 ? {
        type: 'group',
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : undefined;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
  }).filter(_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.H);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, (0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_4__["default"])(categorizedOption.options.map(function (option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue,
    inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
  var data = categorizedOption.data,
    isSelected = categorizedOption.isSelected,
    label = categorizedOption.label,
    value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label,
    value: value,
    data: data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue,
    lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      // the focused value is still in the selectValue, return it
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      // the focusedValue is not present in the next selectValue array by
      // reference, so return the new value at the same index
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
}
var getOptionLabel = function getOptionLabel(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue = function getOptionValue(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;
  if (typeof props.isOptionSelected === 'function') {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue(props, option);
  return selectValue.some(function (i) {
    return getOptionValue(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
  var hideSelectedOptions = props.hideSelectedOptions,
    isMulti = props.isMulti;
  if (hideSelectedOptions === undefined) return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Select, _Component);
  var _super = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__._)(Select);

  // Misc. Instance Properties
  // ------------------------------
  // TODO
  // Refs
  // ------------------------------
  // Lifecycle
  // ------------------------------
  function Select(_props) {
    var _this;
    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Select);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: undefined,
      prevProps: undefined
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = '';
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function (ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function (ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function (ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function (ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function (newValue, actionMeta) {
      var _this$props = _this.props,
        onChange = _this$props.onChange,
        name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange(newValue, actionMeta);
    };
    _this.setValue = function (newValue, action, option) {
      var _this$props2 = _this.props,
        closeMenuOnSelect = _this$props2.closeMenuOnSelect,
        isMulti = _this$props2.isMulti,
        inputValue = _this$props2.inputValue;
      _this.onInputChange('', {
        action: 'set-value',
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } // when the select value should change, we should reset focusedValue

      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action,
        option: option
      });
    };
    _this.selectOption = function (newValue) {
      var _this$props3 = _this.props,
        blurInputOnSelect = _this$props3.blurInputOnSelect,
        isMulti = _this$props3.isMulti,
        name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.C)(selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        })), 'deselect-option', newValue);
      } else if (!isDisabled) {
        // Select option if option is not disabled
        if (isMulti) {
          _this.setValue((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.C)([].concat((0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_4__["default"])(selectValue), [newValue])), 'select-option', newValue);
        } else {
          _this.setValue((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.D)(newValue), 'select-option');
        }
      } else {
        _this.ariaOnChange((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.D)(newValue), {
          action: 'select-option',
          option: newValue,
          name: name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function (removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.E)(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'remove-value',
        removedValue: removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function () {
      var selectValue = _this.state.selectValue;
      _this.onChange((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.E)(_this.props.isMulti, [], null), {
        action: 'clear',
        removedValues: selectValue
      });
    };
    _this.popValue = function () {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.E)(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function () {
      return _this.state.selectValue;
    };
    _this.cx = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.F.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function (data) {
      return getOptionLabel(_this.props, data);
    };
    _this.getOptionValue = function (data) {
      return getOptionValue(_this.props, data);
    };
    _this.getStyles = function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getElementId = function (element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function () {
      return (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.G)(_this.props);
    };
    _this.buildCategorizedOptions = function () {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function () {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function () {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function () {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function (value, actionMeta) {
      _this.setState({
        ariaSelection: (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({
          value: value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function (event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function (event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function (event) {
      // Event captured by dropdown indicator
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props,
        isMulti = _this$props4.isMulti,
        menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.I)(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function () {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function () {
      _this.isComposing = false;
    };
    _this.onTouchStart = function (_ref2) {
      var touches = _ref2.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function (_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function (event) {
      if (_this.userIsDragging) return; // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).

      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      } // reset move vars

      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function (event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: 'input-change',
        prevInputValue: prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function (event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange('', {
        action: 'input-blur',
        prevInputValue: prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption: focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function () {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onKeyDown = function (event) {
      var _this$props5 = _this.props,
        isMulti = _this$props5.isMulti,
        backspaceRemovesValue = _this$props5.backspaceRemovesValue,
        escapeClearsValue = _this$props5.escapeClearsValue,
        inputValue = _this$props5.inputValue,
        isClearable = _this$props5.isClearable,
        isDisabled = _this$props5.isDisabled,
        menuIsOpen = _this$props5.menuIsOpen,
        onKeyDown = _this$props5.onKeyDown,
        tabSelectsValue = _this$props5.tabSelectsValue,
        openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state,
        focusedOption = _this$state.focusedOption,
        focusedValue = _this$state.focusedValue,
        selectValue = _this$state.selectValue;
      if (isDisabled) return;
      if (typeof onKeyDown === 'function') {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      } // Block option hover events when the user has just pressed a key

      _this.blockOptionHover = true;
      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) return;
          _this.focusValue('previous');
          break;
        case 'ArrowRight':
          if (!isMulti || inputValue) return;
          _this.focusValue('next');
          break;
        case 'Delete':
        case 'Backspace':
          if (inputValue) return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case 'Tab':
          if (_this.isComposing) return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption ||
          // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case 'Escape':
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange('', {
              action: 'menu-close',
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case ' ':
          // space
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu('first');
            break;
          }
          if (!focusedOption) return;
          _this.selectOption(focusedOption);
          break;
        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }
          break;
        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }
          break;
        case 'PageUp':
          if (!menuIsOpen) return;
          _this.focusOption('pageup');
          break;
        case 'PageDown':
          if (!menuIsOpen) return;
          _this.focusOption('pagedown');
          break;
        case 'Home':
          if (!menuIsOpen) return;
          _this.focusOption('first');
          break;
        case 'End':
          if (!menuIsOpen) return;
          _this.focusOption('last');
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.J)(_props.value);
    return _this;
  }
  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        // Listen to all scroll events, and filter them out inside of 'onScroll'
        document.addEventListener('scroll', this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
        isDisabled = _this$props6.isDisabled,
        menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
      // ensure focus is restored correctly when the control becomes enabled
      isFocused && !isDisabled && prevProps.isDisabled ||
      // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        // ensure select state gets blurred in case Select is programmatically disabled while focused
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } // scroll the focused option into view if necessary

      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.K)(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener('scroll', this.onScroll, true);
    } // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange('', {
        action: 'menu-close',
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    } // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    } // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state,
        selectValue = _this$state2.selectValue,
        isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      } // only scroll if the menu isn't already open

      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function () {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state,
        selectValue = _this$state3.selectValue,
        focusedValue = _this$state3.focusedValue; // Only multiselects support value focusing

      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;
      switch (direction) {
        case 'previous':
          if (focusedIndex === 0) {
            // don't cycle from the start to the end
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            // if nothing is focused, focus the last value first
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case 'next':
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options = this.getFocusableOptions();
      if (!options.length) return;
      var nextFocus = 0; // handles 'first'

      var focusedIndex = options.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === 'up') {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
      } else if (direction === 'down') {
        nextFocus = (focusedIndex + 1) % options.length;
      } else if (direction === 'pageup') {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === 'pagedown') {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
      } else if (direction === 'last') {
        nextFocus = options.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value:
    // ==============================
    // Getters
    // ==============================
    function getTheme() {
      // Use the default theme if there are no customizations.
      if (!this.props.theme) {
        return defaultTheme;
      } // If the theme prop is a function, assume the function
      // knows how to merge the passed-in default theme with
      // its own modifications.

      if (typeof this.props.theme === 'function') {
        return this.props.theme(defaultTheme);
      } // Otherwise, if a plain theme object was passed in,
      // overlay it with the default theme.

      return (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue,
        cx = this.cx,
        getStyles = this.getStyles,
        getValue = this.getValue,
        selectOption = this.selectOption,
        setValue = this.setValue,
        props = this.props;
      var isMulti = props.isMulti,
        isRtl = props.isRtl,
        options = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue: clearValue,
        cx: cx,
        getStyles: getStyles,
        getValue: getValue,
        hasValue: hasValue,
        isMulti: isMulti,
        isRtl: isRtl,
        options: options,
        selectOption: selectOption,
        selectProps: props,
        setValue: setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props,
        isClearable = _this$props7.isClearable,
        isMulti = _this$props7.isMulti; // single select, by default, IS NOT clearable
      // multi select, by default, IS clearable

      if (isClearable === undefined) return isMulti;
      return isClearable;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === 'function') {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context: context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel(data) {
      return this.props.formatGroupLabel(data);
    } // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value:
    // ==============================
    // Composition Handlers
    // ==============================
    function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener('compositionstart', this.onCompositionStart, false);
        document.addEventListener('compositionend', this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener('compositionstart', this.onCompositionStart);
        document.removeEventListener('compositionend', this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value:
    // ==============================
    // Touch Handlers
    // ==============================
    function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener('touchstart', this.onTouchStart, false);
        document.addEventListener('touchmove', this.onTouchMove, false);
        document.addEventListener('touchend', this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener('touchstart', this.onTouchStart);
        document.removeEventListener('touchmove', this.onTouchMove);
        document.removeEventListener('touchend', this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value:
    // ==============================
    // Renderers
    // ==============================
    function renderInput() {
      var _this$props8 = this.props,
        isDisabled = _this$props8.isDisabled,
        isSearchable = _this$props8.isSearchable,
        inputId = _this$props8.inputId,
        inputValue = _this$props8.inputValue,
        tabIndex = _this$props8.tabIndex,
        form = _this$props8.form,
        menuIsOpen = _this$props8.menuIsOpen;
      var _this$getComponents = this.getComponents(),
        Input = _this$getComponents.Input;
      var _this$state4 = this.state,
        inputIsHidden = _this$state4.inputIsHidden,
        ariaSelection = _this$state4.ariaSelection;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId('input'); // aria attributes makes the JSX "noisy", separated for clarity

      var ariaAttributes = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({
        'aria-autocomplete': 'list',
        'aria-expanded': menuIsOpen,
        'aria-haspopup': true,
        'aria-errormessage': this.props['aria-errormessage'],
        'aria-invalid': this.props['aria-invalid'],
        'aria-label': this.props['aria-label'],
        'aria-labelledby': this.props['aria-labelledby'],
        role: 'combobox'
      }, menuIsOpen && {
        'aria-controls': this.getElementId('listbox'),
        'aria-owns': this.getElementId('listbox')
      }), !isSearchable && {
        'aria-readonly': true
      }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus' && {
        'aria-describedby': this.getElementId('live-region')
      } : {
        'aria-describedby': this.getElementId('placeholder')
      });
      if (!isSearchable) {
        // use a dummy input to maintain focus/blur functionality
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(DummyInput, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
          id: id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.L,
          onFocus: this.onInputFocus,
          disabled: isDisabled,
          tabIndex: tabIndex,
          inputMode: "none",
          form: form,
          value: ""
        }, ariaAttributes));
      }
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Input, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id: id,
        innerRef: this.getInputRef,
        isDisabled: isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex: tabIndex,
        form: form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(),
        MultiValue = _this$getComponents2.MultiValue,
        MultiValueContainer = _this$getComponents2.MultiValueContainer,
        MultiValueLabel = _this$getComponents2.MultiValueLabel,
        MultiValueRemove = _this$getComponents2.MultiValueRemove,
        SingleValue = _this$getComponents2.SingleValue,
        Placeholder = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props,
        controlShouldRenderValue = _this$props9.controlShouldRenderValue,
        isDisabled = _this$props9.isDisabled,
        isMulti = _this$props9.isMulti,
        inputValue = _this$props9.inputValue,
        placeholder = _this$props9.placeholder;
      var _this$state5 = this.state,
        selectValue = _this$state5.selectValue,
        focusedValue = _this$state5.focusedValue,
        isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Placeholder, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
          key: "placeholder",
          isDisabled: isDisabled,
          isFocused: isFocused,
          innerProps: {
            id: this.getElementId('placeholder')
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function (opt, index) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(MultiValue, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
            components: {
              Container: MultiValueContainer,
              Label: MultiValueLabel,
              Remove: MultiValueRemove
            },
            isFocused: isOptionFocused,
            isDisabled: isDisabled,
            key: key,
            index: index,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e) {
                e.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, 'value'));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(SingleValue, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        data: singleValue,
        isDisabled: isDisabled
      }), this.formatOptionLabel(singleValue, 'value'));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(),
        ClearIndicator = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props,
        isDisabled = _this$props10.isDisabled,
        isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(ClearIndicator, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        innerProps: innerProps,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(),
        LoadingIndicator = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props,
        isDisabled = _this$props11.isDisabled,
        isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator || !isLoading) return null;
      var innerProps = {
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(LoadingIndicator, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(),
        DropdownIndicator = _this$getComponents5.DropdownIndicator,
        IndicatorSeparator = _this$getComponents5.IndicatorSeparator; // separator doesn't make sense without the dropdown indicator

      if (!DropdownIndicator || !IndicatorSeparator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(IndicatorSeparator, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(),
        DropdownIndicator = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(DropdownIndicator, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(),
        Group = _this$getComponents7.Group,
        GroupHeading = _this$getComponents7.GroupHeading,
        Menu = _this$getComponents7.Menu,
        MenuList = _this$getComponents7.MenuList,
        MenuPortal = _this$getComponents7.MenuPortal,
        LoadingMessage = _this$getComponents7.LoadingMessage,
        NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
        Option = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props,
        captureMenuScroll = _this$props12.captureMenuScroll,
        inputValue = _this$props12.inputValue,
        isLoading = _this$props12.isLoading,
        loadingMessage = _this$props12.loadingMessage,
        minMenuHeight = _this$props12.minMenuHeight,
        maxMenuHeight = _this$props12.maxMenuHeight,
        menuIsOpen = _this$props12.menuIsOpen,
        menuPlacement = _this$props12.menuPlacement,
        menuPosition = _this$props12.menuPosition,
        menuPortalTarget = _this$props12.menuPortalTarget,
        menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
        menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
        noOptionsMessage = _this$props12.noOptionsMessage,
        onMenuScrollToTop = _this$props12.onMenuScrollToTop,
        onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null; // TODO: Internal Option Type here

      var render = function render(props, id) {
        var type = props.type,
          data = props.data,
          isDisabled = props.isDisabled,
          isSelected = props.isSelected,
          label = props.label,
          value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? undefined : function () {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Option, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
          innerProps: innerProps,
          data: data,
          isDisabled: isDisabled,
          isSelected: isSelected,
          key: optionId,
          label: label,
          type: type,
          value: value,
          isFocused: isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
        }), _this4.formatOptionLabel(props.data, 'menu'));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function (item) {
          if (item.type === 'group') {
            var _data = item.data,
              options = item.options,
              groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Group, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
              key: groupId,
              data: _data,
              options: options,
              Heading: GroupHeading,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function (option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === 'option') {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage({
          inputValue: inputValue
        });
        if (message === null) return null;
        menuUI = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(LoadingMessage, commonProps, message);
      } else {
        var _message = noOptionsMessage({
          inputValue: inputValue
        });
        if (_message === null) return null;
        menuUI = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(NoOptionsMessage, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight: minMenuHeight,
        maxMenuHeight: maxMenuHeight,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        menuShouldScrollIntoView: menuShouldScrollIntoView
      };
      var menuElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.M, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, menuPlacementProps), function (_ref4) {
        var ref = _ref4.ref,
          _ref4$placerProps = _ref4.placerProps,
          placement = _ref4$placerProps.placement,
          maxHeight = _ref4$placerProps.maxHeight;
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Menu, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId('listbox')
          },
          isLoading: isLoading,
          placement: placement
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function (scrollTargetRef) {
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(MenuList, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading: isLoading,
            maxHeight: maxHeight,
            focusedOption: focusedOption
          }), menuUI);
        }));
      }); // positioning behaviour is almost identical for portalled and fixed,
      // so we use the same component. the actual portalling logic is forked
      // within the component based on `menuPosition`

      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(MenuPortal, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props,
        delimiter = _this$props13.delimiter,
        isDisabled = _this$props13.isDisabled,
        isMulti = _this$props13.isMulti,
        name = _this$props13.name;
      var selectValue = this.state.selectValue;
      if (!name || isDisabled) return;
      if (isMulti) {
        if (delimiter) {
          var value = selectValue.map(function (opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter);
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement("input", {
            name: name,
            type: "hidden",
            value: value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement("input", {
              key: "i-".concat(i),
              name: name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement("input", {
            name: name,
            type: "hidden"
          });
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement("input", {
          name: name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state,
        ariaSelection = _this$state6.ariaSelection,
        focusedOption = _this$state6.focusedOption,
        focusedValue = _this$state6.focusedValue,
        isFocused = _this$state6.isFocused,
        selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(LiveRegion, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        id: this.getElementId('live-region'),
        ariaSelection: ariaSelection,
        focusedOption: focusedOption,
        focusedValue: focusedValue,
        isFocused: isFocused,
        selectValue: selectValue,
        focusableOptions: focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(),
        Control = _this$getComponents8.Control,
        IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
        SelectContainer = _this$getComponents8.SelectContainer,
        ValueContainer = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props,
        className = _this$props14.className,
        id = _this$props14.id,
        isDisabled = _this$props14.isDisabled,
        menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(SelectContainer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        className: className,
        innerProps: {
          id: id,
          onKeyDown: this.onKeyDown
        },
        isDisabled: isDisabled,
        isFocused: isFocused
      }), this.renderLiveRegion(), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(Control, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: isDisabled,
        isFocused: isFocused,
        menuIsOpen: menuIsOpen
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(ValueContainer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__.createElement(IndicatorsContainer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, commonProps, {
        isDisabled: isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps,
        clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
        inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
        ariaSelection = state.ariaSelection,
        isFocused = state.isFocused,
        prevWasFocused = state.prevWasFocused;
      var options = props.options,
        value = props.value,
        menuIsOpen = props.menuIsOpen,
        inputValue = props.inputValue,
        isMulti = props.isMulti;
      var selectValue = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.J)(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue: selectValue,
          focusedOption: focusedOption,
          focusedValue: focusedValue,
          clearFocusValueOnUpdate: false
        };
      } // some updates should toggle the state of the input visibility

      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: undefined
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        // If `value` or `defaultValue` props are not empty then announce them
        // when the Select is initially focused
        newAriaSelection = {
          value: (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.E)(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: 'initial-input-focus'
        };
        hasKeptFocus = !prevWasFocused;
      } // If the 'initial-input-focus' action has been set already
      // then reset the ariaSelection to null

      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
        newAriaSelection = null;
      }
      return (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_8__.a)({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select;
}(react__WEBPACK_IMPORTED_MODULE_5__.Component);
Select.defaultProps = defaultProps;


/***/ }),

/***/ "../../node_modules/react-select/dist/index-a7690a33.esm.js":
/*!******************************************************************!*\
  !*** ../../node_modules/react-select/dist/index-a7690a33.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ isTouchCapable),
/* harmony export */   "B": () => (/* binding */ isMobileDevice),
/* harmony export */   "C": () => (/* binding */ multiValueAsValue),
/* harmony export */   "D": () => (/* binding */ singleValueAsValue),
/* harmony export */   "E": () => (/* binding */ valueTernary),
/* harmony export */   "F": () => (/* binding */ classNames),
/* harmony export */   "G": () => (/* binding */ defaultComponents),
/* harmony export */   "H": () => (/* binding */ notNullish),
/* harmony export */   "I": () => (/* binding */ isDocumentElement),
/* harmony export */   "J": () => (/* binding */ cleanValue),
/* harmony export */   "K": () => (/* binding */ scrollIntoView),
/* harmony export */   "L": () => (/* binding */ noop),
/* harmony export */   "M": () => (/* binding */ MenuPlacer),
/* harmony export */   "N": () => (/* binding */ handleInputChange),
/* harmony export */   "_": () => (/* binding */ _createSuper),
/* harmony export */   "a": () => (/* binding */ _objectSpread2),
/* harmony export */   "b": () => (/* binding */ clearIndicatorCSS),
/* harmony export */   "c": () => (/* binding */ components),
/* harmony export */   "d": () => (/* binding */ containerCSS),
/* harmony export */   "e": () => (/* binding */ css$1),
/* harmony export */   "f": () => (/* binding */ dropdownIndicatorCSS),
/* harmony export */   "g": () => (/* binding */ groupCSS),
/* harmony export */   "h": () => (/* binding */ groupHeadingCSS),
/* harmony export */   "i": () => (/* binding */ indicatorsContainerCSS),
/* harmony export */   "j": () => (/* binding */ indicatorSeparatorCSS),
/* harmony export */   "k": () => (/* binding */ inputCSS),
/* harmony export */   "l": () => (/* binding */ loadingIndicatorCSS),
/* harmony export */   "m": () => (/* binding */ loadingMessageCSS),
/* harmony export */   "n": () => (/* binding */ menuCSS),
/* harmony export */   "o": () => (/* binding */ menuListCSS),
/* harmony export */   "p": () => (/* binding */ menuPortalCSS),
/* harmony export */   "q": () => (/* binding */ multiValueCSS),
/* harmony export */   "r": () => (/* binding */ removeProps),
/* harmony export */   "s": () => (/* binding */ supportsPassiveEvents),
/* harmony export */   "t": () => (/* binding */ multiValueLabelCSS),
/* harmony export */   "u": () => (/* binding */ multiValueRemoveCSS),
/* harmony export */   "v": () => (/* binding */ noOptionsMessageCSS),
/* harmony export */   "w": () => (/* binding */ optionCSS),
/* harmony export */   "x": () => (/* binding */ placeholderCSS),
/* harmony export */   "y": () => (/* binding */ css),
/* harmony export */   "z": () => (/* binding */ valueContainerCSS)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @emotion/react */ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteral */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");












function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
// ==============================
// NO OP
// ==============================
var noop = function noop() {};
// Class Name Prefixer
// ==============================

/**
 String representation of component state for styling with class names.

 Expects an array of strings OR a string/object pair:
 - className(['comp', 'comp-arg', 'comp-arg-2'])
   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 - className('comp', { some: true, state: false })
   @returns 'react-select__comp react-select__comp--some'
*/

function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}
function classNames(prefix, state, className) {
  var arr = [className];
  if (state && prefix) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix, key)));
      }
    }
  }
  return arr.filter(function (i) {
    return i;
  }).map(function (i) {
    return String(i).trim();
  }).join(' ');
} // ==============================
// Clean Value
// ==============================

var cleanValue = function cleanValue(value) {
  if (isArray(value)) return value.filter(Boolean);
  if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_4__["default"])(value) === 'object' && value !== null) return [value];
  return [];
}; // ==============================
// Clean Common Props
// ==============================

var cleanCommonProps = function cleanCommonProps(props) {
  //className
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(props, _excluded$3);
  return _objectSpread2({}, innerProps);
}; // ==============================
// Handle Input Change
// ==============================

function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var _newValue = onInputChange(inputValue, actionMeta);
    if (typeof _newValue === 'string') return _newValue;
  }
  return inputValue;
} // ==============================
// Scroll Helpers
// ==============================

function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
} // Normalized Scroll Top
// ------------------------------

function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
} // Normalized scrollTo & scrollTop
// ------------------------------

function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
} // Get Scroll Parent
// ------------------------------

function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === 'absolute';
  var overflowRx = /(auto|scroll)/;
  if (style.position === 'fixed') return document.documentElement;
  for (var parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === 'static') {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
} // Animated Scroll To
// ------------------------------

/**
  @param t: time (elapsed)
  @param b: initial value
  @param c: amount of change
  @param d: duration
*/

function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
} // Scroll Into View
// ------------------------------

function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
} // ==============================
// Get bounding client object
// ==============================
// cannot get keys using array notation with DOMRect

function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
// Touch Capability Detector
// ==============================

function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch (e) {
    return false;
  }
} // ==============================
// Mobile Device Detector
// ==============================

function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
} // ==============================
// Passive Event Detector
// ==============================
// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36

var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
}; // check for SSR

var w = typeof window !== 'undefined' ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener('p', noop, options);
  w.removeEventListener('p', noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps(propsObj) {
  for (var _len = arguments.length, properties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    properties[_key - 1] = arguments[_key];
  }
  var propsMap = Object.entries(propsObj).filter(function (_ref) {
    var _ref2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref, 1),
      key = _ref2[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function (newProps, _ref3) {
    var _ref4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref3, 2),
      key = _ref4[0],
      val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
function getMenuPlacement(_ref) {
  var maxHeight = _ref.maxHeight,
    menuEl = _ref.menuEl,
    minHeight = _ref.minHeight,
    placement = _ref.placement,
    shouldScroll = _ref.shouldScroll,
    isFixedPosition = _ref.isFixedPosition,
    theme = _ref.theme;
  var spacing = theme.spacing;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: 'bottom',
    maxHeight: maxHeight
  }; // something went wrong, return default state

  if (!menuEl || !menuEl.offsetParent) return defaultState; // we can't trust `scrollParent.scrollHeight` --> it may increase when
  // the menu is rendered

  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
    scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
    menuBottom = _menuEl$getBoundingCl.bottom,
    menuHeight = _menuEl$getBoundingCl.height,
    menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
    containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (placement) {
    case 'auto':
    case 'bottom':
      // 1: the menu will fit, do nothing
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled

      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained

      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        } // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.

        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: 'bottom',
          maxHeight: constrainedHeight
        };
      } // 4. Forked beviour when there isn't enough space below
      // AUTO: flip the menu, render above

      if (placement === 'auto' || isFixedPosition) {
        // may need to be constrained after flipping
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing.controlHeight, maxHeight);
        }
        return {
          placement: 'top',
          maxHeight: _constrainedHeight
        };
      } // BOTTOM: allow browser to increase scrollable area and immediately set scroll

      if (placement === 'bottom') {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      }
      break;
    case 'top':
      // 1: the menu will fit, do nothing
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled

      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained

      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight; // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.

        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: 'top',
          maxHeight: _constrainedHeight2
        };
      } // 4. not enough space, the browser WILL NOT increase scrollable area when
      // absolutely positioned element rendered above the viewport (only below).
      // Flip the menu, render below

      return {
        placement: 'bottom',
        maxHeight: maxHeight
      };
    default:
      throw new Error("Invalid placement provided \"".concat(placement, "\"."));
  }
  return defaultState;
} // Menu Component
// ------------------------------

function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: 'top',
    top: 'bottom'
  };
  return placement ? placementToCSSProp[placement] : 'bottom';
}
var coercePlacement = function coercePlacement(p) {
  return p === 'auto' ? 'bottom' : p;
};
var menuCSS = function menuCSS(_ref2) {
  var _ref3;
  var placement = _ref2.placement,
    _ref2$theme = _ref2.theme,
    borderRadius = _ref2$theme.borderRadius,
    spacing = _ref2$theme.spacing,
    colors = _ref2$theme.colors;
  return _ref3 = {
    label: 'menu'
  }, (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, alignToControl(placement), '100%'), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "backgroundColor", colors.neutral0), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "borderRadius", borderRadius), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "boxShadow", '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)'), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "marginBottom", spacing.menuGutter), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "marginTop", spacing.menuGutter), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "position", 'absolute'), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "width", '100%'), (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_8__["default"])(_ref3, "zIndex", 1), _ref3;
};
var PortalPlacementContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_9__.createContext)({
  getPortalPlacement: null
}); // NOTE: internal only

var MenuPlacer = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__["default"])(MenuPlacer, _Component);
  var _super = _createSuper(MenuPlacer);
  function MenuPlacer() {
    var _this;
    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, MenuPlacer);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };
    _this.context = void 0;
    _this.getPlacement = function (ref) {
      var _this$props = _this.props,
        minMenuHeight = _this$props.minMenuHeight,
        maxMenuHeight = _this$props.maxMenuHeight,
        menuPlacement = _this$props.menuPlacement,
        menuPosition = _this$props.menuPosition,
        menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView,
        theme = _this$props.theme;
      if (!ref) return; // DO NOT scroll if position is fixed

      var isFixedPosition = menuPosition === 'fixed';
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll: shouldScroll,
        isFixedPosition: isFixedPosition,
        theme: theme
      });
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (getPortalPlacement) getPortalPlacement(state);
      _this.setState(state);
    };
    _this.getUpdatedProps = function () {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return _objectSpread2(_objectSpread2({}, _this.props), {}, {
        placement: placement,
        maxHeight: _this.state.maxHeight
      });
    };
    return _this;
  }
  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__["default"])(MenuPlacer, [{
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children({
        ref: this.getPlacement,
        placerProps: this.getUpdatedProps()
      });
    }
  }]);
  return MenuPlacer;
}(react__WEBPACK_IMPORTED_MODULE_9__.Component);
MenuPlacer.contextType = PortalPlacementContext;
var Menu = function Menu(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerRef = props.innerRef,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('menu', props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
};
// Menu List
// ==============================

var menuListCSS = function menuListCSS(_ref4) {
  var maxHeight = _ref4.maxHeight,
    baseUnit = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight: maxHeight,
    overflowY: 'auto',
    paddingBottom: baseUnit,
    paddingTop: baseUnit,
    position: 'relative',
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: 'touch'
  };
};
var MenuList = function MenuList(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    innerRef = props.innerRef,
    isMulti = props.isMulti;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('menuList', props),
    className: cx({
      'menu-list': true,
      'menu-list--is-multi': isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
}; // ==============================
// Menu Notices
// ==============================

var noticeCSS = function noticeCSS(_ref5) {
  var _ref5$theme = _ref5.theme,
    baseUnit = _ref5$theme.spacing.baseUnit,
    colors = _ref5$theme.colors;
  return {
    color: colors.neutral40,
    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px"),
    textAlign: 'center'
  };
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('noOptionsMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--no-options': true
    }, className)
  }, innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: 'No options'
};
var LoadingMessage = function LoadingMessage(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('loadingMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--loading': true
    }, className)
  }, innerProps), children);
};
LoadingMessage.defaultProps = {
  children: 'Loading...'
}; // ==============================
// Menu Portal
// ==============================

var menuPortalCSS = function menuPortalCSS(_ref6) {
  var rect = _ref6.rect,
    offset = _ref6.offset,
    position = _ref6.position;
  return {
    left: rect.left,
    position: position,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = /*#__PURE__*/function (_Component2) {
  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__["default"])(MenuPortal, _Component2);
  var _super2 = _createSuper(MenuPortal);
  function MenuPortal() {
    var _this2;
    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, MenuPortal);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.state = {
      placement: null
    };
    _this2.getPortalPlacement = function (_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement); // avoid re-renders if the placement has not changed

      if (placement !== initialPlacement) {
        _this2.setState({
          placement: placement
        });
      }
    };
    return _this2;
  }
  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__["default"])(MenuPortal, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        appendTo = _this$props2.appendTo,
        children = _this$props2.children,
        className = _this$props2.className,
        controlElement = _this$props2.controlElement,
        cx = _this$props2.cx,
        innerProps = _this$props2.innerProps,
        menuPlacement = _this$props2.menuPlacement,
        position = _this$props2.menuPosition,
        getStyles = _this$props2.getStyles;
      var isFixed = position === 'fixed'; // bail early if required elements aren't present

      if (!appendTo && !isFixed || !controlElement) {
        return null;
      }
      var placement = this.state.placement || coercePlacement(menuPlacement);
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = isFixed ? 0 : window.pageYOffset;
      var offset = rect[placement] + scrollDistance;
      var state = {
        offset: offset,
        position: position,
        rect: rect
      }; // same wrapper element whether fixed or portalled

      var menuWrapper = (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
        css: getStyles('menuPortal', state),
        className: cx({
          'menu-portal': true
        }, className)
      }, innerProps), children);
      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(PortalPlacementContext.Provider, {
        value: {
          getPortalPlacement: this.getPortalPlacement
        }
      }, appendTo ? /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_10__.createPortal)(menuWrapper, appendTo) : menuWrapper);
    }
  }]);
  return MenuPortal;
}(react__WEBPACK_IMPORTED_MODULE_9__.Component);
var containerCSS = function containerCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    isRtl = _ref.isRtl;
  return {
    label: 'container',
    direction: isRtl ? 'rtl' : undefined,
    pointerEvents: isDisabled ? 'none' : undefined,
    // cancel mouse events when disabled
    position: 'relative'
  };
};
var SelectContainer = function SelectContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isDisabled = props.isDisabled,
    isRtl = props.isRtl;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('container', props),
    className: cx({
      '--is-disabled': isDisabled,
      '--is-rtl': isRtl
    }, className)
  }, innerProps), children);
}; // ==============================
// Value Container
// ==============================

var valueContainerCSS = function valueContainerCSS(_ref2) {
  var spacing = _ref2.theme.spacing,
    isMulti = _ref2.isMulti,
    hasValue = _ref2.hasValue,
    controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
  return {
    alignItems: 'center',
    display: isMulti && hasValue && controlShouldRenderValue ? 'flex' : 'grid',
    flex: 1,
    flexWrap: 'wrap',
    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px"),
    WebkitOverflowScrolling: 'touch',
    position: 'relative',
    overflow: 'hidden'
  };
};
var ValueContainer = function ValueContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    innerProps = props.innerProps,
    isMulti = props.isMulti,
    getStyles = props.getStyles,
    hasValue = props.hasValue;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('valueContainer', props),
    className: cx({
      'value-container': true,
      'value-container--is-multi': isMulti,
      'value-container--has-value': hasValue
    }, className)
  }, innerProps), children);
}; // ==============================
// Indicator Container
// ==============================

var indicatorsContainerCSS = function indicatorsContainerCSS() {
  return {
    alignItems: 'center',
    alignSelf: 'stretch',
    display: 'flex',
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    innerProps = props.innerProps,
    getStyles = props.getStyles;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('indicatorsContainer', props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 =  false ? 0 : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpc0ZvY3VzZWQsXG4gIHRoZW1lOiB7XG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIGNvbG9ycyxcbiAgfSxcbn06XG4gIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuXG4gICc6aG92ZXInOiB7XG4gICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBkcm9wZG93bkluZGljYXRvckNTUyA9IGJhc2VDU1M7XG5leHBvcnQgY29uc3QgRHJvcGRvd25JbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBEcm9wZG93bkluZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+XG4pID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdjbGVhckluZGljYXRvcicsIHByb3BzKX1cbiAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpc0Rpc2FibGVkLFxuICB0aGVtZToge1xuICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICBjb2xvcnMsXG4gIH0sXG59OiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvclNlcGFyYXRvcicsXG4gIGFsaWduU2VsZjogJ3N0cmV0Y2gnLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGlzRGlzYWJsZWQgPyBjb2xvcnMubmV1dHJhbDEwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgbWFyZ2luQm90dG9tOiBiYXNlVW5pdCAqIDIsXG4gIG1hcmdpblRvcDogYmFzZVVuaXQgKiAyLFxuICB3aWR0aDogMSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2luZGljYXRvclNlcGFyYXRvcicsIHByb3BzKX1cbiAgICAgIGNsYXNzTmFtZT17Y3goeyAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUgfSwgY2xhc3NOYW1lKX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaXNGb2N1c2VkLFxuICBzaXplLFxuICB0aGVtZToge1xuICAgIGNvbG9ycyxcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gIH0sXG59OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgZm9udFNpemU6IHNpemUsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG1hcmdpblJpZ2h0OiBzaXplLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcywgaXNSdGwgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2xvYWRpbmdJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHsgc2l6ZTogNCB9O1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};

// ==============================
// Dropdown & Clear Icons
// ==============================
var Svg = function Svg(_ref) {
  var size = _ref.size,
    props = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, _excluded$2);
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("svg", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon(props) {
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Svg, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    size: 20
  }, props), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron(props) {
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Svg, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    size: 20
  }, props), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}; // ==============================
// Dropdown & Clear Buttons
// ==============================

var baseCSS = function baseCSS(_ref3) {
  var isFocused = _ref3.isFocused,
    _ref3$theme = _ref3.theme,
    baseUnit = _ref3$theme.spacing.baseUnit,
    colors = _ref3$theme.colors;
  return {
    label: 'indicatorContainer',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    ':hover': {
      color: isFocused ? colors.neutral80 : colors.neutral40
    }
  };
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('dropdownIndicator', props),
    className: cx({
      indicator: true,
      'dropdown-indicator': true
    }, className)
  }, innerProps), children || (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('clearIndicator', props),
    className: cx({
      indicator: true,
      'clear-indicator': true
    }, className)
  }, innerProps), children || (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(CrossIcon, null));
}; // ==============================
// Separator
// ==============================

var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4) {
  var isDisabled = _ref4.isDisabled,
    _ref4$theme = _ref4.theme,
    baseUnit = _ref4$theme.spacing.baseUnit,
    colors = _ref4$theme.colors;
  return {
    label: 'indicatorSeparator',
    alignSelf: 'stretch',
    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
    marginBottom: baseUnit * 2,
    marginTop: baseUnit * 2,
    width: 1
  };
};
var IndicatorSeparator = function IndicatorSeparator(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("span", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, innerProps, {
    css: getStyles('indicatorSeparator', props),
    className: cx({
      'indicator-separator': true
    }, className)
  }));
}; // ==============================
// Loading
// ==============================

var loadingDotAnimations = (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.keyframes)(_templateObject || (_templateObject = (0,_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_1__["default"])(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5) {
  var isFocused = _ref5.isFocused,
    size = _ref5.size,
    _ref5$theme = _ref5.theme,
    colors = _ref5$theme.colors,
    baseUnit = _ref5$theme.spacing.baseUnit;
  return {
    label: 'loadingIndicator',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    alignSelf: 'center',
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: 'center',
    verticalAlign: 'middle'
  };
};
var LoadingDot = function LoadingDot(_ref6) {
  var delay = _ref6.delay,
    offset = _ref6.offset;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("span", {
    css: /*#__PURE__*/(0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.css)({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: 'currentColor',
      borderRadius: '1em',
      display: 'inline-block',
      marginLeft: offset ? '1em' : undefined,
      height: '1em',
      verticalAlign: 'top',
      width: '1em'
    },  false ? 0 : ";label:LoadingDot;",  false ? 0 : "")
  });
};
var LoadingIndicator = function LoadingIndicator(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isRtl = props.isRtl;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('loadingIndicator', props),
    className: cx({
      indicator: true,
      'loading-indicator': true
    }, className)
  }, innerProps), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(LoadingDot, {
    delay: 160,
    offset: true
  }), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};
var css$1 = function css(_ref) {
  var isDisabled = _ref.isDisabled,
    isFocused = _ref.isFocused,
    _ref$theme = _ref.theme,
    colors = _ref$theme.colors,
    borderRadius = _ref$theme.borderRadius,
    spacing = _ref$theme.spacing;
  return {
    label: 'control',
    alignItems: 'center',
    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
    borderRadius: borderRadius,
    borderStyle: 'solid',
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : undefined,
    cursor: 'default',
    display: 'flex',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    minHeight: spacing.controlHeight,
    outline: '0 !important',
    position: 'relative',
    transition: 'all 100ms',
    '&:hover': {
      borderColor: isFocused ? colors.primary : colors.neutral30
    }
  };
};
var Control = function Control(props) {
  var children = props.children,
    cx = props.cx,
    getStyles = props.getStyles,
    className = props.className,
    isDisabled = props.isDisabled,
    isFocused = props.isFocused,
    innerRef = props.innerRef,
    innerProps = props.innerProps,
    menuIsOpen = props.menuIsOpen;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    ref: innerRef,
    css: getStyles('control', props),
    className: cx({
      control: true,
      'control--is-disabled': isDisabled,
      'control--is-focused': isFocused,
      'control--menu-is-open': menuIsOpen
    }, className)
  }, innerProps), children);
};
var _excluded$1 = ["data"];
var groupCSS = function groupCSS(_ref) {
  var spacing = _ref.theme.spacing;
  return {
    paddingBottom: spacing.baseUnit * 2,
    paddingTop: spacing.baseUnit * 2
  };
};
var Group = function Group(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    Heading = props.Heading,
    headingProps = props.headingProps,
    innerProps = props.innerProps,
    label = props.label,
    theme = props.theme,
    selectProps = props.selectProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('group', props),
    className: cx({
      group: true
    }, className)
  }, innerProps), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Heading, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, headingProps, {
    selectProps: selectProps,
    theme: theme,
    getStyles: getStyles,
    cx: cx
  }), label), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    label: 'group',
    color: '#999',
    cursor: 'default',
    display: 'block',
    fontSize: '75%',
    fontWeight: 500,
    marginBottom: '0.25em',
    paddingLeft: spacing.baseUnit * 3,
    paddingRight: spacing.baseUnit * 3,
    textTransform: 'uppercase'
  };
};
var GroupHeading = function GroupHeading(props) {
  var getStyles = props.getStyles,
    cx = props.cx,
    className = props.className;
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_cleanCommonProps, _excluded$1);
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('groupHeading', props),
    className: cx({
      'group-heading': true
    }, className)
  }, innerProps));
};
var _excluded = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    value = _ref.value,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return _objectSpread2({
    margin: spacing.baseUnit / 2,
    paddingBottom: spacing.baseUnit / 2,
    paddingTop: spacing.baseUnit / 2,
    visibility: isDisabled ? 'hidden' : 'visible',
    color: colors.neutral80,
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? 'translateZ(0)' : ''
  }, containerStyle);
};
var spacingStyle = {
  gridArea: '1 / 2',
  font: 'inherit',
  minWidth: '2px',
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: '1 1 auto',
  display: 'inline-grid',
  gridArea: '1 / 1 / 2 / 3',
  gridTemplateColumns: '0 min-content',
  '&:after': _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: 'hidden',
    whiteSpace: 'pre'
  }, spacingStyle)
};
var inputStyle = function inputStyle(isHidden) {
  return _objectSpread2({
    label: 'input',
    color: 'inherit',
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: '100%'
  }, spacingStyle);
};
var Input = function Input(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    value = props.value;
  var _cleanCommonProps = cleanCommonProps(props),
    innerRef = _cleanCommonProps.innerRef,
    isDisabled = _cleanCommonProps.isDisabled,
    isHidden = _cleanCommonProps.isHidden,
    inputClassName = _cleanCommonProps.inputClassName,
    innerProps = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_cleanCommonProps, _excluded);
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", {
    className: cx({
      'input-container': true
    }, className),
    css: getStyles('input', props),
    "data-value": value || ''
  }, (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("input", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var multiValueCSS = function multiValueCSS(_ref) {
  var _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    borderRadius = _ref$theme.borderRadius,
    colors = _ref$theme.colors;
  return {
    label: 'multiValue',
    backgroundColor: colors.neutral10,
    borderRadius: borderRadius / 2,
    display: 'flex',
    margin: spacing.baseUnit / 2,
    minWidth: 0 // resolves flex/text-overflow bug
  };
};

var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
  var _ref2$theme = _ref2.theme,
    borderRadius = _ref2$theme.borderRadius,
    colors = _ref2$theme.colors,
    cropWithEllipsis = _ref2.cropWithEllipsis;
  return {
    borderRadius: borderRadius / 2,
    color: colors.neutral80,
    fontSize: '85%',
    overflow: 'hidden',
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis || cropWithEllipsis === undefined ? 'ellipsis' : undefined,
    whiteSpace: 'nowrap'
  };
};
var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
  var _ref3$theme = _ref3.theme,
    spacing = _ref3$theme.spacing,
    borderRadius = _ref3$theme.borderRadius,
    colors = _ref3$theme.colors,
    isFocused = _ref3.isFocused;
  return {
    alignItems: 'center',
    borderRadius: borderRadius / 2,
    backgroundColor: isFocused ? colors.dangerLight : undefined,
    display: 'flex',
    paddingLeft: spacing.baseUnit,
    paddingRight: spacing.baseUnit,
    ':hover': {
      backgroundColor: colors.dangerLight,
      color: colors.danger
    }
  };
};
var MultiValueGeneric = function MultiValueGeneric(_ref4) {
  var children = _ref4.children,
    innerProps = _ref4.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children,
    innerProps = _ref5.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    role: "button"
  }, innerProps), children || (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue(props) {
  var children = props.children,
    className = props.className,
    components = props.components,
    cx = props.cx,
    data = props.data,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isDisabled = props.isDisabled,
    removeProps = props.removeProps,
    selectProps = props.selectProps;
  var Container = components.Container,
    Label = components.Label,
    Remove = components.Remove;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(_emotion_react__WEBPACK_IMPORTED_MODULE_11__.ClassNames, null, function (_ref6) {
    var css = _ref6.css,
      emotionCx = _ref6.cx;
    return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Container, {
      data: data,
      innerProps: _objectSpread2({
        className: emotionCx(css(getStyles('multiValue', props)), cx({
          'multi-value': true,
          'multi-value--is-disabled': isDisabled
        }, className))
      }, innerProps),
      selectProps: selectProps
    }, (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Label, {
      data: data,
      innerProps: {
        className: emotionCx(css(getStyles('multiValueLabel', props)), cx({
          'multi-value__label': true
        }, className))
      },
      selectProps: selectProps
    }, children), (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)(Remove, {
      data: data,
      innerProps: _objectSpread2({
        className: emotionCx(css(getStyles('multiValueRemove', props)), cx({
          'multi-value__remove': true
        }, className)),
        'aria-label': "Remove ".concat(children || 'option')
      }, removeProps),
      selectProps: selectProps
    }));
  });
};
var optionCSS = function optionCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    isFocused = _ref.isFocused,
    isSelected = _ref.isSelected,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'option',
    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
    cursor: 'default',
    display: 'block',
    fontSize: 'inherit',
    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
    width: '100%',
    userSelect: 'none',
    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
    // provide some affordance on touch devices
    ':active': {
      backgroundColor: !isDisabled ? isSelected ? colors.primary : colors.primary50 : undefined
    }
  };
};
var Option = function Option(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    isDisabled = props.isDisabled,
    isFocused = props.isFocused,
    isSelected = props.isSelected,
    innerRef = props.innerRef,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('option', props),
    className: cx({
      option: true,
      'option--is-disabled': isDisabled,
      'option--is-focused': isFocused,
      'option--is-selected': isSelected
    }, className),
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var placeholderCSS = function placeholderCSS(_ref) {
  var _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'placeholder',
    color: colors.neutral50,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2
  };
};
var Placeholder = function Placeholder(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('placeholder', props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};
var css = function css(_ref) {
  var isDisabled = _ref.isDisabled,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'singleValue',
    color: isDisabled ? colors.neutral40 : colors.neutral80,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    maxWidth: '100%',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  };
};
var SingleValue = function SingleValue(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    isDisabled = props.isDisabled,
    innerProps = props.innerProps;
  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_11__.jsx)("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    css: getStyles('singleValue', props),
    className: cx({
      'single-value': true,
      'single-value--is-disabled': isDisabled
    }, className)
  }, innerProps), children);
};
var components = {
  ClearIndicator: ClearIndicator,
  Control: Control,
  DropdownIndicator: DropdownIndicator,
  DownChevron: DownChevron,
  CrossIcon: CrossIcon,
  Group: Group,
  GroupHeading: GroupHeading,
  IndicatorsContainer: IndicatorsContainer,
  IndicatorSeparator: IndicatorSeparator,
  Input: Input,
  LoadingIndicator: LoadingIndicator,
  Menu: Menu,
  MenuList: MenuList,
  MenuPortal: MenuPortal,
  LoadingMessage: LoadingMessage,
  NoOptionsMessage: NoOptionsMessage,
  MultiValue: MultiValue,
  MultiValueContainer: MultiValueContainer,
  MultiValueLabel: MultiValueLabel,
  MultiValueRemove: MultiValueRemove,
  Option: Option,
  Placeholder: Placeholder,
  SelectContainer: SelectContainer,
  SingleValue: SingleValue,
  ValueContainer: ValueContainer
};
var defaultComponents = function defaultComponents(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};


/***/ }),

/***/ "../../node_modules/react-select/dist/react-select.esm.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-select/dist/react-select.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NonceProvider": () => (/* binding */ NonceProvider),
/* harmony export */   "components": () => (/* reexport safe */ _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_7__.c),
/* harmony export */   "createFilter": () => (/* reexport safe */ _Select_54ac8379_esm_js__WEBPACK_IMPORTED_MODULE_3__.c),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "defaultTheme": () => (/* reexport safe */ _Select_54ac8379_esm_js__WEBPACK_IMPORTED_MODULE_3__.d),
/* harmony export */   "mergeStyles": () => (/* reexport safe */ _Select_54ac8379_esm_js__WEBPACK_IMPORTED_MODULE_3__.m),
/* harmony export */   "useStateManager": () => (/* reexport safe */ _useStateManager_68425271_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)
/* harmony export */ });
/* harmony import */ var _useStateManager_68425271_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useStateManager-68425271.esm.js */ "../../node_modules/react-select/dist/useStateManager-68425271.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var _Select_54ac8379_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Select-54ac8379.esm.js */ "../../node_modules/react-select/dist/Select-54ac8379.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index-a7690a33.esm.js */ "../../node_modules/react-select/dist/index-a7690a33.esm.js");
/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @emotion/react */ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js");
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/cache */ "../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js");
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! memoize-one */ "../../node_modules/react-select/node_modules/memoize-one/dist/memoize-one.esm.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");






















var StateManagedSelect = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(function (props, ref) {
  var baseSelectProps = (0,_useStateManager_68425271_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(props);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(_Select_54ac8379_esm_js__WEBPACK_IMPORTED_MODULE_3__.S, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    ref: ref
  }, baseSelectProps));
});
var NonceProvider = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_6__["default"])(NonceProvider, _Component);
  var _super = (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(NonceProvider);
  function NonceProvider(props) {
    var _this;
    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, NonceProvider);
    _this = _super.call(this, props);
    _this.createEmotionCache = function (nonce, key) {
      return (0,_emotion_cache__WEBPACK_IMPORTED_MODULE_8__["default"])({
        nonce: nonce,
        key: key
      });
    };
    _this.createEmotionCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_16__["default"])(_this.createEmotionCache);
    return _this;
  }
  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(NonceProvider, [{
    key: "render",
    value: function render() {
      var emotionCache = this.createEmotionCache(this.props.nonce, this.props.cacheKey);
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(_emotion_react__WEBPACK_IMPORTED_MODULE_17__.C, {
        value: emotionCache
      }, this.props.children);
    }
  }]);
  return NonceProvider;
}(react__WEBPACK_IMPORTED_MODULE_2__.Component);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StateManagedSelect);


/***/ }),

/***/ "../../node_modules/react-select/dist/useStateManager-68425271.esm.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/react-select/dist/useStateManager-68425271.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": () => (/* binding */ useStateManager)
/* harmony export */ });
/* harmony import */ var _index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-a7690a33.esm.js */ "../../node_modules/react-select/dist/index-a7690a33.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");




var _excluded = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref) {
  var _ref$defaultInputValu = _ref.defaultInputValue,
    defaultInputValue = _ref$defaultInputValu === void 0 ? '' : _ref$defaultInputValu,
    _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
    defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
    _ref$defaultValue = _ref.defaultValue,
    defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
    propsInputValue = _ref.inputValue,
    propsMenuIsOpen = _ref.menuIsOpen,
    propsOnChange = _ref.onChange,
    propsOnInputChange = _ref.onInputChange,
    propsOnMenuClose = _ref.onMenuClose,
    propsOnMenuOpen = _ref.onMenuOpen,
    propsValue = _ref.value,
    restSelectProps = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, _excluded);
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(propsInputValue !== undefined ? propsInputValue : defaultInputValue),
    _useState2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_useState, 2),
    stateInputValue = _useState2[0],
    setStateInputValue = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen),
    _useState4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_useState3, 2),
    stateMenuIsOpen = _useState4[0],
    setStateMenuIsOpen = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(propsValue !== undefined ? propsValue : defaultValue),
    _useState6 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_useState5, 2),
    stateValue = _useState6[0],
    setStateValue = _useState6[1];
  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(function (value, actionMeta) {
    if (typeof propsOnChange === 'function') {
      propsOnChange(value, actionMeta);
    }
    setStateValue(value);
  }, [propsOnChange]);
  var onInputChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(function (value, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === 'function') {
      newValue = propsOnInputChange(value, actionMeta);
    }
    setStateInputValue(newValue !== undefined ? newValue : value);
  }, [propsOnInputChange]);
  var onMenuOpen = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(function () {
    if (typeof propsOnMenuOpen === 'function') {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(function () {
    if (typeof propsOnMenuClose === 'function') {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== undefined ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== undefined ? propsValue : stateValue;
  return (0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_3__.a)((0,_index_a7690a33_esm_js__WEBPACK_IMPORTED_MODULE_3__.a)({}, restSelectProps), {}, {
    inputValue: inputValue,
    menuIsOpen: menuIsOpen,
    onChange: onChange,
    onInputChange: onInputChange,
    onMenuClose: onMenuClose,
    onMenuOpen: onMenuOpen,
    value: value
  });
}


/***/ }),

/***/ "../../node_modules/react-select/node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hoist-non-react-statics */ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0__);


// this file isolates this package that is not tree-shakeable
// and if this module doesn't actually contain any logic of its own
// then Rollup just use 'hoist-non-react-statics' directly in other chunks

var hoistNonReactStatics = function (targetComponent, sourceComponent) {
  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_0___default()(targetComponent, sourceComponent);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hoistNonReactStatics);

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ CacheProvider),
/* harmony export */   "E": () => (/* binding */ Emotion),
/* harmony export */   "T": () => (/* binding */ ThemeContext),
/* harmony export */   "_": () => (/* binding */ __unsafe_useEmotionCache),
/* harmony export */   "a": () => (/* binding */ ThemeProvider),
/* harmony export */   "b": () => (/* binding */ withTheme),
/* harmony export */   "c": () => (/* binding */ createEmotionProps),
/* harmony export */   "h": () => (/* binding */ hasOwnProperty),
/* harmony export */   "u": () => (/* binding */ useTheme),
/* harmony export */   "w": () => (/* binding */ withEmotionCache)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/cache */ "../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/react-select/node_modules/@emotion/react/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/weak-memoize */ "../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var _isolated_hnrs_dist_emotion_react_isolated_hnrs_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js */ "../../node_modules/react-select/node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js");
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/utils */ "../../node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/serialize */ "../../node_modules/react-select/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js");
/* harmony import */ var _emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/use-insertion-effect-with-fallbacks */ "../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js");








var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* #__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(
// we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */(0,_emotion_cache__WEBPACK_IMPORTED_MODULE_1__["default"])({
  key: 'css'
}) : null);
if (true) {
  EmotionCacheContext.displayName = 'EmotionCacheContext';
}
var CacheProvider = EmotionCacheContext.Provider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);
};
var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* #__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});
if (true) {
  ThemeContext.displayName = 'EmotionThemeContext';
}
var useTheme = function useTheme() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);
};
var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);
    if ( true && (mergedTheme == null || typeof mergedTheme !== 'object' || Array.isArray(mergedTheme))) {
      throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');
    }
    return mergedTheme;
  }
  if ( true && (theme == null || typeof theme !== 'object' || Array.isArray(theme))) {
    throw new Error('[ThemeProvider] Please make your theme prop a plain object');
  }
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__["default"])({}, outerTheme, theme);
};
var createCacheWithTheme = /* #__PURE__ */(0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__["default"])(function (outerTheme) {
  return (0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_3__["default"])(function (theme) {
    return getTheme(outerTheme, theme);
  });
});
var ThemeProvider = function ThemeProvider(props) {
  var theme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);
  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ThemeContext.Provider, {
    value: theme
  }, props.children);
};
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';
  var render = function render(props, ref) {
    var theme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__["default"])({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe

  var WithTheme = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return (0,_isolated_hnrs_dist_emotion_react_isolated_hnrs_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WithTheme, Component);
}
var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};
var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};
var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return undefined;
};
var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if ( true && typeof props.css === 'string' &&
  // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when
  // the label hasn't already been computed

  if ( true && !!props.css && (typeof props.css !== 'object' || typeof props.css.name !== 'string' || props.css.name.indexOf('-') === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
    serialized = _ref.serialized,
    isStringTag = _ref.isStringTag;
  (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.registerStyles)(cache, serialized, isStringTag);
  var rules = (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_6__.useInsertionEffectAlwaysWithSyncFallback)(function () {
    return (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.insertStyles)(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';
  if (typeof props.className === 'string') {
    className = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_4__.getRegisteredStyles)(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_5__.serializeStyles)(registeredStyles, undefined, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext));
  if ( true && serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_5__.serializeStyles)([serialized, 'label:' + labelFromStack + ';']);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( false || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = 'EmotionCssPropInternal';
}


/***/ }),

/***/ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-react.browser.esm.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-react.browser.esm.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheProvider": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.C),
/* harmony export */   "ClassNames": () => (/* binding */ ClassNames),
/* harmony export */   "Global": () => (/* binding */ Global),
/* harmony export */   "ThemeContext": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.T),
/* harmony export */   "ThemeProvider": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),
/* harmony export */   "__unsafe_useEmotionCache": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._),
/* harmony export */   "createElement": () => (/* binding */ jsx),
/* harmony export */   "css": () => (/* binding */ css),
/* harmony export */   "jsx": () => (/* binding */ jsx),
/* harmony export */   "keyframes": () => (/* binding */ keyframes),
/* harmony export */   "useTheme": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.u),
/* harmony export */   "withEmotionCache": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.w),
/* harmony export */   "withTheme": () => (/* reexport safe */ _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.b)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/cache */ "../../node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js");
/* harmony import */ var _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emotion-element-6a883da9.browser.esm.js */ "../../node_modules/react-select/node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/react-select/node_modules/@emotion/react/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/weak-memoize */ "../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hoist-non-react-statics */ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/utils */ "../../node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @emotion/serialize */ "../../node_modules/react-select/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js");
/* harmony import */ var _emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/use-insertion-effect-with-fallbacks */ "../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js");











var pkg = {
  name: "@emotion/react",
  version: "11.10.4",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": "./macro.js"
  },
  types: "types/index.d.ts",
  files: ["src", "dist", "jsx-runtime", "jsx-dev-runtime", "_isolated-hnrs", "types/*.d.ts", "macro.js", "macro.d.ts", "macro.js.flow"],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.10.0",
    "@emotion/cache": "^11.10.0",
    "@emotion/serialize": "^1.1.0",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
    "@emotion/utils": "^1.2.0",
    "@emotion/weak-memoize": "^0.3.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    "@babel/core": "^7.0.0",
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@babel/core": {
      optional: true
    },
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@babel/core": "^7.18.5",
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.10.0",
    "@emotion/css-prettifier": "1.1.0",
    "@emotion/server": "11.10.0",
    "@emotion/styled": "11.10.4",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: ["./index.js", "./jsx-runtime.js", "./jsx-dev-runtime.js", "./_isolated-hnrs.js"],
    umdName: "emotionReact",
    exports: {
      envConditions: ["browser", "worker"],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      }
    }
  }
};
var jsx = function jsx(type, props) {
  var args = arguments;
  if (props == null || !_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.h.call(props, 'css')) {
    // $FlowFixMe
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(undefined, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = _emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.E;
  createElementArgArray[1] = (0,_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.c)(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(null, createElementArgArray);
};
var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */(0,_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.w)(function (props, cache) {
  if ( true && !warnedAboutCssPropForGlobal && (
  // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_7__.serializeStyles)([styles], undefined, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.T));
  // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything

  var sheetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_8__.useInsertionEffectWithLayoutFallback)(function () {
    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

    var sheet = new cache.sheet.constructor({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false; // $FlowFixMe

    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_8__.useInsertionEffectWithLayoutFallback)(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
      rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== undefined) {
      // insert keyframes
      (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_6__.insertStyles)(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = 'EmotionGlobal';
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_7__.serializeStyles)(args);
}
var keyframes = function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case 'boolean':
        break;
      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if ( true && arg.styles !== undefined && arg.name !== undefined) {
              console.error('You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n' + '`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.');
            }
            toAdd = '';
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }
          break;
        }
      default:
        {
          toAdd = arg;
        }
    }
    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_6__.getRegisteredStyles)(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css(registeredStyles);
}
var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
    serializedArr = _ref.serializedArr;
  var rules = (0,_emotion_use_insertion_effect_with_fallbacks__WEBPACK_IMPORTED_MODULE_8__.useInsertionEffectAlwaysWithSyncFallback)(function () {
    for (var i = 0; i < serializedArr.length; i++) {
      var res = (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_6__.insertStyles)(cache, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = /* #__PURE__ */(0,_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.w)(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css = function css() {
    if (hasRendered && "development" !== 'production') {
      throw new Error('css can only be used during render');
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = (0,_emotion_serialize__WEBPACK_IMPORTED_MODULE_7__.serializeStyles)(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    (0,_emotion_utils__WEBPACK_IMPORTED_MODULE_6__.registerStyles)(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx() {
    if (hasRendered && "development" !== 'production') {
      throw new Error('cx can only be used during render');
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css, classnames(args));
  };
  var content = {
    css: css,
    cx: cx,
    theme: (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_emotion_element_6a883da9_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.T)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = 'EmotionClassNames';
}
if (true) {
  var isBrowser = "object" !== 'undefined'; // #1727 for some reason Jest evaluates modules twice if some consuming module gets mocked with jest.mock

  var isJest = typeof jest !== 'undefined';
  if (isBrowser && !isJest) {
    // globalThis has wide browser support - https://caniuse.com/?search=globalThis, Node.js 12 and later
    var globalContext =
    // $FlowIgnore
    typeof globalThis !== 'undefined' ? globalThis // eslint-disable-line no-undef
    : isBrowser ? window : __webpack_require__.g;
    var globalKey = "__EMOTION_REACT_" + pkg.version.split('.')[0] + "__";
    if (globalContext[globalKey]) {
      console.warn('You are loading @emotion/react when it is already loaded. Running ' + 'multiple instances may cause problems. This can happen if multiple ' + 'versions are used, or if multiple builds of the same version are ' + 'used.');
    }
    globalContext[globalKey] = true;
  }
}


/***/ }),

/***/ "../../node_modules/react-select/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeStyles": () => (/* binding */ serializeStyles)
/* harmony export */ });
/* harmony import */ var _emotion_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/hash */ "../../node_modules/@emotion/hash/dist/emotion-hash.esm.js");
/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/unitless */ "../../node_modules/@emotion/unitless/dist/emotion-unitless.esm.js");
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/memoize */ "../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");



var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};
var processStyleName = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_2__["default"])(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});
var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }
  if (_emotion_unitless__WEBPACK_IMPORTED_MODULE_1__["default"][key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }
  return value;
};
if (true) {
  var contentValuePattern = /(var|attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};
  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }
  if (interpolation.__emotion_styles !== undefined) {
    if ( true && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }
    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== undefined) {
          var next = interpolation.next;
          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }
          var styles = interpolation.styles + ";";
          if ( true && interpolation.map !== undefined) {
            styles += interpolation.map;
          }
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (true) {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }
        break;
      }
    case 'string':
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
        }
      }
      break;
  } // finalize string values (regular strings and functions interpolated into css calls)

  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = '';
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
            default:
              {
                if ( true && _key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }
                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list

var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }
  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];
  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if ( true && strings[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  } // we start at 1 since we've already handled the first arg

  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if ( true && strings[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i];
    }
  }
  var sourceMap;
  if (true) {
    styles = styles.replace(sourceMapPattern, function (match) {
      sourceMap = match;
      return '';
    });
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time

  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' +
    // $FlowFixMe we know it's not null
    match[1];
  }
  var name = (0,_emotion_hash__WEBPACK_IMPORTED_MODULE_0__["default"])(styles) + identifierName;
  if (true) {
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
      name: name,
      styles: styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name,
    styles: styles,
    next: cursor
  };
};


/***/ }),

/***/ "../../node_modules/react-select/node_modules/memoize-one/dist/memoize-one.esm.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === 'number' && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoizeOne);

/***/ }),

/***/ "../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!../../node_modules/@glideapps/glide-data-grid/dist/index.css":
/*!***************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!../../node_modules/@glideapps/glide-data-grid/dist/index.css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: flex;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  transform: translateX(var(--sxep88s-0));\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: flex;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: flex;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: flex;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  -o-object-fit: contain;\n     object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  -o-object-fit: contain;\n     object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: flex;\n  align-items: flex-start;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  flex: 1 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  flex-shrink: 0;\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: flex;\n  flex-grow: 1;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  flex-grow: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n", "",{"version":3,"sources":["webpack://./../../node_modules/@glideapps/glide-data-grid/dist/index.css","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-editor/group-rename.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-editor-container/data-grid-container.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/markdown-div/private/markdown-container.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/growing-entry/growing-entry-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/number-overlay-editor-style.tsx","webpack://./../../../../glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx"],"names":[".d1t1th9s",".m15w2ly5",".s1jz82f8",".sxep88s",".r1kzy40b",".c1sqdbw3",".wzg2m5k",".b1bqsp5z",".df2kt4a",".i1eozt10",".mlbeo71",".ijuk0po",".saq3p5l",".gf8vzix",".mdwzdl1",".n1czszh3",".uf0sjo8"],"mappings":"AAAA,+DAA+D;ACCrBA;EAAAA,kBAAAA;EAAAA,aAAAA;EAAAA,sBAAAA;EAAAA,gBAAAA;EAAAA,sBAAAA;EAAAA,+BAAAA;EAAAA,uBAAAA;EAAAA,sBAAAA;EAAAA,4BAAAA;EAAAA,6BAAAA;EAAAA,uBAAAA;EAAAA,kBAAAA;EAAAA,gBAAAA;EAAAA,2CAAAA;EAAAA,mCAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;ADwB1C;ACxB0CA;EDkCxC;IClCwCA,WAAAA;EDoCxC;EACA;ICrCwCA,aAAAA;EDuCxC;AACF;ACxC0CA;EAAAA,kBAAAA;EAAAA,oCAAAA;EAAAA;;;uCD+CH;EC/CGA,wCAAAA;ADkD1C;AClD0CA;EAAAA,oCAAAA;ADqD1C;ACrD0CA;EAAAA,aAAAA;EAAAA,sBAAAA;EAAAA,gBAAAA;EAAAA,kBAAAA;EAAAA,kBAAAA;EAAAA,YAAAA;ADqE1C;ACrE0CA;EAAAA,YAAAA;ADwE1C;ACxE0CA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;AD8E1C;AC9E0CA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;ADmF1C;;AAEA,mDAAmD;AEjF9BC;EAAAA,kBAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,oCAAAA;EAAAA,0EAAAA;EAAAA,kBAAAA;EAAAA,UAAAA;EAAAA,4EAAAA;EAAAA,gBAAAA;AF4FrB;AE5FqBA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;EAAAA,WAAAA;EAAAA,WAAAA;EAAAA,sCAAAA;EAAAA,6CAAAA;AFqGrB;AErGqBA;EAAAA,kBAAAA;EAAAA,yCAAAA;EAAAA,yCAAAA;AF0GrB;;AAEA,kDAAkD;AG5GxBC;EAAAA,2BAAAA;EAAAA,+BAAAA;AHkH1B;AGlH0BA;EAAAA,kBAAAA;AHqH1B;AGrH0BA;EAAAA,aAAAA;EAAAA,oBAAAA;AH4H1B;AG5H0BA;EAAAA,cAAAA;AHiI1B;AGjI0BA;EAAAA,YAAAA;AHuI1B;AGvI0BA;EAAAA,aAAAA;EAAAA,sBAAAA;AHgJ1B;AGhJ0BA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;AHqJ1B;AGrJ0BA;EAAAA,aAAAA;AHwJ1B;AGxJ0BA;EAAAA,SAAAA;AH2J1B;;AAEA,sDAAsD;AIjKzBC;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,WAAAA;EAAAA,oCAAAA;EAAAA,2BAAAA;EAAAA,YAAAA;EAAAA,yCAAAA;EAAAA,kBAAAA;EAAAA,sCAAAA;EAAAA,uCAAAA;EAAAA,2BAAAA;AJkL7B;AIlL6BA;EAAAA,aAAAA;AJwL7B;AIxL6BA;EAAAA,gBAAAA;EAAAA,eAAAA;AJ4L7B;AI5L6BA;EAAAA,kBAAAA;EAAAA,WAAAA;EAAAA,OAAAA;EAAAA,SAAAA;EAAAA,uCAAAA;AJmM7B;AInM6BA;EAAAA,YAAAA;EAAAA,0BAAAA;EAAAA,oCAAAA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;AJ2M7B;AI3M6BA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,UAAAA;EAAAA,YAAAA;EAAAA,aAAAA;EAAAA,gBAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,eAAAA;EAAAA,6BAAAA;AJiO7B;AIjO6BA;EAAAA,2BAAAA;AJoO7B;AIpO6BA;EAAAA,WAAAA;EAAAA,YAAAA;AJwO7B;AIxO6BA;EAAAA,YAAAA;EAAAA,oBAAAA;AJ4O7B;;AAEA,4CAA4C;AK3OxBC;EAAAA,YAAAA;EAAAA,YAAAA;EAAAA,aAAAA;EAAAA,gDAAAA;EAAAA,kBAAAA;EAAAA,cAAAA;EAAAA,6CAAAA;EAAAA,mCAAAA;EAAAA,6BAAAA;EAAAA,yDAAAA;AL0PpB;AKnOeC;EAAAA,cAAAA;EAAAA,aAAAA;EAAAA,mBAAAA;EAAAA,sCAAAA;AL+Of;;AAEA,mDAAmD;AMrQnCC;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,uBAAAA;EAAAA,wBAAAA;EAAAA,gBAAAA;EAAAA,cAAAA;EAAAA,eAAAA;ANiRhB;AMjRgBA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;EAAAA,WAAAA;EAAAA,YAAAA;ANwRhB;;AAEA,6DAA6D;AOhSpBC;EAAAA,aAAAA;EAAAA,eAAAA;APySzC;AOzSyCA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,YAAAA;EAAAA,sCAAAA;EAAAA,2BAAAA;EAAAA,WAAAA;AP6TzC;AO7TyCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;APqUzC;;AAEA,yDAAyD;AQtUrBC;EAAAA,aAAAA;EAAAA,eAAAA;AR+UpC;AQ/UoCA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,YAAAA;EAAAA,oCAAAA;EAAAA,2BAAAA;EAAAA,WAAAA;EAAAA,kBAAAA;EAAAA,0EAAAA;ARqWpC;AQrWoCA;EAAAA,YAAAA;EAAAA,sBAAAA;KAAAA,mBAAAA;EAAAA,iBAAAA;AR0WpC;AQ1WoCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;ARkXpC;;AAEA,0DAA0D;ASrXnBC;EAAAA,aAAAA;EAAAA,YAAAA;AT4XvC;AS5XuCA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,YAAAA;AT2YvC;AS3YuCA;;EAAAA,mDAAAA;EAAAA,sBAAAA;KAAAA,mBAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,iBAAAA;AToZvC;ASpZuCA;EAAAA,gBAAAA;ATuZvC;ASvZuCA;EAAAA,kBAAAA;EAAAA,SAAAA;EAAAA,QAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,8BAAAA;EAAAA,eAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;AT4avC;AS5auCA;EAAAA,WAAAA;EAAAA,YAAAA;ATgbvC;AShbuCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;ATwbvC;;AAEA,kDAAkD;AU1bjBC;EAAAA,sBAAAA;EAAAA,8BAAAA;EAAAA,gBAAAA;AV+bjC;AU/biCA;EAAAA,SAAAA;AVkcjC;AUlciCA;EAAAA,gBAAAA;AVqcjC;AUrciCA;EAAAA,WAAAA;AVwcjC;;AAEA,mDAAmD;AW1c3BC;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,QAAAA;EAAAA,MAAAA;EAAAA,SAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,kBAAAA;EAAAA,YAAAA;EAAAA,qBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,SAAAA;EAAAA,6BAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,UAAAA;EAAAA,SAAAA;AXgexB;AWhewBA;EAAAA,4BAAAA;AXsexB;AWtewBA;EAAAA,4BAAAA;AX4exB;AW5ewBA;EAAAA,kCAAAA;EAAAA,0BAAAA;EAAAA,8BAAAA;AXkfxB;AWhdyBC;EAAAA,kBAAAA;EAAAA,qBAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,eAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,UAAAA;EAAAA,SAAAA;EAAAA,mBAAAA;AXiezB;AW9ciCC;EAAAA,kBAAAA;EAAAA,eAAAA;AXkdjC;;AAEA,6DAA6D;AYxgBnBC;EAAAA,2BAAAA;EAAAA,WAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,8BAAAA;EAAAA,kBAAAA;EAAAA,2BAAAA;AZ0hB1C;AY1hB0CA;EAAAA,cAAAA;EAAAA,YAAAA;AZgiB1C;AYhiB0CA;EAAAA,SAAAA;AZqiB1C;AYriB0CA;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,8BAAAA;EAAAA,UAAAA;EAAAA,YAAAA;EAAAA,WAAAA;EAAAA,cAAAA;EAAAA,6BAAAA;EAAAA,kBAAAA;AZ+jB1C;AY/jB0CA;EAAAA,WAAAA;EAAAA,YAAAA;AZmkB1C;AYnkB0CA;EAAAA,yCAAAA;EAAAA,kCAAAA;AZwkB1C;AYxkB0CA;EAAAA,cAAAA;EAAAA,yCAAAA;AZ4kB1C;AY5kB0CA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,gBAAAA;EAAAA,UAAAA;EAAAA,UAAAA;AZslB1C;AYtlB0CA;EAAAA,gBAAAA;AZylB1C;;AAEA,2DAA2D;Aa5lBnBC;EAAAA,aAAAA;EAAAA,iBAAAA;EAAAA,2BAAAA;AbomBxC;AapmBwCA;EAAAA,sCAAAA;EAAAA,UAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,oCAAAA;Ab2mBxC;;AAEA,wDAAwD;Ac7mBnBC;EAAAA,aAAAA;EAAAA,YAAAA;EAAAA,mBAAAA;EAAAA,gBAAAA;Ad4nBrC;Ac5nBqCA;EAAAA,YAAAA;EAAAA,cAAAA;EAAAA,eAAAA;EAAAA,iBAAAA;EAAAA,gBAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,4BAAAA;EAAAA,6CAAAA;EAAAA,qCAAAA;Ad6oBrC;Ac7oBqCA;EAAAA,cAAAA;EAAAA,WAAAA;EAAAA,8BAAAA;EAAAA,eAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;AdiqBrC;AcjqBqCA;EAAAA,WAAAA;EAAAA,YAAAA;AdqqBrC;AcrqBqCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;Ad6qBrC","sourcesContent":["/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@-webkit-keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  -webkit-transform: translateX(var(--sxep88s-0));\n  -ms-transform: translateX(var(--sxep88s-0));\n  transform: translateX(var(--sxep88s-0));\n  -webkit-transition: -webkit-transform 0.15s;\n  -webkit-transition: transform 0.15s;\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-webkit-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po:-ms-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  -webkit-text-decoration-color: #d60606;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: flex-start;\n  -webkit-box-align: flex-start;\n  -ms-flex-align: flex-start;\n  align-items: flex-start;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  -webkit-transition: all \"0.125s ease\";\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  -webkit-transition: background-color 150ms;\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n","import { styled } from \"@linaria/react\";\nexport const DataGridOverlayEditorStyle = styled.div`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${(p) => p.targetY}px;\n\n    left: ${(p) => p.targetX - 1}px;\n    top: ${(p) => p.targetY - 1}px;\n    min-width: ${(p) => p.targetWidth + 2}px;\n    min-height: ${(p) => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${(p) => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${(p) => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0WDogbnVtYmVyO1xuICAgIHRhcmdldFk6IG51bWJlcjtcbiAgICB0YXJnZXRXaWR0aDogbnVtYmVyO1xuICAgIHRhcmdldEhlaWdodDogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IERhdGFHcmlkT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgIC0tb3ZlcmxheS10b3A6ICR7cCA9PiBwLnRhcmdldFl9cHg7XG5cbiAgICBsZWZ0OiAke3AgPT4gcC50YXJnZXRYIC0gMX1weDtcbiAgICB0b3A6ICR7cCA9PiBwLnRhcmdldFkgLSAxfXB4O1xuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGggKyAyfXB4O1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBwLnRhcmdldEhlaWdodCArIDJ9cHg7XG4gICAgd2lkdGg6IG1heC1jb250ZW50O1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtICR7cCA9PiBwLnRhcmdldFkgKyAxMH1weCk7XG5cbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcblxuICAgIEBrZXlmcmFtZXMgZ2xpZGVfZmFkZV9pbiB7XG4gICAgICAgIGZyb20ge1xuICAgICAgICAgICAgb3BhY2l0eTogMCU7XG4gICAgICAgIH1cblxuICAgICAgICB0byB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5nZGctc3R5bGUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcblxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWFjY2VudC1jb2xvciksIDBweCAwcHggMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC40KSxcbiAgICAgICAgICAgIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMTUpO1xuXG4gICAgICAgIGFuaW1hdGlvbjogZ2xpZGVfZmFkZV9pbiA2MG1zIDE7XG4gICAgfVxuXG4gICAgJi5wYWQge1xuICAgICAgICBwYWRkaW5nOiAke3AgPT4gTWF0aC5tYXgoMCwgKHAudGFyZ2V0SGVpZ2h0IC0gMjgpIC8gMil9cHggOC41cHggM3B4O1xuICAgIH1cblxuICAgIC5jbGlwLXJlZ2lvbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgLmdkZy1ncm93aW5nLWVudHJ5IHtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgICYgaW5wdXQuZ2RnLWlucHV0IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgICYgdGV4dGFyZWEuZ2RnLWlucHV0IHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0LWFsaWduOiBzdGFydDtcbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQVFPLGFBQU0sNkJBQTZCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQVE1QixPQUFLLEVBQUU7QUFBQTtBQUFBLFlBRWhCLE9BQUssRUFBRSxVQUFVO0FBQUEsV0FDbEIsT0FBSyxFQUFFLFVBQVU7QUFBQSxpQkFDWCxPQUFLLEVBQUUsY0FBYztBQUFBLGtCQUNwQixPQUFLLEVBQUUsZUFBZTtBQUFBO0FBQUE7QUFBQSwrQkFHVCxPQUFLLEVBQUUsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBMEI3QixPQUFLLEtBQUssSUFBSSxHQUFJLEdBQUUsZUFBZSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd from \"../data-grid-dnd/data-grid-dnd\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\nconst GridScroller = (p) => {\n  const {\n    columns,\n    rows,\n    rowHeight,\n    headerHeight,\n    groupHeaderHeight,\n    enableGroups,\n    freezeColumns,\n    experimental,\n    clientSize,\n    className,\n    onVisibleRegionChanged,\n    scrollToEnd,\n    scrollRef,\n    preventDiagonalScrolling,\n    rightElement,\n    rightElementProps,\n    overscrollX,\n    overscrollY,\n    showMinimap = false,\n    initialSize,\n    smoothScrollX = false,\n    smoothScrollY = false,\n    isDraggable\n  } = p;\n  const { paddingRight, paddingBottom } = experimental ?? {};\n  const [clientWidth, clientHeight] = clientSize;\n  const last = React.useRef();\n  const lastX = React.useRef();\n  const lastY = React.useRef();\n  const lastSize = React.useRef();\n  const width = React.useMemo(() => {\n    let r = Math.max(0, overscrollX ?? 0);\n    for (const c of columns) {\n      r += c.width;\n    }\n    return r;\n  }, [columns, overscrollX]);\n  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n  if (typeof rowHeight === \"number\") {\n    height += rows * rowHeight;\n  } else {\n    for (let r = 0; r < rows; r++) {\n      height += rowHeight(r);\n    }\n  }\n  if (overscrollY !== void 0) {\n    height += overscrollY;\n  }\n  const lastArgs = React.useRef();\n  const processArgs = React.useCallback(() => {\n    if (lastArgs.current === void 0)\n      return;\n    const args = { ...lastArgs.current };\n    let x = 0;\n    let tx = args.x < 0 ? -args.x : 0;\n    let cellRight = 0;\n    let cellX = 0;\n    args.x = args.x < 0 ? 0 : args.x;\n    let stickyColWidth = 0;\n    for (let i = 0; i < freezeColumns; i++) {\n      stickyColWidth += columns[i].width;\n    }\n    for (const c of columns) {\n      const cx = x - stickyColWidth;\n      if (args.x >= cx + c.width) {\n        x += c.width;\n        cellX++;\n        cellRight++;\n      } else if (args.x > cx) {\n        x += c.width;\n        if (smoothScrollX) {\n          tx += cx - args.x;\n        } else {\n          cellX++;\n        }\n        cellRight++;\n      } else if (args.x + args.width > cx) {\n        x += c.width;\n        cellRight++;\n      } else {\n        break;\n      }\n    }\n    let ty = 0;\n    let cellY = 0;\n    let cellBottom = 0;\n    if (typeof rowHeight === \"number\") {\n      if (smoothScrollY) {\n        cellY = Math.floor(args.y / rowHeight);\n        ty = cellY * rowHeight - args.y;\n      } else {\n        cellY = Math.ceil(args.y / rowHeight);\n      }\n      cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n      if (ty < 0)\n        cellBottom++;\n    } else {\n      let y = 0;\n      for (let row = 0; row < rows; row++) {\n        const rh = rowHeight(row);\n        const cy = y + (smoothScrollY ? 0 : rh / 2);\n        if (args.y >= y + rh) {\n          y += rh;\n          cellY++;\n          cellBottom++;\n        } else if (args.y > cy) {\n          y += rh;\n          if (smoothScrollY) {\n            ty += cy - args.y;\n          } else {\n            cellY++;\n          }\n          cellBottom++;\n        } else if (args.y + args.height > rh / 2 + y) {\n          y += rh;\n          cellBottom++;\n        } else {\n          break;\n        }\n      }\n    }\n    const rect = {\n      x: cellX,\n      y: cellY,\n      width: cellRight - cellX,\n      height: cellBottom - cellY\n    };\n    const oldRect = last.current;\n    if (oldRect === void 0 || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== lastSize.current?.[0] || args.height !== lastSize.current?.[1]) {\n      onVisibleRegionChanged?.({\n        x: cellX,\n        y: cellY,\n        width: cellRight - cellX,\n        height: cellBottom - cellY\n      }, args.width, args.height, args.paddingRight ?? 0, tx, ty);\n      last.current = rect;\n      lastX.current = tx;\n      lastY.current = ty;\n      lastSize.current = [args.width, args.height];\n    }\n  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n  const onScrollUpdate = React.useCallback((args) => {\n    lastArgs.current = args;\n    processArgs();\n  }, [processArgs]);\n  React.useEffect(() => {\n    processArgs();\n  }, [processArgs]);\n  const scroller = scrollRef?.current ?? void 0;\n  const aspect = clamp(width / height, 2 / 3, 1.5);\n  const maxSize = 200;\n  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n  const hRatio = w / width;\n  const vRatio = h / height;\n  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n  const left = (scroller?.scrollLeft ?? 0) / (width - clientWidth) * (w - vWidth);\n  const top = (scroller?.scrollTop ?? 0) / (height - clientHeight) * (h - vHeight);\n  const minimap = React.useMemo(() => {\n    if (!showMinimap || vWidth === 0 || vHeight === 0)\n      return void 0;\n    const handleMouse = (e) => {\n      if (scroller === void 0)\n        return;\n      const bounds = e.currentTarget.getBoundingClientRect();\n      const x = e.clientX - bounds.x - vWidth / 2;\n      const y = e.clientY - bounds.y - vHeight / 2;\n      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n      scroller.scrollTo({\n        left: newScrollLeft,\n        top: newScrollTop,\n        behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\"\n      });\n    };\n    return /* @__PURE__ */ React.createElement(MinimapStyle, {\n      style: { width: w, height: h },\n      \"data-testid\": \"minimap-container\",\n      onMouseMove: (e) => {\n        if (e.buttons !== 1)\n          return;\n        handleMouse(e);\n      },\n      onClick: handleMouse\n    }, /* @__PURE__ */ React.createElement(\"div\", {\n      className: \"header\"\n    }), /* @__PURE__ */ React.createElement(\"div\", {\n      className: \"locationMarker\",\n      onDragStart: (e) => e.preventDefault(),\n      style: {\n        left,\n        top,\n        width: vWidth,\n        height: vHeight,\n        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)\n      }\n    }));\n  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n  return /* @__PURE__ */ React.createElement(InfiniteScroller, {\n    scrollRef,\n    minimap,\n    className,\n    preventDiagonalScrolling,\n    draggable: isDraggable === true || typeof isDraggable === \"string\",\n    scrollWidth: width + (paddingRight ?? 0),\n    scrollHeight: height + (paddingBottom ?? 0),\n    clientHeight,\n    rightElement,\n    paddingBottom,\n    paddingRight,\n    rightElementProps,\n    update: onScrollUpdate,\n    initialSize,\n    scrollToEnd\n  }, /* @__PURE__ */ React.createElement(DataGridDnd, {\n    eventTargetRef: scrollRef,\n    width: clientWidth,\n    height: clientHeight,\n    accessibilityHeight: p.accessibilityHeight,\n    canvasRef: p.canvasRef,\n    cellXOffset: p.cellXOffset,\n    cellYOffset: p.cellYOffset,\n    columns: p.columns,\n    disabledRows: p.disabledRows,\n    enableGroups: p.enableGroups,\n    fillHandle: p.fillHandle,\n    firstColAccessible: p.firstColAccessible,\n    fixedShadowX: p.fixedShadowX,\n    fixedShadowY: p.fixedShadowY,\n    freezeColumns: p.freezeColumns,\n    getCellContent: p.getCellContent,\n    getCellRenderer: p.getCellRenderer,\n    getGroupDetails: p.getGroupDetails,\n    getRowThemeOverride: p.getRowThemeOverride,\n    groupHeaderHeight: p.groupHeaderHeight,\n    headerHeight: p.headerHeight,\n    highlightRegions: p.highlightRegions,\n    imageWindowLoader: p.imageWindowLoader,\n    isFilling: p.isFilling,\n    isFocused: p.isFocused,\n    lockColumns: p.lockColumns,\n    maxColumnWidth: p.maxColumnWidth,\n    minColumnWidth: p.minColumnWidth,\n    onHeaderMenuClick: p.onHeaderMenuClick,\n    onMouseMove: p.onMouseMove,\n    prelightCells: p.prelightCells,\n    rowHeight: p.rowHeight,\n    rows: p.rows,\n    selection: p.selection,\n    theme: p.theme,\n    trailingRowType: p.trailingRowType,\n    translateX: p.translateX,\n    translateY: p.translateY,\n    verticalBorder: p.verticalBorder,\n    drawCustomCell: p.drawCustomCell,\n    drawFocusRing: p.drawFocusRing,\n    drawHeader: p.drawHeader,\n    experimental: p.experimental,\n    gridRef: p.gridRef,\n    headerIcons: p.headerIcons,\n    isDraggable: p.isDraggable,\n    onCanvasBlur: p.onCanvasBlur,\n    onCanvasFocused: p.onCanvasFocused,\n    onCellFocused: p.onCellFocused,\n    onColumnMoved: p.onColumnMoved,\n    onColumnResize: p.onColumnResize,\n    onColumnResizeEnd: p.onColumnResizeEnd,\n    onColumnResizeStart: p.onColumnResizeStart,\n    onContextMenu: p.onContextMenu,\n    onDragEnd: p.onDragEnd,\n    onDragLeave: p.onDragLeave,\n    onDragOverCell: p.onDragOverCell,\n    onDragStart: p.onDragStart,\n    onDrop: p.onDrop,\n    onItemHovered: p.onItemHovered,\n    onKeyDown: p.onKeyDown,\n    onKeyUp: p.onKeyUp,\n    onMouseDown: p.onMouseDown,\n    onMouseUp: p.onMouseUp,\n    onRowMoved: p.onRowMoved,\n    smoothScrollX: p.smoothScrollX,\n    smoothScrollY: p.smoothScrollY\n  }));\n};\nexport default GridScroller;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IERhdGFHcmlkRG5kLCB7IERhdGFHcmlkRG5kUHJvcHMgfSBmcm9tIFwiLi4vZGF0YS1ncmlkLWRuZC9kYXRhLWdyaWQtZG5kXCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbGVyIH0gZnJvbSBcIi4vaW5maW5pdGUtc2Nyb2xsZXJcIjtcbmltcG9ydCBjbGFtcCBmcm9tIFwibG9kYXNoL2NsYW1wLmpzXCI7XG5cbnR5cGUgUHJvcHMgPSBPbWl0PERhdGFHcmlkRG5kUHJvcHMsIFwid2lkdGhcIiB8IFwiaGVpZ2h0XCIgfCBcImV2ZW50VGFyZ2V0UmVmXCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbGluZ0RhdGFHcmlkUHJvcHMgZXh0ZW5kcyBQcm9wcyB7XG4gICAgcmVhZG9ubHkgY2xhc3NOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZDpcbiAgICAgICAgfCAoKFxuICAgICAgICAgICAgICByYW5nZTogUmVjdGFuZ2xlLFxuICAgICAgICAgICAgICBjbGllbnRXaWR0aDogbnVtYmVyLFxuICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IG51bWJlcixcbiAgICAgICAgICAgICAgcmlnaHRFbFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIHR4OiBudW1iZXIsXG4gICAgICAgICAgICAgIHR5OiBudW1iZXJcbiAgICAgICAgICApID0+IHZvaWQpXG4gICAgICAgIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgZ3JpZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB3aGVuIGZsaXBwZWQgdG8gdHJ1ZVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRGF0YUVkaXRvclJlZi5zY3JvbGxUb30gaW5zdGVhZFxuICAgICAqIEBncm91cCBEZXByZWNhdGVkXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2Nyb2xsVG9FbmQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgc2Nyb2xsUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD4gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3ZlcnNjcm9sbCBwcm9wZXJ0aWVzIGFyZSB1c2VkIHRvIGFsbG93IHRoZSBncmlkIHRvIHNjcm9sbCBwYXN0IHRoZSBsb2dpY2FsIGVuZCBvZiB0aGUgY29udGVudCBieSBhIGZpeGVkXG4gICAgICogbnVtYmVyIG9mIHBpeGVscy4gVGhpcyBpcyB1c2VmdWwgcGFydGljdWxhcmx5IG9uIHRoZSBYIGF4aXMgaWYgeW91IGFsbG93IGZvciByZXNpemluZyBjb2x1bW5zIGFzIGl0IGNhbiBtYWtlXG4gICAgICogcmVzaXppbmcgdGhlIGZpbmFsIGNvbHVtbiBzaWduaWZpY2FudGx5IGVhc2llci5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxYOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIHtAaW5oZXJpdERvYyBvdmVyc2Nyb2xsWH1cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBvdmVyc2Nyb2xsWTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGluaXRpYWwgc2l6ZSBmb3IgdGhlIGdyaWQgd2hpY2ggY2FuIHByZXZlbnQgYSBmbGlja2VyIG9uIGxvYWQgaWYgdGhlIGluaXRpYWwgc2l6ZSBpcyBrbm93biBwcmlvciB0b1xuICAgICAqIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplOiByZWFkb25seSBbd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJdIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHByZXZlbnQgYW55IGRpYWdvbmFsIHNjcm9sbGluZy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuc3RpY2t5YCBpcyBzZXQgdG8gdHJ1ZSB0aGUgcmlnaHQgZWxlbWVudCB3aWxsIGJlIHZpc2libGUgYXQgYWxsIHRpbWVzLCBvdGhlcndpc2UgdGhlIHVzZXJcbiAgICAgKiB3aWxsIG5lZWQgdG8gc2Nyb2xsIHRvIHRoZSBlbmQgdG8gcmV2ZWFsIGl0LlxuICAgICAqXG4gICAgICogSWYgYHJpZ2h0RWxlbWVudFByb3BzLmZpbGxgIGlzIHNldCwgdGhlIHJpZ2h0IGVsZW1lbnRzIGNvbnRhaW5lciB3aWxsIGZpbGwgdG8gY29uc3VtZSBhbGwgcmVtYWluaW5nIHNwYWNlIChpZlxuICAgICAqIGFueSkgYXQgdGhlIGVuZCBvZiB0aGUgZ3JpZC4gVGhpcyBkb2VzIG5vdCBwbGF5IG5pY2Ugd2l0aCBncm93aW5nIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wczpcbiAgICAgICAgfCB7XG4gICAgICAgICAgICAgIHJlYWRvbmx5IHN0aWNreT86IGJvb2xlYW47XG4gICAgICAgICAgICAgIHJlYWRvbmx5IGZpbGw/OiBib29sZWFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIHJpZ2h0IGVsZW1lbnQgaXMgYSBET00gbm9kZSB3aGljaCBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcmVnaW9uLiBUaGlzIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgcmlnaHQgaGFuZGxlIHBhbmVsLCBtYWtlIGEgYmlnIGFkZCBidXR0b24sIG9yIGRpc3BsYXkgbWVzc2FnZXMuXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50OiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcy9kaXNhYmxlcyB0aGUgaW50ZXJhY3RpdmUgbWluaW1hcC5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGZhbHNlXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2hvd01pbmltYXA6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgY2xpZW50U2l6ZTogcmVhZG9ubHkgW251bWJlciwgbnVtYmVyXTtcbn1cblxuY29uc3QgTWluaW1hcFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDQ0cHg7XG4gICAgYm90dG9tOiA0NHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodmFyKC0tZ2RnLWJnLWNlbGwpLCB2YXIoLS1nZGctYmctY2VsbC1tZWRpdW0pKTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgei1pbmRleDogMTtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvciksIDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xuXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgIC5oZWFkZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIH1cblxuICAgIC5sb2NhdGlvbk1hcmtlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgfVxuYDtcblxuY29uc3QgR3JpZFNjcm9sbGVyOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxTY3JvbGxpbmdEYXRhR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgcm93cyxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICBoZWFkZXJIZWlnaHQsXG4gICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0LFxuICAgICAgICBlbmFibGVHcm91cHMsXG4gICAgICAgIGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgIGV4cGVyaW1lbnRhbCxcbiAgICAgICAgY2xpZW50U2l6ZSxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkLFxuICAgICAgICBzY3JvbGxUb0VuZCxcbiAgICAgICAgc2Nyb2xsUmVmLFxuICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcsXG4gICAgICAgIHJpZ2h0RWxlbWVudCxcbiAgICAgICAgcmlnaHRFbGVtZW50UHJvcHMsXG4gICAgICAgIG92ZXJzY3JvbGxYLFxuICAgICAgICBvdmVyc2Nyb2xsWSxcbiAgICAgICAgc2hvd01pbmltYXAgPSBmYWxzZSxcbiAgICAgICAgaW5pdGlhbFNpemUsXG4gICAgICAgIHNtb290aFNjcm9sbFggPSBmYWxzZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWSA9IGZhbHNlLFxuICAgICAgICBpc0RyYWdnYWJsZSxcbiAgICB9ID0gcDtcbiAgICBjb25zdCB7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9ID0gZXhwZXJpbWVudGFsID8/IHt9O1xuXG4gICAgY29uc3QgW2NsaWVudFdpZHRoLCBjbGllbnRIZWlnaHRdID0gY2xpZW50U2l6ZTtcbiAgICBjb25zdCBsYXN0ID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WCA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFkgPSBSZWFjdC51c2VSZWY8bnVtYmVyIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RTaXplID0gUmVhY3QudXNlUmVmPHJlYWRvbmx5IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB3aWR0aCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgciA9IE1hdGgubWF4KDAsIG92ZXJzY3JvbGxYID8/IDApO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgciArPSBjLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH0sIFtjb2x1bW5zLCBvdmVyc2Nyb2xsWF0pO1xuXG4gICAgbGV0IGhlaWdodCA9IGVuYWJsZUdyb3VwcyA/IGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0IDogaGVhZGVySGVpZ2h0O1xuICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGhlaWdodCArPSByb3dzICogcm93SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgICAgICBoZWlnaHQgKz0gcm93SGVpZ2h0KHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyc2Nyb2xsWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCArPSBvdmVyc2Nyb2xsWTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0QXJncyA9IFJlYWN0LnVzZVJlZjxSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0+KCk7XG5cbiAgICBjb25zdCBwcm9jZXNzQXJncyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGxhc3RBcmdzLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcmdzID0geyAuLi5sYXN0QXJncy5jdXJyZW50IH07XG5cbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgdHggPSBhcmdzLnggPCAwID8gLWFyZ3MueCA6IDA7XG4gICAgICAgIGxldCBjZWxsUmlnaHQgPSAwO1xuICAgICAgICBsZXQgY2VsbFggPSAwO1xuXG4gICAgICAgIGFyZ3MueCA9IGFyZ3MueCA8IDAgPyAwIDogYXJncy54O1xuXG4gICAgICAgIGxldCBzdGlja3lDb2xXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJlZXplQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBzdGlja3lDb2xXaWR0aCArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN4ID0geCAtIHN0aWNreUNvbFdpZHRoO1xuICAgICAgICAgICAgaWYgKGFyZ3MueCA+PSBjeCArIGMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbFgrKztcbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ID4gY3gpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHggKz0gY3ggLSBhcmdzLng7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueCArIGFyZ3Mud2lkdGggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHkgPSAwO1xuICAgICAgICBsZXQgY2VsbFkgPSAwO1xuICAgICAgICBsZXQgY2VsbEJvdHRvbSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgIGNlbGxZID0gTWF0aC5mbG9vcihhcmdzLnkgLyByb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHR5ID0gY2VsbFkgKiByb3dIZWlnaHQgLSBhcmdzLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxZID0gTWF0aC5jZWlsKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsQm90dG9tID0gTWF0aC5jZWlsKGFyZ3MuaGVpZ2h0IC8gcm93SGVpZ2h0KSArIGNlbGxZO1xuICAgICAgICAgICAgaWYgKHR5IDwgMCkgY2VsbEJvdHRvbSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByaCA9IHJvd0hlaWdodChyb3cpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5ID0geSArIChzbW9vdGhTY3JvbGxZID8gMCA6IHJoIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MueSA+PSB5ICsgcmgpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFkrKztcbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy55ID4gY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ICs9IGN5IC0gYXJncy55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgKyBhcmdzLmhlaWdodCA+IHJoIC8gMiArIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY3Q6IFJlY3RhbmdsZSA9IHtcbiAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICB3aWR0aDogY2VsbFJpZ2h0IC0gY2VsbFgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbGRSZWN0ID0gbGFzdC5jdXJyZW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9sZFJlY3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgb2xkUmVjdC55ICE9PSByZWN0LnkgfHxcbiAgICAgICAgICAgIG9sZFJlY3QueCAhPT0gcmVjdC54IHx8XG4gICAgICAgICAgICBvbGRSZWN0LmhlaWdodCAhPT0gcmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgIG9sZFJlY3Qud2lkdGggIT09IHJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgIT09IHR4IHx8XG4gICAgICAgICAgICBsYXN0WS5jdXJyZW50ICE9PSB0eSB8fFxuICAgICAgICAgICAgYXJncy53aWR0aCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzBdIHx8XG4gICAgICAgICAgICBhcmdzLmhlaWdodCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD8uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNlbGxZLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2VsbFJpZ2h0IC0gY2VsbFgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJncy53aWR0aCxcbiAgICAgICAgICAgICAgICBhcmdzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBhcmdzLnBhZGRpbmdSaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHR4LFxuICAgICAgICAgICAgICAgIHR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGFzdC5jdXJyZW50ID0gcmVjdDtcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgPSB0eDtcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgPSB0eTtcbiAgICAgICAgICAgIGxhc3RTaXplLmN1cnJlbnQgPSBbYXJncy53aWR0aCwgYXJncy5oZWlnaHRdO1xuICAgICAgICB9XG4gICAgfSwgW2NvbHVtbnMsIHJvd0hlaWdodCwgcm93cywgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCwgZnJlZXplQ29sdW1ucywgc21vb3RoU2Nyb2xsWCwgc21vb3RoU2Nyb2xsWV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGxVcGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKGFyZ3M6IFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfSkgPT4ge1xuICAgICAgICAgICAgbGFzdEFyZ3MuY3VycmVudCA9IGFyZ3M7XG4gICAgICAgICAgICBwcm9jZXNzQXJncygpO1xuICAgICAgICB9LFxuICAgICAgICBbcHJvY2Vzc0FyZ3NdXG4gICAgKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgfSwgW3Byb2Nlc3NBcmdzXSk7XG5cbiAgICBjb25zdCBzY3JvbGxlciA9IHNjcm9sbFJlZj8uY3VycmVudCA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXNwZWN0ID0gY2xhbXAod2lkdGggLyBoZWlnaHQsIDIgLyAzLCAxLjUpO1xuICAgIGNvbnN0IG1heFNpemUgPSAyMDA7XG4gICAgY29uc3QgdyA9IGFzcGVjdCA+IDEgPyBtYXhTaXplIDogTWF0aC5jZWlsKG1heFNpemUgKiBhc3BlY3QpO1xuICAgIGNvbnN0IGggPSBhc3BlY3QgPiAxID8gTWF0aC5jZWlsKG1heFNpemUgLyBhc3BlY3QpIDogbWF4U2l6ZTtcbiAgICBjb25zdCBoUmF0aW8gPSB3IC8gd2lkdGg7XG4gICAgY29uc3QgdlJhdGlvID0gaCAvIGhlaWdodDtcbiAgICBjb25zdCB2V2lkdGggPSBNYXRoLm1pbihjbGllbnRXaWR0aCAqIE1hdGgubWF4KGhSYXRpbywgMC4wMSksIHcpO1xuICAgIGNvbnN0IHZIZWlnaHQgPSBNYXRoLm1pbihjbGllbnRIZWlnaHQgKiBNYXRoLm1heCh2UmF0aW8sIDAuMDEpLCBoKTtcbiAgICBjb25zdCBsZWZ0ID0gKChzY3JvbGxlcj8uc2Nyb2xsTGVmdCA/PyAwKSAvICh3aWR0aCAtIGNsaWVudFdpZHRoKSkgKiAodyAtIHZXaWR0aCk7XG4gICAgY29uc3QgdG9wID0gKChzY3JvbGxlcj8uc2Nyb2xsVG9wID8/IDApIC8gKGhlaWdodCAtIGNsaWVudEhlaWdodCkpICogKGggLSB2SGVpZ2h0KTtcblxuICAgIGNvbnN0IG1pbmltYXA6IFJlYWN0LlJlYWN0Tm9kZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3dNaW5pbWFwIHx8IHZXaWR0aCA9PT0gMCB8fCB2SGVpZ2h0ID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZU1vdXNlID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gYm91bmRzLnggLSB2V2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIGJvdW5kcy55IC0gdkhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbExlZnQgPSAod2lkdGggLSBzY3JvbGxlci5jbGllbnRXaWR0aCkgKiAoeCAvICh3IC0gdldpZHRoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxUb3AgPSAoaGVpZ2h0IC0gc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSAqICh5IC8gKGggLSB2SGVpZ2h0KSk7XG5cbiAgICAgICAgICAgIHNjcm9sbGVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBuZXdTY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogbmV3U2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBlLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcImF1dG9cIiA6IFwic21vb3RoXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1pbmltYXBTdHlsZVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiB3LCBoZWlnaHQ6IGggfX1cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD1cIm1pbmltYXAtY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgIT09IDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2UoZSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVNb3VzZX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIiAvPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibG9jYXRpb25NYXJrZXJcIlxuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17ZSA9PiBlLnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdkhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogTWF0aC5taW4odldpZHRoLCB2SGVpZ2h0ICogMC4yLCA5KSxcbiAgICAgICAgICAgICAgICAgICAgfX0+PC9kaXY+XG4gICAgICAgICAgICA8L01pbmltYXBTdHlsZT5cbiAgICAgICAgKTtcbiAgICB9LCBbaCwgaGVpZ2h0LCBsZWZ0LCBzY3JvbGxlciwgc2hvd01pbmltYXAsIHRvcCwgdkhlaWdodCwgdldpZHRoLCB3LCB3aWR0aF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEluZmluaXRlU2Nyb2xsZXJcbiAgICAgICAgICAgIHNjcm9sbFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgbWluaW1hcD17bWluaW1hcH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXtwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmd9XG4gICAgICAgICAgICBkcmFnZ2FibGU9e2lzRHJhZ2dhYmxlID09PSB0cnVlIHx8IHR5cGVvZiBpc0RyYWdnYWJsZSA9PT0gXCJzdHJpbmdcIn1cbiAgICAgICAgICAgIHNjcm9sbFdpZHRoPXt3aWR0aCArIChwYWRkaW5nUmlnaHQgPz8gMCl9XG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQ9e2hlaWdodCArIChwYWRkaW5nQm90dG9tID8/IDApfVxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0PXtjbGllbnRIZWlnaHR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b209e3BhZGRpbmdCb3R0b219XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ9e3BhZGRpbmdSaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudFByb3BzPXtyaWdodEVsZW1lbnRQcm9wc31cbiAgICAgICAgICAgIHVwZGF0ZT17b25TY3JvbGxVcGRhdGV9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17aW5pdGlhbFNpemV9XG4gICAgICAgICAgICBzY3JvbGxUb0VuZD17c2Nyb2xsVG9FbmR9PlxuICAgICAgICAgICAgPERhdGFHcmlkRG5kXG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXRSZWY9e3Njcm9sbFJlZn1cbiAgICAgICAgICAgICAgICB3aWR0aD17Y2xpZW50V2lkdGh9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtjbGllbnRIZWlnaHR9XG4gICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17cC5hY2Nlc3NpYmlsaXR5SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGNhbnZhc1JlZj17cC5jYW52YXNSZWZ9XG4gICAgICAgICAgICAgICAgY2VsbFhPZmZzZXQ9e3AuY2VsbFhPZmZzZXR9XG4gICAgICAgICAgICAgICAgY2VsbFlPZmZzZXQ9e3AuY2VsbFlPZmZzZXR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cC5jb2x1bW5zfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkUm93cz17cC5kaXNhYmxlZFJvd3N9XG4gICAgICAgICAgICAgICAgZW5hYmxlR3JvdXBzPXtwLmVuYWJsZUdyb3Vwc31cbiAgICAgICAgICAgICAgICBmaWxsSGFuZGxlPXtwLmZpbGxIYW5kbGV9XG4gICAgICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXtwLmZpcnN0Q29sQWNjZXNzaWJsZX1cbiAgICAgICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3AuZml4ZWRTaGFkb3dYfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17cC5maXhlZFNoYWRvd1l9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17cC5mcmVlemVDb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtwLmdldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17cC5nZXRDZWxsUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXtwLmdldEdyb3VwRGV0YWlsc31cbiAgICAgICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXtwLmdldFJvd1RoZW1lT3ZlcnJpZGV9XG4gICAgICAgICAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQ9e3AuZ3JvdXBIZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXtwLmhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXtwLmhpZ2hsaWdodFJlZ2lvbnN9XG4gICAgICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3AuaW1hZ2VXaW5kb3dMb2FkZXJ9XG4gICAgICAgICAgICAgICAgaXNGaWxsaW5nPXtwLmlzRmlsbGluZ31cbiAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ9e3AuaXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIGxvY2tDb2x1bW5zPXtwLmxvY2tDb2x1bW5zfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXtwLm1heENvbHVtbldpZHRofVxuICAgICAgICAgICAgICAgIG1pbkNvbHVtbldpZHRoPXtwLm1pbkNvbHVtbldpZHRofVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXtwLm9uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtwLm9uTW91c2VNb3ZlfVxuICAgICAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3AucHJlbGlnaHRDZWxsc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIHJvd3M9e3Aucm93c31cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb249e3Auc2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHRoZW1lPXtwLnRoZW1lfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17cC50cmFpbGluZ1Jvd1R5cGV9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWD17cC50cmFuc2xhdGVYfVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3AudHJhbnNsYXRlWX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17cC52ZXJ0aWNhbEJvcmRlcn1cbiAgICAgICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17cC5kcmF3Q3VzdG9tQ2VsbH1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtwLmRyYXdGb2N1c1Jpbmd9XG4gICAgICAgICAgICAgICAgZHJhd0hlYWRlcj17cC5kcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbD17cC5leHBlcmltZW50YWx9XG4gICAgICAgICAgICAgICAgZ3JpZFJlZj17cC5ncmlkUmVmfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtwLmhlYWRlckljb25zfVxuICAgICAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXtwLmlzRHJhZ2dhYmxlfVxuICAgICAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17cC5vbkNhbnZhc0JsdXJ9XG4gICAgICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXtwLm9uQ2FudmFzRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXtwLm9uQ2VsbEZvY3VzZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5Nb3ZlZD17cC5vbkNvbHVtbk1vdmVkfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtwLm9uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplRW5kPXtwLm9uQ29sdW1uUmVzaXplRW5kfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplU3RhcnQ9e3Aub25Db2x1bW5SZXNpemVTdGFydH1cbiAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51PXtwLm9uQ29udGV4dE1lbnV9XG4gICAgICAgICAgICAgICAgb25EcmFnRW5kPXtwLm9uRHJhZ0VuZH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17cC5vbkRyYWdMZWF2ZX1cbiAgICAgICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17cC5vbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17cC5vbkRyYWdTdGFydH1cbiAgICAgICAgICAgICAgICBvbkRyb3A9e3Aub25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e3Aub25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBvbktleURvd249e3Aub25LZXlEb3dufVxuICAgICAgICAgICAgICAgIG9uS2V5VXA9e3Aub25LZXlVcH1cbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17cC5vbk1vdXNlRG93bn1cbiAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e3Aub25Nb3VzZVVwfVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Aub25Sb3dNb3ZlZH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXtwLnNtb290aFNjcm9sbFh9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17cC5zbW9vdGhTY3JvbGxZfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9JbmZpbml0ZVNjcm9sbGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHcmlkU2Nyb2xsZXI7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBK0VBLE1BQU0sZUFBZSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4QjVCLE1BQU0sZUFBZ0UsT0FBSztBQUN2RSxRQUFNO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxjQUFjO0FBQUEsSUFDZDtBQUFBLElBQ0EsZ0JBQWdCO0FBQUEsSUFDaEIsZ0JBQWdCO0FBQUEsSUFDaEI7QUFBQSxNQUNBO0FBQ0osUUFBTSxFQUFFLGNBQWMsa0JBQWtCLGdCQUFnQjtBQUV4RCxRQUFNLENBQUMsYUFBYSxnQkFBZ0I7QUFDcEMsUUFBTSxPQUFPLE1BQU07QUFDbkIsUUFBTSxRQUFRLE1BQU07QUFDcEIsUUFBTSxRQUFRLE1BQU07QUFDcEIsUUFBTSxXQUFXLE1BQU07QUFFdkIsUUFBTSxRQUFRLE1BQU0sUUFBUSxNQUFNO0FBQzlCLFFBQUksSUFBSSxLQUFLLElBQUksR0FBRyxlQUFlO0FBQ25DLGVBQVcsS0FBSyxTQUFTO0FBQ3JCLFdBQUssRUFBRTtBQUFBO0FBRVgsV0FBTztBQUFBLEtBQ1IsQ0FBQyxTQUFTO0FBRWIsTUFBSSxTQUFTLGVBQWUsZUFBZSxvQkFBb0I7QUFDL0QsTUFBSSxPQUFPLGNBQWMsVUFBVTtBQUMvQixjQUFVLE9BQU87QUFBQSxTQUNkO0FBQ0gsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLEtBQUs7QUFDM0IsZ0JBQVUsVUFBVTtBQUFBO0FBQUE7QUFHNUIsTUFBSSxnQkFBZ0IsUUFBVztBQUMzQixjQUFVO0FBQUE7QUFHZCxRQUFNLFdBQVcsTUFBTTtBQUV2QixRQUFNLGNBQWMsTUFBTSxZQUFZLE1BQU07QUFDeEMsUUFBSSxTQUFTLFlBQVk7QUFBVztBQUNwQyxVQUFNLE9BQU8sS0FBSyxTQUFTO0FBRTNCLFFBQUksSUFBSTtBQUNSLFFBQUksS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSTtBQUNoQyxRQUFJLFlBQVk7QUFDaEIsUUFBSSxRQUFRO0FBRVosU0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSztBQUUvQixRQUFJLGlCQUFpQjtBQUNyQixhQUFTLElBQUksR0FBRyxJQUFJLGVBQWUsS0FBSztBQUNwQyx3QkFBa0IsUUFBUSxHQUFHO0FBQUE7QUFHakMsZUFBVyxLQUFLLFNBQVM7QUFDckIsWUFBTSxLQUFLLElBQUk7QUFDZixVQUFJLEtBQUssS0FBSyxLQUFLLEVBQUUsT0FBTztBQUN4QixhQUFLLEVBQUU7QUFDUDtBQUNBO0FBQUEsaUJBQ08sS0FBSyxJQUFJLElBQUk7QUFDcEIsYUFBSyxFQUFFO0FBQ1AsWUFBSSxlQUFlO0FBQ2YsZ0JBQU0sS0FBSyxLQUFLO0FBQUEsZUFDYjtBQUNIO0FBQUE7QUFFSjtBQUFBLGlCQUNPLEtBQUssSUFBSSxLQUFLLFFBQVEsSUFBSTtBQUNqQyxhQUFLLEVBQUU7QUFDUDtBQUFBLGFBQ0c7QUFDSDtBQUFBO0FBQUE7QUFJUixRQUFJLEtBQUs7QUFDVCxRQUFJLFFBQVE7QUFDWixRQUFJLGFBQWE7QUFDakIsUUFBSSxPQUFPLGNBQWMsVUFBVTtBQUMvQixVQUFJLGVBQWU7QUFDZixnQkFBUSxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQzVCLGFBQUssUUFBUSxZQUFZLEtBQUs7QUFBQSxhQUMzQjtBQUNILGdCQUFRLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQTtBQUUvQixtQkFBYSxLQUFLLEtBQUssS0FBSyxTQUFTLGFBQWE7QUFDbEQsVUFBSSxLQUFLO0FBQUc7QUFBQSxXQUNUO0FBQ0gsVUFBSSxJQUFJO0FBQ1IsZUFBUyxNQUFNLEdBQUcsTUFBTSxNQUFNLE9BQU87QUFDakMsY0FBTSxLQUFLLFVBQVU7QUFDckIsY0FBTSxLQUFLLElBQUssaUJBQWdCLElBQUksS0FBSztBQUN6QyxZQUFJLEtBQUssS0FBSyxJQUFJLElBQUk7QUFDbEIsZUFBSztBQUNMO0FBQ0E7QUFBQSxtQkFDTyxLQUFLLElBQUksSUFBSTtBQUNwQixlQUFLO0FBQ0wsY0FBSSxlQUFlO0FBQ2Ysa0JBQU0sS0FBSyxLQUFLO0FBQUEsaUJBQ2I7QUFDSDtBQUFBO0FBRUo7QUFBQSxtQkFDTyxLQUFLLElBQUksS0FBSyxTQUFTLEtBQUssSUFBSSxHQUFHO0FBQzFDLGVBQUs7QUFDTDtBQUFBLGVBQ0c7QUFDSDtBQUFBO0FBQUE7QUFBQTtBQUtaLFVBQU0sT0FBa0I7QUFBQSxNQUNwQixHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxPQUFPLFlBQVk7QUFBQSxNQUNuQixRQUFRLGFBQWE7QUFBQTtBQUd6QixVQUFNLFVBQVUsS0FBSztBQUVyQixRQUNJLFlBQVksVUFDWixRQUFRLE1BQU0sS0FBSyxLQUNuQixRQUFRLE1BQU0sS0FBSyxLQUNuQixRQUFRLFdBQVcsS0FBSyxVQUN4QixRQUFRLFVBQVUsS0FBSyxTQUN2QixNQUFNLFlBQVksTUFDbEIsTUFBTSxZQUFZLE1BQ2xCLEtBQUssVUFBVSxTQUFTLFVBQVUsTUFDbEMsS0FBSyxXQUFXLFNBQVMsVUFBVSxJQUNyQztBQUNFLCtCQUNJO0FBQUEsUUFDSSxHQUFHO0FBQUEsUUFDSCxHQUFHO0FBQUEsUUFDSCxPQUFPLFlBQVk7QUFBQSxRQUNuQixRQUFRLGFBQWE7QUFBQSxTQUV6QixLQUFLLE9BQ0wsS0FBSyxRQUNMLEtBQUssZ0JBQWdCLEdBQ3JCLElBQ0E7QUFFSixXQUFLLFVBQVU7QUFDZixZQUFNLFVBQVU7QUFDaEIsWUFBTSxVQUFVO0FBQ2hCLGVBQVMsVUFBVSxDQUFDLEtBQUssT0FBTyxLQUFLO0FBQUE7QUFBQSxLQUUxQyxDQUFDLFNBQVMsV0FBVyxNQUFNLHdCQUF3QixlQUFlLGVBQWU7QUFFcEYsUUFBTSxpQkFBaUIsTUFBTSxZQUN6QixDQUFDLFNBQStDO0FBQzVDLGFBQVMsVUFBVTtBQUNuQjtBQUFBLEtBRUosQ0FBQztBQUdMLFFBQU0sVUFBVSxNQUFNO0FBQ2xCO0FBQUEsS0FDRCxDQUFDO0FBRUosUUFBTSxXQUFXLFdBQVcsV0FBVztBQUN2QyxRQUFNLFNBQVMsTUFBTSxRQUFRLFFBQVEsSUFBSSxHQUFHO0FBQzVDLFFBQU0sVUFBVTtBQUNoQixRQUFNLElBQUksU0FBUyxJQUFJLFVBQVUsS0FBSyxLQUFLLFVBQVU7QUFDckQsUUFBTSxJQUFJLFNBQVMsSUFBSSxLQUFLLEtBQUssVUFBVSxVQUFVO0FBQ3JELFFBQU0sU0FBUyxJQUFJO0FBQ25CLFFBQU0sU0FBUyxJQUFJO0FBQ25CLFFBQU0sU0FBUyxLQUFLLElBQUksY0FBYyxLQUFLLElBQUksUUFBUSxPQUFPO0FBQzlELFFBQU0sVUFBVSxLQUFLLElBQUksZUFBZSxLQUFLLElBQUksUUFBUSxPQUFPO0FBQ2hFLFFBQU0sT0FBUyxXQUFVLGNBQWMsS0FBTSxTQUFRLGVBQWlCLEtBQUk7QUFDMUUsUUFBTSxNQUFRLFdBQVUsYUFBYSxLQUFNLFVBQVMsZ0JBQWtCLEtBQUk7QUFFMUUsUUFBTSxVQUEyQixNQUFNLFFBQVEsTUFBTTtBQUNqRCxRQUFJLENBQUMsZUFBZSxXQUFXLEtBQUssWUFBWTtBQUFHLGFBQU87QUFFMUQsVUFBTSxjQUFjLENBQUMsTUFBd0I7QUFDekMsVUFBSSxhQUFhO0FBQVc7QUFDNUIsWUFBTSxTQUFTLEVBQUUsY0FBYztBQUMvQixZQUFNLElBQUksRUFBRSxVQUFVLE9BQU8sSUFBSSxTQUFTO0FBQzFDLFlBQU0sSUFBSSxFQUFFLFVBQVUsT0FBTyxJQUFJLFVBQVU7QUFFM0MsWUFBTSxnQkFBaUIsU0FBUSxTQUFTLGVBQWdCLEtBQUssS0FBSTtBQUNqRSxZQUFNLGVBQWdCLFVBQVMsU0FBUyxnQkFBaUIsS0FBSyxLQUFJO0FBRWxFLGVBQVMsU0FBUztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sS0FBSztBQUFBLFFBQ0wsVUFBVSxFQUFFLFNBQVMsY0FBYyxTQUFTO0FBQUE7QUFBQTtBQUlwRCxXQUNJLG9DQUFDLGNBQUQ7QUFBQSxNQUNJLE9BQU8sRUFBRSxPQUFPLEdBQUcsUUFBUTtBQUFBLE1BQzNCLGVBQVk7QUFBQSxNQUNaLGFBQWEsT0FBSztBQUNkLFlBQUksRUFBRSxZQUFZO0FBQUc7QUFDckIsb0JBQVk7QUFBQTtBQUFBLE1BRWhCLFNBQVM7QUFBQSxPQUNULG9DQUFDLE9BQUQ7QUFBQSxNQUFLLFdBQVU7QUFBQSxRQUNmLG9DQUFDLE9BQUQ7QUFBQSxNQUNJLFdBQVU7QUFBQSxNQUNWLGFBQWEsT0FBSyxFQUFFO0FBQUEsTUFDcEIsT0FBTztBQUFBLFFBQ0g7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPO0FBQUEsUUFDUCxRQUFRO0FBQUEsUUFDUixjQUFjLEtBQUssSUFBSSxRQUFRLFVBQVUsS0FBSztBQUFBO0FBQUE7QUFBQSxLQUkvRCxDQUFDLEdBQUcsUUFBUSxNQUFNLFVBQVUsYUFBYSxLQUFLLFNBQVMsUUFBUSxHQUFHO0FBRXJFLFNBQ0ksb0NBQUMsa0JBQUQ7QUFBQSxJQUNJO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxXQUFXLGdCQUFnQixRQUFRLE9BQU8sZ0JBQWdCO0FBQUEsSUFDMUQsYUFBYSxRQUFTLGlCQUFnQjtBQUFBLElBQ3RDLGNBQWMsU0FBVSxrQkFBaUI7QUFBQSxJQUN6QztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSO0FBQUEsSUFDQTtBQUFBLEtBQ0Esb0NBQUMsYUFBRDtBQUFBLElBQ0ksZ0JBQWdCO0FBQUEsSUFDaEIsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IscUJBQXFCLEVBQUU7QUFBQSxJQUN2QixXQUFXLEVBQUU7QUFBQSxJQUNiLGFBQWEsRUFBRTtBQUFBLElBQ2YsYUFBYSxFQUFFO0FBQUEsSUFDZixTQUFTLEVBQUU7QUFBQSxJQUNYLGNBQWMsRUFBRTtBQUFBLElBQ2hCLGNBQWMsRUFBRTtBQUFBLElBQ2hCLFlBQVksRUFBRTtBQUFBLElBQ2Qsb0JBQW9CLEVBQUU7QUFBQSxJQUN0QixjQUFjLEVBQUU7QUFBQSxJQUNoQixjQUFjLEVBQUU7QUFBQSxJQUNoQixlQUFlLEVBQUU7QUFBQSxJQUNqQixnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGlCQUFpQixFQUFFO0FBQUEsSUFDbkIsaUJBQWlCLEVBQUU7QUFBQSxJQUNuQixxQkFBcUIsRUFBRTtBQUFBLElBQ3ZCLG1CQUFtQixFQUFFO0FBQUEsSUFDckIsY0FBYyxFQUFFO0FBQUEsSUFDaEIsa0JBQWtCLEVBQUU7QUFBQSxJQUNwQixtQkFBbUIsRUFBRTtBQUFBLElBQ3JCLFdBQVcsRUFBRTtBQUFBLElBQ2IsV0FBVyxFQUFFO0FBQUEsSUFDYixhQUFhLEVBQUU7QUFBQSxJQUNmLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsZ0JBQWdCLEVBQUU7QUFBQSxJQUNsQixtQkFBbUIsRUFBRTtBQUFBLElBQ3JCLGFBQWEsRUFBRTtBQUFBLElBQ2YsZUFBZSxFQUFFO0FBQUEsSUFDakIsV0FBVyxFQUFFO0FBQUEsSUFDYixNQUFNLEVBQUU7QUFBQSxJQUNSLFdBQVcsRUFBRTtBQUFBLElBQ2IsT0FBTyxFQUFFO0FBQUEsSUFDVCxpQkFBaUIsRUFBRTtBQUFBLElBQ25CLFlBQVksRUFBRTtBQUFBLElBQ2QsWUFBWSxFQUFFO0FBQUEsSUFDZCxnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsZUFBZSxFQUFFO0FBQUEsSUFDakIsWUFBWSxFQUFFO0FBQUEsSUFDZCxjQUFjLEVBQUU7QUFBQSxJQUNoQixTQUFTLEVBQUU7QUFBQSxJQUNYLGFBQWEsRUFBRTtBQUFBLElBQ2YsYUFBYSxFQUFFO0FBQUEsSUFDZixjQUFjLEVBQUU7QUFBQSxJQUNoQixpQkFBaUIsRUFBRTtBQUFBLElBQ25CLGVBQWUsRUFBRTtBQUFBLElBQ2pCLGVBQWUsRUFBRTtBQUFBLElBQ2pCLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsbUJBQW1CLEVBQUU7QUFBQSxJQUNyQixxQkFBcUIsRUFBRTtBQUFBLElBQ3ZCLGVBQWUsRUFBRTtBQUFBLElBQ2pCLFdBQVcsRUFBRTtBQUFBLElBQ2IsYUFBYSxFQUFFO0FBQUEsSUFDZixnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGFBQWEsRUFBRTtBQUFBLElBQ2YsUUFBUSxFQUFFO0FBQUEsSUFDVixlQUFlLEVBQUU7QUFBQSxJQUNqQixXQUFXLEVBQUU7QUFBQSxJQUNiLFNBQVMsRUFBRTtBQUFBLElBQ1gsYUFBYSxFQUFFO0FBQUEsSUFDZixXQUFXLEVBQUU7QUFBQSxJQUNiLFlBQVksRUFBRTtBQUFBLElBQ2QsZUFBZSxFQUFFO0FBQUEsSUFDakIsZUFBZSxFQUFFO0FBQUE7QUFBQTtBQU1qQyxlQUFlOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\nconst ScrollRegionStyle = styled.div`\n    .dvn-scroller {\n        overflow: ${(p) => p.isSafari ? \"scroll\" : \"auto\"};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\nfunction eatEvent(e) {\n  e.stopPropagation();\n}\nfunction useTouchUpDelayed(delay) {\n  const [hasTouches, setHasTouches] = React.useState(false);\n  const cbTimer = React.useRef(0);\n  useEventListener(\"touchstart\", React.useCallback(() => {\n    window.clearTimeout(cbTimer.current);\n    setHasTouches(true);\n  }, []), window, true, false);\n  useEventListener(\"touchend\", React.useCallback((e) => {\n    if (e.touches.length === 0) {\n      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n    }\n  }, [delay]), window, true, false);\n  return hasTouches;\n}\nexport const InfiniteScroller = (p) => {\n  const {\n    children,\n    clientHeight,\n    scrollHeight,\n    scrollWidth,\n    update,\n    draggable,\n    className,\n    preventDiagonalScrolling = false,\n    paddingBottom = 0,\n    paddingRight = 0,\n    rightElement,\n    rightElementProps,\n    scrollRef,\n    scrollToEnd,\n    initialSize,\n    minimap\n  } = p;\n  const padders = [];\n  const rightElementSticky = rightElementProps?.sticky ?? false;\n  const rightElementFill = rightElementProps?.fill ?? false;\n  const offsetY = React.useRef(0);\n  const lastScrollY = React.useRef(0);\n  const scroller = React.useRef(null);\n  const dpr = window.devicePixelRatio;\n  React.useEffect(() => {\n    const el = scroller.current;\n    if (el === null || scrollToEnd !== true)\n      return;\n    el.scrollLeft = el.scrollWidth - el.clientWidth;\n  }, [scrollToEnd]);\n  const lastScrollPosition = React.useRef({\n    scrollLeft: 0,\n    scrollTop: 0,\n    lockDirection: void 0\n  });\n  const rightWrapRef = React.useRef(null);\n  const hasTouches = useTouchUpDelayed(200);\n  const [isIdle, setIsIdle] = React.useState(true);\n  const idleTimer = React.useRef(0);\n  React.useEffect(() => {\n    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === void 0)\n      return;\n    const el = scroller.current;\n    if (el === null)\n      return;\n    const [lx, ly] = lastScrollPosition.current.lockDirection;\n    if (lx !== void 0) {\n      el.scrollLeft = lx;\n    } else if (ly !== void 0) {\n      el.scrollTop = ly;\n    }\n    lastScrollPosition.current.lockDirection = void 0;\n  }, [hasTouches, isIdle]);\n  const onScroll = React.useCallback(() => {\n    const el = scroller.current;\n    if (el === null)\n      return;\n    let scrollTop = el.scrollTop;\n    let scrollLeft = el.scrollLeft;\n    const lastScrollTop = lastScrollPosition.current.scrollTop;\n    const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n    const dx = scrollLeft - lastScrollLeft;\n    const dy = scrollTop - lastScrollTop;\n    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === void 0) {\n      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, void 0] : [void 0, lastScrollTop];\n    }\n    const lock = lastScrollPosition.current.lockDirection;\n    scrollLeft = lock?.[0] ?? scrollLeft;\n    scrollTop = lock?.[1] ?? scrollTop;\n    lastScrollPosition.current.scrollLeft = scrollLeft;\n    lastScrollPosition.current.scrollTop = scrollTop;\n    const newY = scrollTop;\n    const delta = lastScrollY.current - newY;\n    const scrollableHeight = el.scrollHeight - el.clientHeight;\n    lastScrollY.current = newY;\n    if (scrollableHeight > 0 && (Math.abs(delta) > 2e3 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {\n      const prog = newY / scrollableHeight;\n      const recomputed = (scrollHeight - el.clientHeight) * prog;\n      offsetY.current = recomputed - newY;\n    }\n    if (lock !== void 0) {\n      window.clearTimeout(idleTimer.current);\n      setIsIdle(false);\n      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n    }\n    update({\n      x: scrollLeft,\n      y: newY + offsetY.current,\n      width: el.clientWidth - paddingRight,\n      height: el.clientHeight - paddingBottom,\n      paddingRight: rightWrapRef.current?.clientWidth ?? 0\n    });\n  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n  const onScrollRef = React.useRef(onScroll);\n  onScrollRef.current = onScroll;\n  const lastProps = React.useRef();\n  const didFirstScroll = React.useRef(false);\n  React.useEffect(() => {\n    if (didFirstScroll.current)\n      onScroll();\n    else\n      didFirstScroll.current = true;\n  }, [onScroll, paddingBottom, paddingRight]);\n  const setRefs = React.useCallback((instance) => {\n    scroller.current = instance;\n    if (scrollRef !== void 0) {\n      scrollRef.current = instance;\n    }\n  }, [scrollRef]);\n  let key = 0;\n  let h = 0;\n  padders.push(/* @__PURE__ */ React.createElement(\"div\", {\n    key: key++,\n    style: { width: scrollWidth, height: 0 }\n  }));\n  while (h < scrollHeight) {\n    const toAdd = Math.min(5e6, scrollHeight - h);\n    padders.push(/* @__PURE__ */ React.createElement(\"div\", {\n      key: key++,\n      style: { width: 0, height: toAdd }\n    }));\n    h += toAdd;\n  }\n  const { ref, width, height } = useResizeDetector(initialSize);\n  if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n    window.setTimeout(() => onScrollRef.current(), 0);\n    lastProps.current = { width, height };\n  }\n  if ((width ?? 0) === 0 || (height ?? 0) === 0)\n    return /* @__PURE__ */ React.createElement(\"div\", {\n      ref\n    });\n  return /* @__PURE__ */ React.createElement(\"div\", {\n    ref\n  }, /* @__PURE__ */ React.createElement(ScrollRegionStyle, {\n    isSafari: browserIsSafari.value\n  }, minimap, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-underlay\"\n  }, children), /* @__PURE__ */ React.createElement(\"div\", {\n    ref: setRefs,\n    style: lastProps.current,\n    draggable,\n    onDragStart: (e) => {\n      if (!draggable) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    },\n    className: \"dvn-scroller \" + (className ?? \"\"),\n    onScroll\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-scroll-inner\" + (rightElement === void 0 ? \" hidden\" : \"\")\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-stack\"\n  }, padders), rightElement !== void 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, !rightElementFill && /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-spacer\"\n  }), /* @__PURE__ */ React.createElement(\"div\", {\n    ref: rightWrapRef,\n    onMouseDown: eatEvent,\n    onMouseUp: eatEvent,\n    onMouseMove: eatEvent,\n    style: {\n      height,\n      maxHeight: clientHeight - Math.ceil(dpr % 1),\n      position: \"sticky\",\n      top: 0,\n      paddingLeft: 1,\n      marginBottom: -40,\n      marginRight: paddingRight,\n      flexGrow: rightElementFill ? 1 : void 0,\n      right: rightElementSticky ? paddingRight ?? 0 : void 0,\n      pointerEvents: \"auto\"\n    }\n  }, rightElement))))));\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL2luZmluaXRlLXNjcm9sbGVyLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2l6ZT86IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl07XG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50UHJvcHM/OiB7XG4gICAgICAgIHJlYWRvbmx5IHN0aWNreT86IGJvb2xlYW47XG4gICAgICAgIHJlYWRvbmx5IGZpbGw/OiBib29sZWFuO1xuICAgIH07XG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIHJlYWRvbmx5IG1pbmltYXA/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgc2Nyb2xsUmVmPzogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudCB8IG51bGw+O1xuICAgIHJlYWRvbmx5IHVwZGF0ZTogKHJlZ2lvbjogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB2b2lkO1xufVxuXG5jb25zdCBTY3JvbGxSZWdpb25TdHlsZSA9IHN0eWxlZC5kaXY8eyBpc1NhZmFyaTogYm9vbGVhbiB9PmBcbiAgICAuZHZuLXNjcm9sbGVyIHtcbiAgICAgICAgb3ZlcmZsb3c6ICR7cCA9PiAocC5pc1NhZmFyaSA/IFwic2Nyb2xsXCIgOiBcImF1dG9cIil9O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgIH1cblxuICAgIC5oaWRkZW4ge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgfVxuXG4gICAgLmR2bi1zY3JvbGwtaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAuZHZuLXNwYWNlciB7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAuZHZuLXN0YWNrIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmR2bi11bmRlcmxheSA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICB9XG5cbiAgICBjYW52YXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuXG4gICAgICAgICoge1xuICAgICAgICAgICAgaGVpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxudHlwZSBTY3JvbGxMb2NrID0gW3VuZGVmaW5lZCwgbnVtYmVyXSB8IFtudW1iZXIsIHVuZGVmaW5lZF0gfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGVhdEV2ZW50KGU6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiB1c2VUb3VjaFVwRGVsYXllZChkZWxheTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgW2hhc1RvdWNoZXMsIHNldEhhc1RvdWNoZXNdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgY2JUaW1lciA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjYlRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgc2V0SGFzVG91Y2hlcyh0cnVlKTtcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hlbmRcIixcbiAgICAgICAgUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjYlRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRIYXNUb3VjaGVzKGZhbHNlKSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbZGVsYXldXG4gICAgICAgICksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhc1RvdWNoZXM7XG59XG5cbmV4cG9ydCBjb25zdCBJbmZpbml0ZVNjcm9sbGVyOiBSZWFjdC5GQzxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgc2Nyb2xsV2lkdGgsXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyA9IGZhbHNlLFxuICAgICAgICBwYWRkaW5nQm90dG9tID0gMCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMCxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgc2Nyb2xsUmVmLFxuICAgICAgICBzY3JvbGxUb0VuZCxcbiAgICAgICAgaW5pdGlhbFNpemUsXG4gICAgICAgIG1pbmltYXAsXG4gICAgfSA9IHA7XG4gICAgY29uc3QgcGFkZGVyczogUmVhY3QuUmVhY3ROb2RlW10gPSBbXTtcblxuICAgIGNvbnN0IHJpZ2h0RWxlbWVudFN0aWNreSA9IHJpZ2h0RWxlbWVudFByb3BzPy5zdGlja3kgPz8gZmFsc2U7XG4gICAgY29uc3QgcmlnaHRFbGVtZW50RmlsbCA9IHJpZ2h0RWxlbWVudFByb3BzPy5maWxsID8/IGZhbHNlO1xuXG4gICAgY29uc3Qgb2Zmc2V0WSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBsYXN0U2Nyb2xsWSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBzY3JvbGxlciA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHNjcm9sbGVyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBzY3JvbGxUb0VuZCAhPT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoO1xuICAgIH0sIFtzY3JvbGxUb0VuZF0pO1xuXG4gICAgY29uc3QgbGFzdFNjcm9sbFBvc2l0aW9uID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgICBsb2NrRGlyZWN0aW9uOiB1bmRlZmluZWQgYXMgU2Nyb2xsTG9jayxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJpZ2h0V3JhcFJlZiA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgaGFzVG91Y2hlcyA9IHVzZVRvdWNoVXBEZWxheWVkKDIwMCk7XG4gICAgY29uc3QgW2lzSWRsZSwgc2V0SXNJZGxlXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IGlkbGVUaW1lciA9IFJlYWN0LnVzZVJlZigwKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJZGxlIHx8IGhhc1RvdWNoZXMgfHwgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IFtseCwgbHldID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbjtcbiAgICAgICAgaWYgKGx4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbExlZnQgPSBseDtcbiAgICAgICAgfSBlbHNlIGlmIChseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbC5zY3JvbGxUb3AgPSBseTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIH0sIFtoYXNUb3VjaGVzLCBpc0lkbGVdKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHNjcm9sbGVyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGxldCBzY3JvbGxMZWZ0ID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgY29uc3QgbGFzdFNjcm9sbFRvcCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3QgbGFzdFNjcm9sbExlZnQgPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgIGNvbnN0IGR4ID0gc2Nyb2xsTGVmdCAtIGxhc3RTY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IHNjcm9sbFRvcCAtIGxhc3RTY3JvbGxUb3A7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzVG91Y2hlcyAmJlxuICAgICAgICAgICAgZHggIT09IDAgJiZcbiAgICAgICAgICAgIGR5ICE9PSAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZHgpID4gMyB8fCBNYXRoLmFicyhkeSkgPiAzKSAmJlxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nICYmXG4gICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID1cbiAgICAgICAgICAgICAgICBNYXRoLmFicyhkeCkgPCBNYXRoLmFicyhkeSkgPyBbbGFzdFNjcm9sbExlZnQsIHVuZGVmaW5lZF0gOiBbdW5kZWZpbmVkLCBsYXN0U2Nyb2xsVG9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvY2sgPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuXG4gICAgICAgIHNjcm9sbExlZnQgPSBsb2NrPy5bMF0gPz8gc2Nyb2xsTGVmdDtcbiAgICAgICAgc2Nyb2xsVG9wID0gbG9jaz8uWzFdID8/IHNjcm9sbFRvcDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgICAgICBjb25zdCBuZXdZID0gc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGxhc3RTY3JvbGxZLmN1cnJlbnQgLSBuZXdZO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICBsYXN0U2Nyb2xsWS5jdXJyZW50ID0gbmV3WTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzY3JvbGxhYmxlSGVpZ2h0ID4gMCAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGRlbHRhKSA+IDIwMDAgfHwgbmV3WSA9PT0gMCB8fCBuZXdZID09PSBzY3JvbGxhYmxlSGVpZ2h0KSAmJlxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID4gZWwuc2Nyb2xsSGVpZ2h0ICsgNVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2cgPSBuZXdZIC8gc2Nyb2xsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJlY29tcHV0ZWQgPSAoc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0KSAqIHByb2c7XG4gICAgICAgICAgICBvZmZzZXRZLmN1cnJlbnQgPSByZWNvbXB1dGVkIC0gbmV3WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaWRsZVRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgc2V0SXNJZGxlKGZhbHNlKTtcbiAgICAgICAgICAgIGlkbGVUaW1lci5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gc2V0SXNJZGxlKHRydWUpLCAyMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICAgIHg6IHNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiBuZXdZICsgb2Zmc2V0WS5jdXJyZW50LFxuICAgICAgICAgICAgd2lkdGg6IGVsLmNsaWVudFdpZHRoIC0gcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0OiBlbC5jbGllbnRIZWlnaHQgLSBwYWRkaW5nQm90dG9tLFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiByaWdodFdyYXBSZWYuY3VycmVudD8uY2xpZW50V2lkdGggPz8gMCxcbiAgICAgICAgfSk7XG4gICAgfSwgW3BhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodCwgc2Nyb2xsSGVpZ2h0LCB1cGRhdGUsIHByZXZlbnREaWFnb25hbFNjcm9sbGluZywgaGFzVG91Y2hlc10pO1xuXG4gICAgY29uc3Qgb25TY3JvbGxSZWYgPSBSZWFjdC51c2VSZWYob25TY3JvbGwpO1xuICAgIG9uU2Nyb2xsUmVmLmN1cnJlbnQgPSBvblNjcm9sbDtcblxuICAgIGNvbnN0IGxhc3RQcm9wcyA9IFJlYWN0LnVzZVJlZjx7IHdpZHRoPzogbnVtYmVyOyBoZWlnaHQ/OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IGRpZEZpcnN0U2Nyb2xsID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGlkRmlyc3RTY3JvbGwuY3VycmVudCkgb25TY3JvbGwoKTtcbiAgICAgICAgZWxzZSBkaWRGaXJzdFNjcm9sbC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXVCQSxNQUFNLG9CQUFvQixPQUFPO0FBQUE7QUFBQSxvQkFFYixPQUFNLEVBQUUsV0FBVyxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMkNsRCxrQkFBa0IsR0FBcUI7QUFDbkMsSUFBRTtBQUFBO0FBR04sMkJBQTJCLE9BQXdCO0FBQy9DLFFBQU0sQ0FBQyxZQUFZLGlCQUFpQixNQUFNLFNBQVM7QUFFbkQsUUFBTSxVQUFVLE1BQU0sT0FBTztBQUM3QixtQkFDSSxjQUNBLE1BQU0sWUFBWSxNQUFNO0FBQ3BCLFdBQU8sYUFBYSxRQUFRO0FBQzVCLGtCQUFjO0FBQUEsS0FDZixLQUNILFFBQ0EsTUFDQTtBQUdKLG1CQUNJLFlBQ0EsTUFBTSxZQUNGLE9BQUs7QUFDRCxRQUFJLEVBQUUsUUFBUSxXQUFXLEdBQUc7QUFDeEIsY0FBUSxVQUFVLE9BQU8sV0FBVyxNQUFNLGNBQWMsUUFBUTtBQUFBO0FBQUEsS0FHeEUsQ0FBQyxTQUVMLFFBQ0EsTUFDQTtBQUdKLFNBQU87QUFBQTtBQUdKLGFBQU0sbUJBQW9DLE9BQUs7QUFDbEQsUUFBTTtBQUFBLElBQ0Y7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLDJCQUEyQjtBQUFBLElBQzNCLGdCQUFnQjtBQUFBLElBQ2hCLGVBQWU7QUFBQSxJQUNmO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxNQUNBO0FBQ0osUUFBTSxVQUE2QjtBQUVuQyxRQUFNLHFCQUFxQixtQkFBbUIsVUFBVTtBQUN4RCxRQUFNLG1CQUFtQixtQkFBbUIsUUFBUTtBQUVwRCxRQUFNLFVBQVUsTUFBTSxPQUFPO0FBQzdCLFFBQU0sY0FBYyxNQUFNLE9BQU87QUFDakMsUUFBTSxXQUFXLE1BQU0sT0FBOEI7QUFFckQsUUFBTSxNQUFNLE9BQU87QUFFbkIsUUFBTSxVQUFVLE1BQU07QUFDbEIsVUFBTSxLQUFLLFNBQVM7QUFDcEIsUUFBSSxPQUFPLFFBQVEsZ0JBQWdCO0FBQU07QUFFekMsT0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHO0FBQUEsS0FDckMsQ0FBQztBQUVKLFFBQU0scUJBQXFCLE1BQU0sT0FBTztBQUFBLElBQ3BDLFlBQVk7QUFBQSxJQUNaLFdBQVc7QUFBQSxJQUNYLGVBQWU7QUFBQTtBQUduQixRQUFNLGVBQWUsTUFBTSxPQUE4QjtBQUV6RCxRQUFNLGFBQWEsa0JBQWtCO0FBQ3JDLFFBQU0sQ0FBQyxRQUFRLGFBQWEsTUFBTSxTQUFTO0FBQzNDLFFBQU0sWUFBWSxNQUFNLE9BQU87QUFFL0IsUUFBTSxVQUFVLE1BQU07QUFDbEIsUUFBSSxDQUFDLFVBQVUsY0FBYyxtQkFBbUIsUUFBUSxrQkFBa0I7QUFBVztBQUNyRixVQUFNLEtBQUssU0FBUztBQUNwQixRQUFJLE9BQU87QUFBTTtBQUNqQixVQUFNLENBQUMsSUFBSSxNQUFNLG1CQUFtQixRQUFRO0FBQzVDLFFBQUksT0FBTyxRQUFXO0FBQ2xCLFNBQUcsYUFBYTtBQUFBLGVBQ1QsT0FBTyxRQUFXO0FBQ3pCLFNBQUcsWUFBWTtBQUFBO0FBRW5CLHVCQUFtQixRQUFRLGdCQUFnQjtBQUFBLEtBQzVDLENBQUMsWUFBWTtBQUVoQixRQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU07QUFDckMsVUFBTSxLQUFLLFNBQVM7QUFDcEIsUUFBSSxPQUFPO0FBQU07QUFFakIsUUFBSSxZQUFZLEdBQUc7QUFDbkIsUUFBSSxhQUFhLEdBQUc7QUFDcEIsVUFBTSxnQkFBZ0IsbUJBQW1CLFFBQVE7QUFDakQsVUFBTSxpQkFBaUIsbUJBQW1CLFFBQVE7QUFFbEQsVUFBTSxLQUFLLGFBQWE7QUFDeEIsVUFBTSxLQUFLLFlBQVk7QUFFdkIsUUFDSSxjQUNBLE9BQU8sS0FDUCxPQUFPLEtBQ04sTUFBSyxJQUFJLE1BQU0sS0FBSyxLQUFLLElBQUksTUFBTSxNQUNwQyw0QkFDQSxtQkFBbUIsUUFBUSxrQkFBa0IsUUFDL0M7QUFDRSx5QkFBbUIsUUFBUSxnQkFDdkIsS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsVUFBYSxDQUFDLFFBQVc7QUFBQTtBQUdoRixVQUFNLE9BQU8sbUJBQW1CLFFBQVE7QUFFeEMsaUJBQWEsT0FBTyxNQUFNO0FBQzFCLGdCQUFZLE9BQU8sTUFBTTtBQUN6Qix1QkFBbUIsUUFBUSxhQUFhO0FBQ3hDLHVCQUFtQixRQUFRLFlBQVk7QUFFdkMsVUFBTSxPQUFPO0FBQ2IsVUFBTSxRQUFRLFlBQVksVUFBVTtBQUNwQyxVQUFNLG1CQUFtQixHQUFHLGVBQWUsR0FBRztBQUM5QyxnQkFBWSxVQUFVO0FBRXRCLFFBQ0ksbUJBQW1CLEtBQ2xCLE1BQUssSUFBSSxTQUFTLE9BQVEsU0FBUyxLQUFLLFNBQVMscUJBQ2xELGVBQWUsR0FBRyxlQUFlLEdBQ25DO0FBQ0UsWUFBTSxPQUFPLE9BQU87QUFDcEIsWUFBTSxhQUFjLGdCQUFlLEdBQUcsZ0JBQWdCO0FBQ3RELGNBQVEsVUFBVSxhQUFhO0FBQUE7QUFHbkMsUUFBSSxTQUFTLFFBQVc7QUFDcEIsYUFBTyxhQUFhLFVBQVU7QUFDOUIsZ0JBQVU7QUFDVixnQkFBVSxVQUFVLE9BQU8sV0FBVyxNQUFNLFVBQVUsT0FBTztBQUFBO0FBR2pFLFdBQU87QUFBQSxNQUNILEdBQUc7QUFBQSxNQUNILEdBQUcsT0FBTyxRQUFRO0FBQUEsTUFDbEIsT0FBTyxHQUFHLGNBQWM7QUFBQSxNQUN4QixRQUFRLEdBQUcsZUFBZTtBQUFBLE1BQzFCLGNBQWMsYUFBYSxTQUFTLGVBQWU7QUFBQTtBQUFBLEtBRXhELENBQUMsZUFBZSxjQUFjLGNBQWMsUUFBUSwwQkFBMEI7QUFFakYsUUFBTSxjQUFjLE1BQU0sT0FBTztBQUNqQyxjQUFZLFVBQVU7QUFFdEIsUUFBTSxZQUFZLE1BQU07QUFFeEIsUUFBTSxpQkFBaUIsTUFBTSxPQUFPO0FBQ3BDLFFBQU0sVUFBVSxNQUFNO0FBQ2xCLFFBQUksZUFBZTtBQUFTO0FBQUE7QUFDdkIscUJBQWUsVUFBVTtBQUFBLEtBQy9CLENBQUMsVUFBVSxlQUFlO0FBRTdCLFFBQU0sVUFBVSxNQUFNLFlBQ2xCLENBQUMsYUFBb0M7QUFDakMsYUFBUyxVQUFVO0FBQ25CLFFBQUksY0FBYyxRQUFXO0FBQ3pCLGdCQUFVLFVBQVU7QUFBQTtBQUFBLEtBRzVCLENBQUM7QUFHTCxNQUFJLE1BQU07QUFDVixNQUFJLElBQUk7QUFDUixVQUFRLEtBQUssb0NBQUMsT0FBRDtBQUFBLElBQUssS0FBSztBQUFBLElBQU8sT0FBTyxFQUFFLE9BQU8sYUFBYSxRQUFRO0FBQUE7QUFDbkUsU0FBTyxJQUFJLGNBQWM7QUFDckIsVUFBTSxRQUFRLEtBQUssSUFBSSxLQUFXLGVBQWU7QUFDakQsWUFBUSxLQUFLLG9DQUFDLE9BQUQ7QUFBQSxNQUFLLEtBQUs7QUFBQSxNQUFPLE9BQU8sRUFBRSxPQUFPLEdBQUcsUUFBUTtBQUFBO0FBQ3pELFNBQUs7QUFBQTtBQUdULFFBQU0sRUFBRSxLQUFLLE9BQU8sV0FBVyxrQkFBa0M7QUFFakUsTUFBSSxVQUFVLFNBQVMsV0FBVyxVQUFVLFVBQVUsU0FBUyxVQUFVLE9BQU87QUFDNUUsV0FBTyxXQUFXLE1BQU0sWUFBWSxXQUFXO0FBQy9DLGNBQVUsVUFBVSxFQUFFLE9BQU87QUFBQTtBQUdqQyxNQUFLLFVBQVMsT0FBTyxLQUFNLFdBQVUsT0FBTztBQUFHLFdBQU8sb0NBQUMsT0FBRDtBQUFBLE1BQUs7QUFBQTtBQUUzRCxTQUNJLG9DQUFDLE9BQUQ7QUFBQSxJQUFLO0FBQUEsS0FDRCxvQ0FBQyxtQkFBRDtBQUFBLElBQW1CLFVBQVUsZ0JBQWdCO0FBQUEsS0FDeEMsU0FDRCxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsS0FBZ0IsV0FDL0Isb0NBQUMsT0FBRDtBQUFBLElBQ0ksS0FBSztBQUFBLElBQ0wsT0FBTyxVQUFVO0FBQUEsSUFDakI7QUFBQSxJQUNBLGFBQWEsT0FBSztBQUNkLFVBQUksQ0FBQyxXQUFXO0FBQ1osVUFBRTtBQUNGLFVBQUU7QUFBQTtBQUFBO0FBQUEsSUFHVixXQUFXLGtCQUFtQixjQUFhO0FBQUEsSUFDM0M7QUFBQSxLQUNBLG9DQUFDLE9BQUQ7QUFBQSxJQUFLLFdBQVcscUJBQXNCLGtCQUFpQixTQUFZLFlBQVk7QUFBQSxLQUMzRSxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsS0FBYSxVQUMzQixpQkFBaUIsVUFDZCwwREFDSyxDQUFDLG9CQUFvQixvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsTUFDckMsb0NBQUMsT0FBRDtBQUFBLElBQ0ksS0FBSztBQUFBLElBQ0wsYUFBYTtBQUFBLElBQ2IsV0FBVztBQUFBLElBQ1gsYUFBYTtBQUFBLElBQ2IsT0FBTztBQUFBLE1BQ0g7QUFBQSxNQUNBLFdBQVcsZUFBZSxLQUFLLEtBQUssTUFBTTtBQUFBLE1BQzFDLFVBQVU7QUFBQSxNQUNWLEtBQUs7QUFBQSxNQUNMLGFBQWE7QUFBQSxNQUNiLGNBQWM7QUFBQSxNQUNkLGFBQWE7QUFBQSxNQUNiLFVBQVUsbUJBQW1CLElBQUk7QUFBQSxNQUNqQyxPQUFPLHFCQUFxQixnQkFBZ0IsSUFBSTtBQUFBLE1BQ2hELGVBQWU7QUFBQTtBQUFBLEtBRWxCO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const SearchWrapper = styled.div`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${(p) => p.showSearch ? 0 : 400}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2gtc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFNlYXJjaFdyYXBwZXIgPSBzdHlsZWQuZGl2PHsgc2hvd1NlYXJjaDogYm9vbGVhbiB9PmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA0cHg7XG4gICAgcmlnaHQ6IDIwcHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgcGFkZGluZzogOHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKCR7cCA9PiAocC5zaG93U2VhcmNoID8gMCA6IDQwMCl9cHgpO1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjE1cztcblxuICAgIC5zZWFyY2gtYmFyLWlubmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAuc2VhcmNoLXN0YXR1cyB7XG4gICAgICAgIHBhZGRpbmctdG9wOiA0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICB9XG5cbiAgICAuc2VhcmNoLXByb2dyZXNzIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBpbnB1dCB7XG4gICAgICAgIHdpZHRoOiAyMjBweDtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0RGFyayk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LW1lZGl1bSk7XG5cbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5idXR0b24taWNvbiB7XG4gICAgICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgICAgIGhlaWdodDogMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUVPLGFBQU0sZ0JBQWdCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRCQWNSLE9BQU0sRUFBRSxhQUFhLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nconst RenameInput = styled.input`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${(p) => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\nexport const GroupRename = (p) => {\n  const { bounds, group, onClose, canvasBounds, onFinish } = p;\n  const [value, setValue] = React.useState(group);\n  return /* @__PURE__ */ React.createElement(ClickOutsideContainer, {\n    style: {\n      position: \"absolute\",\n      left: bounds.x - canvasBounds.left + 1,\n      top: bounds.y - canvasBounds.top,\n      width: bounds.width - 2,\n      height: bounds.height\n    },\n    className: css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `,\n    onClickOutside: onClose\n  }, /* @__PURE__ */ React.createElement(RenameInput, {\n    targetHeight: bounds.height,\n    \"data-testid\": \"group-rename-input\",\n    value,\n    onBlur: onClose,\n    onFocus: (e) => e.target.setSelectionRange(0, value.length),\n    onChange: (e) => setValue(e.target.value),\n    onKeyDown: (e) => {\n      if (e.key === \"Enter\") {\n        onFinish(value);\n      } else if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    autoFocus: true\n  }));\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IGNzcyB9IGZyb20gXCJAbGluYXJpYS9jb3JlXCI7XG5pbXBvcnQgQ2xpY2tPdXRzaWRlQ29udGFpbmVyIGZyb20gXCIuLi9jbGljay1vdXRzaWRlLWNvbnRhaW5lci9jbGljay1vdXRzaWRlLWNvbnRhaW5lclwiO1xuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGJvdW5kczogUmVjdGFuZ2xlO1xuICAgIHJlYWRvbmx5IGdyb3VwOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DbG9zZTogKCkgPT4gdm9pZDtcbiAgICByZWFkb25seSBvbkZpbmlzaDogKG5ld1ZhbDogc3RyaW5nKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGNhbnZhc0JvdW5kczogRE9NUmVjdDtcbn1cblxuY29uc3QgUmVuYW1lSW5wdXQgPSBzdHlsZWQuaW5wdXQ8eyB0YXJnZXRIZWlnaHQ6IG51bWJlciB9PmBcbiAgICBmbGV4LWdyb3c6IDE7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlci1oYXMtZm9jdXMpO1xuICAgIGJvcmRlci1yYWRpdXM6IDlweDtcbiAgICBwYWRkaW5nOiAwIDhweDtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWdyb3VwLWhlYWRlcik7XG4gICAgbWluLWhlaWdodDogJHtwID0+IE1hdGgubWF4KDE2LCBwLnRhcmdldEhlaWdodCAtIDEwKX1weDtcbiAgICBmb250OiB2YXIoLS1nZGctaGVhZGVyLWZvbnQtc3R5bGUpIHZhcigtLWdkZy1mb250LWZhbWlseSk7XG5gO1xuXG5leHBvcnQgY29uc3QgR3JvdXBSZW5hbWU6IFJlYWN0LlZGQzxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGJvdW5kcywgZ3JvdXAsIG9uQ2xvc2UsIGNhbnZhc0JvdW5kcywgb25GaW5pc2ggfSA9IHA7XG5cbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGdyb3VwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxDbGlja091dHNpZGVDb250YWluZXJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMueCAtIGNhbnZhc0JvdW5kcy5sZWZ0ICsgMSxcbiAgICAgICAgICAgICAgICB0b3A6IGJvdW5kcy55IC0gY2FudmFzQm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRzLndpZHRoIC0gMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NgXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIG9uQ2xpY2tPdXRzaWRlPXtvbkNsb3NlfT5cbiAgICAgICAgICAgIDxSZW5hbWVJbnB1dFxuICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodD17Ym91bmRzLmhlaWdodH1cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD1cImdyb3VwLXJlbmFtZS1pbnB1dFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQmx1cj17b25DbG9zZX1cbiAgICAgICAgICAgICAgICBvbkZvY3VzPXtlID0+IGUudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKDAsIHZhbHVlLmxlbmd0aCl9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9DbGlja091dHNpZGVDb250YWluZXI+XG4gICAgKTtcbn07XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVdBLE1BQU0sY0FBYyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQVNULE9BQUssS0FBSyxJQUFJLElBQUksRUFBRSxlQUFlO0FBQUE7QUFBQTtBQUk5QyxhQUFNLGNBQWdDLE9BQUs7QUFDOUMsUUFBTSxFQUFFLFFBQVEsT0FBTyxTQUFTLGNBQWMsYUFBYTtBQUUzRCxRQUFNLENBQUMsT0FBTyxZQUFZLE1BQU0sU0FBUztBQUV6QyxTQUNJLG9DQUFDLHVCQUFEO0FBQUEsSUFDSSxPQUFPO0FBQUEsTUFDSCxVQUFVO0FBQUEsTUFDVixNQUFNLE9BQU8sSUFBSSxhQUFhLE9BQU87QUFBQSxNQUNyQyxLQUFLLE9BQU8sSUFBSSxhQUFhO0FBQUEsTUFDN0IsT0FBTyxPQUFPLFFBQVE7QUFBQSxNQUN0QixRQUFRLE9BQU87QUFBQTtBQUFBLElBRW5CLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNWCxnQkFBZ0I7QUFBQSxLQUNoQixvQ0FBQyxhQUFEO0FBQUEsSUFDSSxjQUFjLE9BQU87QUFBQSxJQUNyQixlQUFZO0FBQUEsSUFDWjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsU0FBUyxPQUFLLEVBQUUsT0FBTyxrQkFBa0IsR0FBRyxNQUFNO0FBQUEsSUFDbEQsVUFBVSxPQUFLLFNBQVMsRUFBRSxPQUFPO0FBQUEsSUFDakMsV0FBVyxPQUFLO0FBQ1osVUFBSSxFQUFFLFFBQVEsU0FBUztBQUNuQixpQkFBUztBQUFBLGlCQUNGLEVBQUUsUUFBUSxVQUFVO0FBQzNCO0FBQUE7QUFBQTtBQUFBLElBR1IsV0FBVztBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nfunction toCss(x) {\n  if (typeof x === \"string\")\n    return x;\n  return `${x}px`;\n}\nconst Wrapper = styled.div`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${(p) => p.innerWidth};\n    height: ${(p) => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\nexport const DataEditorContainer = (p) => {\n  const { inWidth, inHeight, children, ...rest } = p;\n  return /* @__PURE__ */ React.createElement(Wrapper, {\n    innerHeight: toCss(inHeight),\n    innerWidth: toCss(inWidth),\n    ...rest\n  }, children);\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci1jb250YWluZXIvZGF0YS1ncmlkLWNvbnRhaW5lci50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBQ0E7QUFPQSxlQUFlLEdBQW9CO0FBQy9CLE1BQUksT0FBTyxNQUFNO0FBQVUsV0FBTztBQUNsQyxTQUFPLEdBQUc7QUFBQTtBQUdkLE1BQU0sVUFBVSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVFWLE9BQUssRUFBRTtBQUFBLGNBQ04sT0FBSyxFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtCZCxhQUFNLHNCQUErRSxPQUFLO0FBQzdGLFFBQU0sRUFBRSxTQUFTLFVBQVUsYUFBYSxTQUFTO0FBQ2pELFNBQ0ksb0NBQUMsU0FBRDtBQUFBLElBQVMsYUFBYSxNQUFNO0FBQUEsSUFBVyxZQUFZLE1BQU07QUFBQSxPQUFjO0FBQUEsS0FDbEU7QUFBQTsiLAogICJuYW1lcyI6IFtdCn0K*/","import { styled } from \"@linaria/react\";\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9idWJibGVzLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBCdWJibGVzT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5ib2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjBweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctYnViYmxlKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICBtYXJnaW46IDJweDtcbiAgICB9XG5cbiAgICB0ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG5cbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5gO1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFTyxhQUFNLDRCQUE0QixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\nconst DrilldownOverlayEditor = (p) => {\n  const { drilldowns } = p;\n  return /* @__PURE__ */ React.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => /* @__PURE__ */ React.createElement(\"div\", {\n    key: i,\n    className: \"doe-bubble\"\n  }, d.img !== void 0 && /* @__PURE__ */ React.createElement(\"img\", {\n    src: d.img\n  }), /* @__PURE__ */ React.createElement(\"div\", null, d.text))));\n};\nexport default DrilldownOverlayEditor;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9kcmlsbGRvd24tb3ZlcmxheS1lZGl0b3IudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IERyaWxsZG93bkNlbGxEYXRhIH0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmNvbnN0IERyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG5cbiAgICAuZG9lLWJ1YmJsZSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC40KSwgMCAxcHggM3B4IHJnYmEoNjIsIDY1LCA4NiwgMC40KTtcblxuICAgICAgICBpbWcge1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcblxuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG5cbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGRyaWxsZG93bnM6IHJlYWRvbmx5IERyaWxsZG93bkNlbGxEYXRhW107XG59XG5cbmNvbnN0IERyaWxsZG93bk92ZXJsYXlFZGl0b3I6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgZHJpbGxkb3ducyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8RHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlPlxuICAgICAgICAgICAge2RyaWxsZG93bnMubWFwKChkLCBpKSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cImRvZS1idWJibGVcIj5cbiAgICAgICAgICAgICAgICAgICAge2QuaW1nICE9PSB1bmRlZmluZWQgJiYgPGltZyBzcmM9e2QuaW1nfSAvPn1cbiAgICAgICAgICAgICAgICAgICAgPGRpdj57ZC50ZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIDwvRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlPlxuICAgICk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUNBO0FBQ0E7QUFFQSxNQUFNLDhCQUE4QixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBNkMzQyxNQUFNLHlCQUF5RCxPQUFLO0FBQ2hFLFFBQU0sRUFBRSxlQUFlO0FBQ3ZCLFNBQ0ksb0NBQUMsNkJBQUQsTUFDSyxXQUFXLElBQUksQ0FBQyxHQUFHLE1BQ2hCLG9DQUFDLE9BQUQ7QUFBQSxJQUFLLEtBQUs7QUFBQSxJQUFHLFdBQVU7QUFBQSxLQUNsQixFQUFFLFFBQVEsVUFBYSxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxLQUFLLEVBQUU7QUFBQSxNQUNwQyxvQ0FBQyxPQUFELE1BQU0sRUFBRTtBQUFBO0FBTTVCLGVBQWU7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgSW1hZ2VPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAuY2VudGVyaW5nLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgICBpbWcsXG4gICAgICAgIGNhbnZhcyB7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tb3ZlcmxheS10b3ApIC0gMjBweCk7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LXdpZHRoOiAzODBweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMTJweDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSwwQkFBMEIsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9tYXJrZG93bi1kaXYvcHJpdmF0ZS9tYXJrZG93bi1jb250YWluZXIudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogZGVmYXVsdDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuXG4gICAgPiAqIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgICYgKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICB9XG5cbiAgICAmIHAgaW1nIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSxvQkFBb0IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IElucHV0Qm94ID0gc3R5bGVkLnRleHRhcmVhYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xuXG4gICAgcmVzaXplOiBub25lO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXI6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICA6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICAuaW52YWxpZCAmIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbi1jb2xvcjogI2Q2MDYwNjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgU2hhZG93Qm94ID0gc3R5bGVkLmRpdmBcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcblxuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG5cbiAgICBtaW4td2lkdGg6IDEwMCU7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeVN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbWFyZ2luLXRvcDogNnB4O1xuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSxXQUFXLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQ3hCLGFBQU0sWUFBWSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0J6QixhQUFNLG9CQUFvQixPQUFPO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\nexport const MarkdownOverlayEditorStyle = styled.div`\n    min-width: ${(p) => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEdyb3dpbmdFbnRyeVN0eWxlIH0gZnJvbSBcIi4uLy4uL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZVwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aH1weDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgJHtHcm93aW5nRW50cnlTdHlsZX0ge1xuICAgICAgICBmbGV4LXNocmluazogMTtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgIH1cblxuICAgIC5zcGFjZXIge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBmbGV4LXNocmluazogMDtcblxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgXCIwLjEyNXMgZWFzZVwiO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTUwbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuY2hlY2ttYXJrLWhvdmVyIHtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWQtZWRpdC10ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDI1cHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuXG4gICAgLm1sLTYge1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgIH1cbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBTU8sYUFBTSw2QkFBNkIsT0FBTztBQUFBLGlCQUNoQyxPQUFLLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUWxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const NumberOverlayEditorStyle = styled.div`\n    display: flex;\n    margin: 6px 0 3px;\n    color: var(--gdg-text-dark);\n\n    > input {\n        font-size: var(--gdg-editor-font-size);\n        padding: 0;\n        font-family: var(--gdg-font-family);\n        color: var(--gdg-text-dark);\n        background-color: var(--gdg-bg-cell);\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9udW1iZXItb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IE51bWJlck92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IDZweCAwIDNweDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGlucHV0IHtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICB9XG5gO1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFTyxhQUFNLDJCQUEyQixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFVyaU92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcblxuICAgIGZsZXgtZ3JvdzogMTtcblxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICBtaW4taGVpZ2h0OiAyMXB4O1xuXG4gICAgLmxpbmstYXJlYSB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWxpbmstY29sb3IpO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSx3QkFBd0IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid/dist/index.css":
/*!********************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid/dist/index.css ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "../../node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "../../node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "../../node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "../../node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../../postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../../source-map-loader/dist/cjs.js!./index.css */ "../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!../../node_modules/@glideapps/glide-data-grid/dist/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CHARSET": () => (/* binding */ CHARSET),
/* harmony export */   "COMMENT": () => (/* binding */ COMMENT),
/* harmony export */   "COUNTER_STYLE": () => (/* binding */ COUNTER_STYLE),
/* harmony export */   "DECLARATION": () => (/* binding */ DECLARATION),
/* harmony export */   "DOCUMENT": () => (/* binding */ DOCUMENT),
/* harmony export */   "FONT_FACE": () => (/* binding */ FONT_FACE),
/* harmony export */   "FONT_FEATURE_VALUES": () => (/* binding */ FONT_FEATURE_VALUES),
/* harmony export */   "IMPORT": () => (/* binding */ IMPORT),
/* harmony export */   "KEYFRAMES": () => (/* binding */ KEYFRAMES),
/* harmony export */   "MEDIA": () => (/* binding */ MEDIA),
/* harmony export */   "MOZ": () => (/* binding */ MOZ),
/* harmony export */   "MS": () => (/* binding */ MS),
/* harmony export */   "NAMESPACE": () => (/* binding */ NAMESPACE),
/* harmony export */   "PAGE": () => (/* binding */ PAGE),
/* harmony export */   "RULESET": () => (/* binding */ RULESET),
/* harmony export */   "SUPPORTS": () => (/* binding */ SUPPORTS),
/* harmony export */   "VIEWPORT": () => (/* binding */ VIEWPORT),
/* harmony export */   "WEBKIT": () => (/* binding */ WEBKIT)
/* harmony export */ });
var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';
var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var PAGE = '@page';
var MEDIA = '@media';
var IMPORT = '@import';
var CHARSET = '@charset';
var VIEWPORT = '@viewport';
var SUPPORTS = '@supports';
var DOCUMENT = '@document';
var NAMESPACE = '@namespace';
var KEYFRAMES = '@keyframes';
var FONT_FACE = '@font-face';
var COUNTER_STYLE = '@counter-style';
var FONT_FEATURE_VALUES = '@font-feature-values';

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Middleware.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Middleware.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "middleware": () => (/* binding */ middleware),
/* harmony export */   "namespace": () => (/* binding */ namespace),
/* harmony export */   "prefixer": () => (/* binding */ prefixer),
/* harmony export */   "rulesheet": () => (/* binding */ rulesheet)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tokenizer.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js");
/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Serializer.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Serializer.js");
/* harmony import */ var _Prefixer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Prefixer.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Prefixer.js");






/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware(collection) {
  var length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(collection);
  return function (element, index, children, callback) {
    var output = '';
    for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
    return output;
  };
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet(callback) {
  return function (element) {
    if (!element.root) if (element = element.return) callback(element);
  };
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element.return) switch (element.type) {
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.DECLARATION:
      element.return = (0,_Prefixer_js__WEBPACK_IMPORTED_MODULE_2__.prefix)(element.value, element.length);
      break;
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.KEYFRAMES:
      return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {
        value: (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(element.value, '@', '@' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT)
      })], callback);
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:
      if (element.length) return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)(element.props, function (value) {
        switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.match)(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {
              props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(read-\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + '$1')]
            })], callback);
          // :placeholder
          case '::placeholder':
            return (0,_Serializer_js__WEBPACK_IMPORTED_MODULE_3__.serialize)([(0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {
              props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'input-$1')]
            }), (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {
              props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + '$1')]
            }), (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.copy)(element, {
              props: [(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /:(plac\w+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'input-$1')]
            })], callback);
        }
        return '';
      });
  }
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */
function namespace(element) {
  switch (element.type) {
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:
      element.props = element.props.map(function (value) {
        return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.combine)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_4__.tokenize)(value), function (value, index, children) {
          switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 0)) {
            // \f
            case 12:
              return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(value, 1, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value));
            // \0 ( + > ~
            case 0:
            case 40:
            case 43:
            case 62:
            case 126:
              return value;
            // :
            case 58:
              if (children[++index] === 'global') children[index] = '', children[++index] = '\f' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(children[index], index = 1, -1);
            // \s
            case 32:
              return index === 1 ? '' : value;
            default:
              switch (index) {
                case 0:
                  element = value;
                  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) > 1 ? '' : value;
                case index = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children) - 1:
                case 2:
                  return index === 2 ? value + element + element : value + element;
                default:
                  return value;
              }
          }
        });
      });
  }
}

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Parser.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Parser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "declaration": () => (/* binding */ declaration),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "ruleset": () => (/* binding */ ruleset)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Enum.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utility.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js");




/**
 * @param {string} value
 * @return {object[]}
 */
function compile(value) {
  return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.dealloc)(parse('', null, null, null, [''], value = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.alloc)(value), 0, [0], value));
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character = 0;
  var type = '';
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters = type;
  while (scanning) switch (previous = character, character = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)()) {
    // (
    case 40:
      if (previous != 108 && characters.charCodeAt(length - 1) == 58) {
        if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.indexof)(characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
        break;
      }
    // " ' [
    case 34:
    case 39:
    case 91:
      characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)(character);
      break;
    // \t \n \r \s
    case 9:
    case 10:
    case 13:
    case 32:
      characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.whitespace)(previous);
      break;
    // \
    case 92:
      characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.escaping)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)() - 1, 7);
      continue;
    // /
    case 47:
      switch ((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)()) {
        case 42:
        case 47:
          (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(comment((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.commenter)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)(), (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)()), root, parent), declarations);
          break;
        default:
          characters += '/';
      }
      break;
    // {
    case 123 * variable:
      points[index++] = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) * ampersand;
    // } ; \0
    case 125 * variable:
    case 59:
    case 0:
      switch (character) {
        // \0 }
        case 0:
        case 125:
          scanning = 0;
        // ;
        case 59 + offset:
          if (property > 0 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - length) (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
          break;
        // @ ;
        case 59:
          characters += ';';
        // { rule/at-rule
        default:
          (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
          if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule) {
            // d m s
            case 100:
            case 109:
            case 115:
              parse(value, reference, reference, rule && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.append)(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
              break;
            default:
              parse(characters, reference, reference, reference, [''], children, 0, points, children);
          }
      }
      index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
      break;
    // :
    case 58:
      length = 1 + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters), property = previous;
    default:
      if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.prev)() == 125) continue;
      switch (characters += (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)(character), character * variable) {
        // &
        case 38:
          ampersand = offset > 0 ? 1 : (characters += '\f', -1);
          break;
        // ,
        case 44:
          points[index++] = ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) - 1) * ampersand, ampersand = 1;
          break;
        // @
        case 64:
          // -
          if ((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)() === 45) characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.delimit)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.next)());
          atrule = (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.peek)(), offset = length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(type = characters += (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.identifier)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.caret)())), character++;
          break;
        // -
        case 45:
          if (previous === 45 && (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.strlen)(characters) == 2) variable = 0;
      }
  }
  return rulesets;
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [''];
  var size = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.sizeof)(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, post + 1, post = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.abs)(j = points[i])), z = value; x < size; ++x) if (z = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.trim)(j > 0 ? rule[x] + ' ' + y : (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.replace)(y, /&\f/g, rule[x]))) props[k++] = z;
  return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, offset === 0 ? _Enum_js__WEBPACK_IMPORTED_MODULE_2__.RULESET : type, props, children, length);
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment(value, root, parent) {
  return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.COMMENT, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.from)((0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.char)()), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 2, -2), 0);
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration(value, root, parent, length) {
  return (0,_Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.node)(value, root, parent, _Enum_js__WEBPACK_IMPORTED_MODULE_2__.DECLARATION, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, 0, length), (0,_Utility_js__WEBPACK_IMPORTED_MODULE_1__.substr)(value, length + 1, -1), length);
}

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Prefixer.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Prefixer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefix": () => (/* binding */ prefix)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");



/**
 * @param {string} value
 * @param {number} length
 * @return {string}
 */
function prefix(value, length) {
  switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.hash)(value, length)) {
    // color-adjust
    case 5103:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value;
    // order
    case 6165:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-' + value + value;
    // align-items
    case 5187:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(\w+).+(:[^]+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-$1$2' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-$1$2') + value;
    // align-self
    case 5443:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-item-' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /flex-|-self/, '') + value;
    // align-content
    case 4675:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-line-pack' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink
    case 5548:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'shrink', 'negative') + value;
    // flex-basis
    case 5292:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'basis', 'preferred-size') + value;
    // flex-grow
    case 6060:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, '-grow', '') + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'grow', 'positive') + value;
    // transition
    case 4554:
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /([^-])(transform)/g, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2') + value;
    // cursor
    case 6187:
      return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(zoom-|grab)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1'), /(image-set)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1'), value, '') + value;
    // background, background-image
    case 5495:
    case 3959:
      return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(image-set\([^]*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1' + '$`$1');
    // justify-content
    case 4968:
      return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(flex-)?(.*)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + 'box-pack:$3' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+)-inline(.+)/, _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value) - 1 - length > 6) switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)(.+)-([^]+)/, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2-$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MOZ + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch
        case 115:
          return ~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value, 'stretch') ? prefix((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      // (s)ticky?
      if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(value) - 3 - (~(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.indexof)(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, ':', ':' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + '$2$3' + '$1' + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + '$2box$3') + value;
      }
      break;
    // writing-mode
    case 5936:
      switch ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)
        case 108:
          return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb
        case 45:
          return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.replace)(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }
      return _Enum_js__WEBPACK_IMPORTED_MODULE_1__.WEBKIT + value + _Enum_js__WEBPACK_IMPORTED_MODULE_1__.MS + value + value;
  }
  return value;
}

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Serializer.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Serializer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serialize": () => (/* binding */ serialize),
/* harmony export */   "stringify": () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var _Enum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enum.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Enum.js");
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize(children, callback) {
  var output = '';
  var length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.sizeof)(children);
  for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';
  return output;
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify(element, index, children, callback) {
  switch (element.type) {
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.IMPORT:
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.DECLARATION:
      return element.return = element.return || element.value;
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.COMMENT:
      return '';
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.KEYFRAMES:
      return element.return = element.value + '{' + serialize(element.children, callback) + '}';
    case _Enum_js__WEBPACK_IMPORTED_MODULE_1__.RULESET:
      element.value = element.props.join(',');
  }
  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
}

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alloc": () => (/* binding */ alloc),
/* harmony export */   "caret": () => (/* binding */ caret),
/* harmony export */   "char": () => (/* binding */ char),
/* harmony export */   "character": () => (/* binding */ character),
/* harmony export */   "characters": () => (/* binding */ characters),
/* harmony export */   "column": () => (/* binding */ column),
/* harmony export */   "commenter": () => (/* binding */ commenter),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "dealloc": () => (/* binding */ dealloc),
/* harmony export */   "delimit": () => (/* binding */ delimit),
/* harmony export */   "delimiter": () => (/* binding */ delimiter),
/* harmony export */   "escaping": () => (/* binding */ escaping),
/* harmony export */   "identifier": () => (/* binding */ identifier),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "line": () => (/* binding */ line),
/* harmony export */   "next": () => (/* binding */ next),
/* harmony export */   "node": () => (/* binding */ node),
/* harmony export */   "peek": () => (/* binding */ peek),
/* harmony export */   "position": () => (/* binding */ position),
/* harmony export */   "prev": () => (/* binding */ prev),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "token": () => (/* binding */ token),
/* harmony export */   "tokenize": () => (/* binding */ tokenize),
/* harmony export */   "tokenizer": () => (/* binding */ tokenizer),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js");

var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node(value, root, parent, type, props, children, length) {
  return {
    value: value,
    root: root,
    parent: parent,
    type: type,
    props: props,
    children: children,
    line: line,
    column: column,
    length: length,
    return: ''
  };
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy(root, props) {
  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.assign)(node('', null, null, '', null, null, 0), root, {
    length: -root.length
  }, props);
}

/**
 * @return {number}
 */
function char() {
  return character;
}

/**
 * @return {number}
 */
function prev() {
  character = position > 0 ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, --position) : 0;
  if (column--, character === 10) column = 1, line--;
  return character;
}

/**
 * @return {number}
 */
function next() {
  character = position < length ? (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position++) : 0;
  if (column++, character === 10) column = 1, line++;
  return character;
}

/**
 * @return {number}
 */
function peek() {
  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.charat)(characters, position);
}

/**
 * @return {number}
 */
function caret() {
  return position;
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice(begin, end) {
  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.substr)(characters, begin, end);
}

/**
 * @param {number} type
 * @return {number}
 */
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc(value) {
  return line = column = 1, length = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.strlen)(characters = value), position = 0, [];
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc(value) {
  return characters = '', value;
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit(type) {
  return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.trim)(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}

/**
 * @param {string} value
 * @return {string[]}
 */
function tokenize(value) {
  return dealloc(tokenizer(alloc(value)));
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace(type) {
  while (character = peek()) if (character < 33) next();else break;
  return token(type) > 2 || token(character) > 3 ? '' : ' ';
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer(children) {
  while (next()) switch (token(character)) {
    case 0:
      (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(identifier(position - 1), children);
      break;
    case 2:
      (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)(delimit(character), children);
      break;
    default:
      (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.append)((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(character), children);
  }
  return children;
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping(index, count) {
  while (--count && next())
  // not 0-9 A-F a-f
  if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter(type) {
  while (next()) switch (character) {
    // ] ) " '
    case type:
      return position;
    // " '
    case 34:
    case 39:
      if (type !== 34 && type !== 39) delimiter(character);
      break;
    // (
    case 40:
      if (type === 41) delimiter(type);
      break;
    // \
    case 92:
      next();
      break;
  }
  return position;
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter(type, index) {
  while (next())
  // //
  if (type + character === 47 + 10) break;
  // /*
  else if (type + character === 42 + 42 && peek() === 47) break;
  return '/*' + slice(index, position - 1) + '*' + (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.from)(type === 47 ? type : next());
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier(index) {
  while (!token(peek())) next();
  return slice(index, position);
}

/***/ }),

/***/ "../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@emotion/cache/node_modules/stylis/src/Utility.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "charat": () => (/* binding */ charat),
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "from": () => (/* binding */ from),
/* harmony export */   "hash": () => (/* binding */ hash),
/* harmony export */   "indexof": () => (/* binding */ indexof),
/* harmony export */   "match": () => (/* binding */ match),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "sizeof": () => (/* binding */ sizeof),
/* harmony export */   "strlen": () => (/* binding */ strlen),
/* harmony export */   "substr": () => (/* binding */ substr),
/* harmony export */   "trim": () => (/* binding */ trim)
/* harmony export */ });
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {object}
 * @return {object}
 */
var assign = Object.assign;

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash(value, length) {
  return (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
}

/**
 * @param {string} value
 * @return {string}
 */
function trim(value) {
  return value.trim();
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof(value, search) {
  return value.indexOf(search);
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr(value, begin, end) {
  return value.slice(begin, end);
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen(value) {
  return value.length;
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof(value) {
  return value.length;
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append(value, array) {
  return array.push(value), value;
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine(array, callback) {
  return array.map(callback).join('');
}

/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid-cells/dist/js/chunk-ZLRFYDQA.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid-cells/dist/js/chunk-ZLRFYDQA.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "styled_default": () => (/* binding */ styled_default)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
// ../../node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default = memoize;

// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});
var is_prop_valid_browser_esm_default = index;

// ../../node_modules/@linaria/react/esm/styled.js


// ../../node_modules/@linaria/core/esm/cx.js
var cx = function cx2() {
  const presentClassNames = Array.prototype.slice.call(arguments).filter(Boolean);
  const atomicClasses = {};
  const nonAtomicClasses = [];
  presentClassNames.forEach(arg => {
    const individualClassNames = arg ? arg.split(" ") : [];
    individualClassNames.forEach(className => {
      if (className.startsWith("atm_")) {
        const [, keyHash] = className.split("_");
        atomicClasses[keyHash] = className;
      } else {
        nonAtomicClasses.push(className);
      }
    });
  });
  const result = [];
  for (const keyHash in atomicClasses) {
    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {
      result.push(atomicClasses[keyHash]);
    }
  }
  result.push(...nonAtomicClasses);
  return result.join(" ");
};
var cx_default = cx;

// ../../node_modules/@linaria/react/esm/styled.js
var isCapital = ch => ch.toUpperCase() === ch;
var filterKey = keys => key => keys.indexOf(key) === -1;
var omit = (obj, keys) => {
  const res = {};
  Object.keys(obj).filter(filterKey(keys)).forEach(key => {
    res[key] = obj[key];
  });
  return res;
};
function filterProps(component, props, omitKeys) {
  const filteredProps = omit(props, omitKeys);
  if (typeof component === "string" && component.indexOf("-") === -1 && !isCapital(component[0])) {
    Object.keys(filteredProps).forEach(key => {
      if (!is_prop_valid_browser_esm_default(key)) {
        delete filteredProps[key];
      }
    });
  }
  return filteredProps;
}
var warnIfInvalid = (value, componentName) => {
  if (true) {
    if (typeof value === "string" || typeof value === "number" && isFinite(value)) {
      return;
    }
    const stringified = typeof value === "object" ? JSON.stringify(value) : String(value);
    console.warn(`An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`);
  }
};
function styled(tag) {
  return options => {
    if (true) {
      if (Array.isArray(options)) {
        throw new Error('Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup');
      }
    }
    const render = (props, ref) => {
      const {
        as: component = tag,
        class: className
      } = props;
      const filteredProps = filterProps(component, props, ["as", "class"]);
      filteredProps.ref = ref;
      filteredProps.className = options.atomic ? cx_default(options.class, filteredProps.className || className) : cx_default(filteredProps.className || className, options.class);
      const {
        vars
      } = options;
      if (vars) {
        const style = {};
        for (const name in vars) {
          const variable = vars[name];
          const result = variable[0];
          const unit = variable[1] || "";
          const value = typeof result === "function" ? result(props) : result;
          warnIfInvalid(value, options.name);
          style[`--${name}`] = `${value}${unit}`;
        }
        const ownStyle = filteredProps.style || {};
        const keys = Object.keys(ownStyle);
        if (keys.length > 0) {
          keys.forEach(key => {
            style[key] = ownStyle[key];
          });
        }
        filteredProps.style = style;
      }
      if (tag.__linaria && tag !== component) {
        filteredProps.as = component;
        return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(tag, filteredProps);
      }
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, filteredProps);
    };
    const Result = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(render) : props => {
      const rest = omit(props, ["innerRef"]);
      return render(rest, props.innerRef);
    };
    Result.displayName = options.name;
    Result.__linaria = {
      className: options.class,
      extends: tag
    };
    return Result;
  };
}
var styled_default =  true ? new Proxy(styled, {
  get(o, prop) {
    return o(prop);
  }
}) : 0;


/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid-cells/dist/js/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid-cells/dist/js/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArticleCell": () => (/* binding */ article_cell_default),
/* harmony export */   "ButtonCell": () => (/* binding */ button_cell_default),
/* harmony export */   "DatePickerCell": () => (/* binding */ date_picker_cell_default),
/* harmony export */   "DropdownCell": () => (/* binding */ dropdown_cell_default),
/* harmony export */   "LinksCell": () => (/* binding */ links_cell_default),
/* harmony export */   "RangeCell": () => (/* binding */ range_cell_default),
/* harmony export */   "SparklineCell": () => (/* binding */ sparkline_cell_default),
/* harmony export */   "SpinnerCell": () => (/* binding */ spinner_cell_default),
/* harmony export */   "StarCell": () => (/* binding */ star_cell_default),
/* harmony export */   "TagsCell": () => (/* binding */ tags_cell_default),
/* harmony export */   "UserProfileCell": () => (/* binding */ user_profile_cell_default),
/* harmony export */   "allCells": () => (/* binding */ cells),
/* harmony export */   "useExtraCells": () => (/* binding */ useExtraCells)
/* harmony export */ });
/* harmony import */ var _chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-ZLRFYDQA.js */ "../../node_modules/@glideapps/glide-data-grid-cells/dist/js/chunk-ZLRFYDQA.js");
/* harmony import */ var _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @glideapps/glide-data-grid */ "../../node_modules/@glideapps/glide-data-grid/dist/js/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-select */ "../../node_modules/react-select/dist/index-a7690a33.esm.js");
/* harmony import */ var react_select__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-select */ "../../node_modules/react-select/dist/react-select.esm.js");


// src/index.ts


// src/cells/star-cell.tsx


var starPoints = [[50, 5], [61.23, 39.55], [97.55, 39.55], [68.16, 60.9], [79.39, 95.45], [50, 74.1], [20.61, 95.45], [31.84, 60.9], [2.45, 39.55], [38.77, 39.55]];
function pathStar(ctx, center, size) {
  let moved = false;
  for (const p of starPoints) {
    const x = (p[0] - 50) * (size / 100) + center[0];
    const y = (p[1] - 50) * (size / 100) + center[1];
    if (moved) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
      moved = true;
    }
  }
  ctx.closePath();
}
var StarSVG = () => /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("svg", {
  width: "100",
  height: "100",
  viewBox: "0 0 100 100",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
  d: "M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z",
  fill: "currentColor"
}));
var EditorWrap = /* @__PURE__ */(0,_chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__.styled_default)("div")({
  name: "EditorWrap",
  class: "e17a8fyf"
});
var renderer = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: cell => cell.data.kind === "star-cell",
  needsHover: true,
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      rating
    } = cell.data;
    const padX = theme.cellHorizontalPadding;
    let drawX = rect.x + padX;
    const stars = Math.min(5, Math.ceil(rating));
    drawX += 8;
    ctx.beginPath();
    for (let i = 0; i < stars; i++) {
      pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);
      drawX += 18;
    }
    ctx.fillStyle = theme.textDark;
    ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;
    ctx.fill();
    ctx.globalAlpha = 1;
    return true;
  },
  provideEditor: () => {
    return p => /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EditorWrap, null, [0, 1, 2, 3, 4].map(index => /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
      key: index,
      className: p.value.data.rating < index + 1 ? "inactive" : "active",
      onClick: () => {
        p.onChange({
          ...p.value,
          data: {
            ...p.value.data,
            rating: index + 1
          }
        });
      }
    }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StarSVG, null))));
  },
  onPaste: (val, d) => {
    const num = Number.parseInt(val);
    return {
      ...d,
      rating: Number.isNaN(num) ? 0 : num
    };
  }
};
var star_cell_default = renderer;

// src/cells/sparkline-cell.tsx

var renderer2 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: cell => cell.data.kind === "sparkline-cell",
  needsHover: true,
  needsHoverPosition: true,
  draw: (args, cell) => {
    var _a;
    const {
      ctx,
      theme,
      rect,
      hoverAmount,
      hoverX
    } = args;
    let {
      values,
      yAxis,
      color,
      graphKind = "line",
      displayValues
    } = cell.data;
    const [minY, maxY] = yAxis;
    if (values.length === 0) return true;
    values = values.map(x => Math.min(1, Math.max(0, (x - minY) / (maxY - minY))));
    const padX = theme.cellHorizontalPadding;
    const drawX = padX + rect.x;
    const y = rect.y + 3;
    const height = rect.height - 6;
    const width = rect.width - padX * 2;
    const delta = maxY - minY;
    const zeroY = maxY <= 0 ? y : minY >= 0 ? y + height : y + height * (maxY / delta);
    if (minY <= 0 && maxY >= 0) {
      ctx.beginPath();
      ctx.moveTo(drawX, zeroY);
      ctx.lineTo(drawX + width, zeroY);
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1;
      ctx.strokeStyle = theme.textLight;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    if (graphKind === "bar") {
      ctx.beginPath();
      const margin = 2;
      const spacing = (values.length - 1) * margin;
      const barWidth = (width - spacing) / values.length;
      let x = drawX;
      for (const val of values) {
        const barY = y + height - val * height;
        ctx.moveTo(x, zeroY);
        ctx.lineTo(x + barWidth, zeroY);
        ctx.lineTo(x + barWidth, barY);
        ctx.lineTo(x, barY);
        x += barWidth + margin;
      }
      ctx.fillStyle = (_a = cell.data.color) != null ? _a : theme.accentColor;
      ctx.fill();
    } else {
      if (values.length === 1) values = [values[0], values[0]];
      ctx.beginPath();
      const xStep = (rect.width - 16) / (values.length - 1);
      const points = values.map((val, ind) => {
        return {
          x: drawX + xStep * ind,
          y: y + height - val * height
        };
      });
      ctx.moveTo(points[0].x, points[0].y);
      let i;
      for (i = 1; i < points.length - 2; i++) {
        const xControl = (points[i].x + points[i + 1].x) / 2;
        const yControl = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, xControl, yControl);
      }
      ctx.quadraticCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
      ctx.strokeStyle = color != null ? color : theme.accentColor;
      ctx.lineWidth = 1 + hoverAmount * 0.5;
      ctx.stroke();
      ctx.lineTo(rect.x + rect.width - padX, zeroY);
      ctx.lineTo(rect.x + padX, zeroY);
      ctx.closePath();
      ctx.globalAlpha = 0.2 + 0.2 * hoverAmount;
      const grad = ctx.createLinearGradient(0, y, 0, y + height * 1.4);
      grad.addColorStop(0, color != null ? color : theme.accentColor);
      const [r, g, b] = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.parseToRgba)(color != null ? color : theme.accentColor);
      grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1;
      if (hoverX !== void 0 && graphKind === "line" && displayValues !== void 0) {
        ctx.beginPath();
        const closest = Math.min(values.length - 1, Math.max(0, Math.round((hoverX - padX) / xStep)));
        ctx.moveTo(drawX + closest * xStep, rect.y);
        ctx.lineTo(drawX + closest * xStep, rect.y + rect.height);
        ctx.lineWidth = 1;
        ctx.strokeStyle = theme.textLight;
        ctx.stroke();
        ctx.save();
        ctx.font = `8px ${theme.fontFamily}`;
        ctx.fillStyle = theme.textMedium;
        ctx.textBaseline = "top";
        ctx.fillText(displayValues[closest], drawX, rect.y + theme.cellVerticalPadding);
        ctx.restore();
      }
    }
    return true;
  },
  provideEditor: () => void 0,
  onPaste: (_v, d) => d
};
var sparkline_cell_default = renderer2;

// src/cells/tags-cell.tsx



// src/draw-fns.ts
function roundedRect(ctx, x, y, width, height, radius) {
  if (radius === 0) {
    ctx.rect(x, y, width, height);
    return;
  }
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }
  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}

// src/cells/tags-cell.tsx
var tagHeight = 20;
var innerPad = 6;
var _exp = () => p => p.tagHeight / 2;
var _exp2 = () => p => p.tagHeight;
var _exp3 = () => p => p.innerPad;
var EditorWrap2 = /* @__PURE__ */(0,_chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__.styled_default)("div")({
  name: "EditorWrap",
  class: "e43amum",
  vars: {
    "e43amum-0": [_exp(), "px"],
    "e43amum-1": [_exp2(), "px"],
    "e43amum-2": [_exp3(), "px"]
  }
});
var renderer3 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: c => c.data.kind === "tags-cell",
  draw: (args, cell) => {
    var _a, _b;
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      possibleTags,
      tags
    } = cell.data;
    const drawArea = {
      x: rect.x + theme.cellHorizontalPadding,
      y: rect.y + theme.cellVerticalPadding,
      width: rect.width - 2 * theme.cellHorizontalPadding,
      height: rect.height - 2 * theme.cellVerticalPadding
    };
    const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));
    let x = drawArea.x;
    let row = 1;
    let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;
    for (const tag of tags) {
      const color = (_b = (_a = possibleTags.find(t => t.tag === tag)) == null ? void 0 : _a.color) != null ? _b : theme.bgBubble;
      ctx.font = `12px ${theme.fontFamily}`;
      const metrics = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(tag, ctx);
      const width = metrics.width + innerPad * 2;
      const textY = tagHeight / 2;
      if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {
        row++;
        y += tagHeight + innerPad;
        x = drawArea.x;
      }
      ctx.fillStyle = color;
      ctx.beginPath();
      roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);
      ctx.fill();
      ctx.fillStyle = theme.textDark;
      ctx.fillText(tag, x + innerPad, y + textY + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, `12px ${theme.fontFamily}`));
      x += width + 8;
      if (x > drawArea.x + drawArea.width && row >= rows) break;
    }
    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        onChange,
        value
      } = p;
      const {
        possibleTags,
        tags,
        readonly = false
      } = value.data;
      return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EditorWrap2, {
        tagHeight,
        innerPad,
        className: readonly ? "readonly" : ""
      }, possibleTags.map(t => {
        const selected = tags.indexOf(t.tag) !== -1;
        return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("label", {
          key: t.tag
        }, !readonly && /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("input", {
          className: "gdg-input",
          type: "checkbox",
          checked: selected,
          onChange: () => {
            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];
            onChange({
              ...p.value,
              data: {
                ...value.data,
                tags: newTags
              }
            });
          }
        }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
          className: "pill " + (selected ? "selected" : "unselected"),
          style: {
            backgroundColor: selected ? t.color : void 0
          }
        }, t.tag));
      }));
    };
  },
  onPaste: (v, d) => ({
    ...d,
    tags: d.possibleTags.map(x => x.tag).filter(x => v.split(",").map(s => s.trim()).includes(x))
  })
};
var tags_cell_default = renderer3;

// src/cells/user-profile-cell.tsx


var renderer4 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: cell => cell.data.kind === "user-profile-cell",
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      imageLoader,
      col,
      row
    } = args;
    const {
      image,
      name,
      initial,
      tint
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    const radius = Math.min(12, rect.height / 2 - theme.cellVerticalPadding);
    const drawX = rect.x + xPad;
    const imageResult = imageLoader.loadOrGetImage(image, col, row);
    ctx.save();
    ctx.beginPath();
    ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = tint;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.font = `600 16px ${theme.fontFamily}`;
    const metrics = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(initial[0], ctx);
    ctx.fillText(initial[0], drawX + radius - metrics.width / 2, rect.y + rect.height / 2 + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, `600 16px ${theme.fontFamily}`));
    if (imageResult !== void 0) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(imageResult, drawX, rect.y + rect.height / 2 - radius, radius * 2, radius * 2);
      ctx.restore();
    }
    if (name !== void 0) {
      ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
      ctx.fillStyle = theme.textDark;
      ctx.fillText(name, drawX + radius * 2 + xPad, rect.y + rect.height / 2 + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme));
    }
    ctx.restore();
    return true;
  },
  provideEditor: () => p => {
    var _a;
    const {
      isHighlighted,
      onChange,
      value
    } = p;
    return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.TextCellEntry, {
      highlight: isHighlighted,
      autoFocus: true,
      value: (_a = value.data.name) != null ? _a : "",
      onChange: e => onChange({
        ...value,
        data: {
          ...value.data,
          name: e.target.value
        }
      })
    });
  },
  onPaste: (v, d) => ({
    ...d,
    name: v
  })
};
var user_profile_cell_default = renderer4;

// src/cells/dropdown-cell.tsx



var CustomMenu = p => {
  const {
    Menu
  } = react_select__WEBPACK_IMPORTED_MODULE_3__.c;
  const {
    children,
    ...rest
  } = p;
  return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Menu, {
    ...rest
  }, children);
};
var Wrap = /* @__PURE__ */(0,_chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__.styled_default)("div")({
  name: "Wrap",
  class: "w13j932a"
});
var PortalWrap = /* @__PURE__ */(0,_chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__.styled_default)("div")({
  name: "PortalWrap",
  class: "p19663q2"
});
var Editor = p => {
  const {
    value: cell,
    onFinishedEditing,
    initialValue
  } = p;
  const {
    allowedValues,
    value: valueIn
  } = cell.data;
  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(valueIn);
  const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue != null ? initialValue : "");
  const theme = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.useTheme)();
  const values = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => allowedValues.map(x => ({
    value: x,
    label: x
  })), [allowedValues]);
  return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Wrap, null, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_select__WEBPACK_IMPORTED_MODULE_4__["default"], {
    className: "glide-select",
    inputValue,
    onInputChange: setInputValue,
    menuPlacement: "auto",
    value: values.find(x => x.value === value),
    styles: {
      control: base => ({
        ...base,
        border: 0,
        boxShadow: "none"
      })
    },
    theme: t => {
      return {
        ...t,
        colors: {
          ...t.colors,
          neutral0: theme.bgCell,
          neutral5: theme.bgCell,
          neutral10: theme.bgCell,
          neutral20: theme.bgCellMedium,
          neutral30: theme.bgCellMedium,
          neutral40: theme.bgCellMedium,
          neutral50: theme.textLight,
          neutral60: theme.textMedium,
          neutral70: theme.textMedium,
          neutral80: theme.textDark,
          neutral90: theme.textDark,
          neutral100: theme.textDark,
          primary: theme.accentColor,
          primary75: theme.accentColor,
          primary50: theme.accentColor,
          primary25: theme.accentLight
        }
      };
    },
    menuPortalTarget: document.getElementById("portal"),
    autoFocus: true,
    openMenuOnFocus: true,
    components: {
      DropdownIndicator: () => null,
      IndicatorSeparator: () => null,
      Menu: props => /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PortalWrap, null, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(CustomMenu, {
        className: "click-outside-ignore",
        ...props
      }))
    },
    options: values,
    onChange: async e => {
      if (e === null) return;
      setValue(e.value);
      await new Promise(r => window.requestAnimationFrame(r));
      onFinishedEditing({
        ...cell,
        data: {
          ...cell.data,
          value: e.value
        }
      });
    }
  }));
};
var renderer5 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: c => c.data.kind === "dropdown-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      value
    } = cell.data;
    ctx.fillStyle = theme.textDark;
    ctx.fillText(value, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: Editor,
    disablePadding: true,
    deletedValue: v => ({
      ...v,
      copyData: "",
      data: {
        ...v.data,
        value: ""
      }
    })
  }),
  onPaste: (v, d) => ({
    ...d,
    value: d.allowedValues.includes(v) ? v : d.value
  })
};
var dropdown_cell_default = renderer5;

// src/cells/article-cell.tsx


var ArticleCellEditor = (0,react__WEBPACK_IMPORTED_MODULE_0__.lazy)(async () => await __webpack_require__.e(/*! import() */ "vendors-node_modules_glideapps_glide-data-grid-cells_dist_js_article-cell-editor-GUJXT6WU_js").then(__webpack_require__.bind(__webpack_require__, /*! ./article-cell-editor-GUJXT6WU.js */ "../../node_modules/@glideapps/glide-data-grid-cells/dist/js/article-cell-editor-GUJXT6WU.js")));
var renderer6 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: c => c.data.kind === "article-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      markdown
    } = cell.data;
    let data = markdown;
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }
    const max = rect.width / 4;
    if (data.length > max) {
      data = data.slice(0, max);
    }
    ctx.fillStyle = theme.textDark;
    ctx.fillText(data, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: p => {
      return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
        fallback: null
      }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ArticleCellEditor, {
        ...p
      }));
    },
    styleOverride: {
      position: "fixed",
      left: "12.5vw",
      top: "12.5vh",
      width: "75vw",
      borderRadius: "9px",
      maxWidth: "unset",
      maxHeight: "unset"
    },
    disablePadding: true
  }),
  onPaste: (val, d) => ({
    ...d,
    markdown: val
  })
};
var article_cell_default = renderer6;

// src/cells/range-cell.tsx


var RANGE_HEIGHT = 6;
var inputStyle = {
  marginRight: 8
};
var wrapperStyle = {
  display: "flex",
  alignItems: "center",
  flexGrow: 1
};
var renderer7 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: c => c.data.kind === "range-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      min,
      max,
      value,
      label,
      measureLabel
    } = cell.data;
    const x = rect.x + theme.cellHorizontalPadding;
    const yMid = rect.y + rect.height / 2;
    const rangeSize = max - min;
    const fillRatio = (value - min) / rangeSize;
    ctx.save();
    let labelWidth = 0;
    if (label !== void 0) {
      ctx.font = `12px ${theme.fontFamily}`;
      labelWidth = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(measureLabel != null ? measureLabel : label, ctx, `12px ${theme.fontFamily}`).width + theme.cellHorizontalPadding;
    }
    const rangeWidth = rect.width - theme.cellHorizontalPadding * 2 - labelWidth;
    const gradient = ctx.createLinearGradient(x, yMid, x + rangeWidth, yMid);
    gradient.addColorStop(0, theme.accentColor);
    gradient.addColorStop(fillRatio, theme.accentColor);
    gradient.addColorStop(fillRatio, theme.bgBubble);
    gradient.addColorStop(1, theme.bgBubble);
    ctx.beginPath();
    ctx.fillStyle = gradient;
    roundedRect(ctx, x, yMid - RANGE_HEIGHT / 2, rangeWidth, RANGE_HEIGHT, RANGE_HEIGHT / 2);
    ctx.fill();
    ctx.beginPath();
    roundedRect(ctx, x + 0.5, yMid - RANGE_HEIGHT / 2 + 0.5, rangeWidth - 1, RANGE_HEIGHT - 1, (RANGE_HEIGHT - 1) / 2);
    ctx.strokeStyle = theme.accentLight;
    ctx.lineWidth = 1;
    ctx.stroke();
    if (label !== void 0) {
      ctx.textAlign = "right";
      ctx.fillStyle = theme.textDark;
      ctx.fillText(label, rect.x + rect.width - theme.cellHorizontalPadding, yMid + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, `12px ${theme.fontFamily}`));
    }
    ctx.restore();
    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        data
      } = p.value;
      const strValue = data.value.toString();
      const strMin = data.min.toString();
      const strMax = data.max.toString();
      const strStep = data.step.toString();
      const onChange = e => {
        p.onChange({
          ...p.value,
          data: {
            ...data,
            value: Number(e.target.value)
          }
        });
      };
      return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("label", {
        style: wrapperStyle
      }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("input", {
        style: inputStyle,
        type: "range",
        value: strValue,
        min: strMin,
        max: strMax,
        step: strStep,
        onChange
      }), strValue);
    };
  },
  onPaste: (v, d) => {
    let num = Number.parseFloat(v);
    num = Number.isNaN(num) ? d.value : Math.max(d.min, Math.min(d.max, num));
    return {
      ...d,
      value: num
    };
  }
};
var range_cell_default = renderer7;

// src/cells/spinner-cell.tsx

var renderer8 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: cell => cell.data.kind === "spinner-cell",
  draw: args => {
    const {
      ctx,
      theme,
      rect,
      requestAnimationFrame
    } = args;
    const progress = window.performance.now() % 1e3 / 1e3;
    const x = rect.x + rect.width / 2;
    const y = rect.y + rect.height / 2;
    ctx.arc(x, y, Math.min(12, rect.height / 6), Math.PI * 2 * progress, Math.PI * 2 * progress + Math.PI * 1.5);
    ctx.strokeStyle = theme.textMedium;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.lineWidth = 1;
    requestAnimationFrame();
    return true;
  },
  provideEditor: () => void 0
};
var spinner_cell_default = renderer8;

// src/cells/date-picker-cell.tsx


var renderer9 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: cell => cell.data.kind === "date-picker-cell",
  draw: (args, cell) => {
    const {
      displayDate
    } = cell.data;
    (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(args, displayDate, cell.contentAlign);
    return true;
  },
  provideEditor: () => p => {
    const cellData = p.value.data;
    const {
      format,
      date
    } = cellData;
    let val = "";
    if (date !== void 0) {
      val = date.toISOString();
      if (format === "date") {
        val = val.split("T")[0];
      }
    }
    return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("input", {
      style: {
        minHeight: 26,
        border: "none",
        outline: "none"
      },
      type: format,
      autoFocus: true,
      value: val,
      onChange: e => {
        var _a;
        p.onChange({
          ...p.value,
          data: {
            ...p.value.data,
            date: (_a = e.target.valueAsDate) != null ? _a : void 0
          }
        });
      }
    });
  },
  onPaste: (v, d) => {
    let newDate;
    try {
      newDate = new Date(v);
    } catch (e) {}
    return {
      ...d,
      date: Number.isNaN(newDate) ? void 0 : newDate
    };
  }
};
var date_picker_cell_default = renderer9;

// src/cells/links-cell.tsx


function onClickSelect(e) {
  const useCtrl = e.cell.data.navigateOn !== "click";
  if (useCtrl !== e.ctrlKey) return void 0;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", {
    alpha: false
  });
  if (ctx === null) return;
  const {
    posX: hoverX,
    bounds: rect,
    cell,
    theme
  } = e;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  ctx.font = font;
  const {
    links
  } = cell.data;
  const xPad = theme.cellHorizontalPadding;
  let drawX = rect.x + xPad;
  const rectHoverX = rect.x + hoverX;
  for (const [index, l] of links.entries()) {
    const needsComma = index < links.length - 1;
    const metrics = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(l.title, ctx);
    const commaMetrics = needsComma ? (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(l.title + ",", ctx, font) : metrics;
    const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;
    if (isHovered) {
      return l;
    }
    drawX += commaMetrics.width + 4;
  }
  return void 0;
}
var renderer10 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  needsHover: true,
  needsHoverPosition: true,
  isMatch: c => c.data.kind === "links-cell",
  onSelect: e => {
    if (onClickSelect(e) !== void 0) {
      e.preventDefault();
    }
  },
  onClick: e => {
    var _a;
    const hovered = onClickSelect(e);
    if (hovered !== void 0) {
      (_a = hovered.onClick) == null ? void 0 : _a.call(hovered);
      e.preventDefault();
    }
    return void 0;
  },
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      hoverX = -100,
      highlighted
    } = args;
    const {
      links,
      underlineOffset = 5
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    let drawX = rect.x + xPad;
    const rectHoverX = rect.x + hoverX;
    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
    const middleCenterBias = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, font);
    const drawY = rect.y + rect.height / 2 + middleCenterBias;
    for (const [index, l] of links.entries()) {
      const needsComma = index < links.length - 1;
      const metrics = (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(l.title, ctx, font);
      const commaMetrics = needsComma ? (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(l.title + ",", ctx, font) : metrics;
      const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;
      if (isHovered) {
        ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.strokeStyle = theme.textDark;
        ctx.stroke();
        ctx.fillStyle = highlighted ? (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.blend)(theme.accentLight, theme.bgCell) : theme.bgCell;
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 2, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 2, drawY);
      }
      ctx.fillStyle = theme.textDark;
      ctx.fillText(needsComma ? l.title + "," : l.title, drawX, drawY);
      drawX += commaMetrics.width + 4;
    }
    return true;
  },
  provideEditor: () => p => {
    const {
      value,
      onChange
    } = p;
    const {
      links,
      maxLinks = Number.MAX_SAFE_INTEGER
    } = value.data;
    return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LinksCellEditorStyle, {
      onKeyDown: ignoreTab
    }, links.map((l, i) => {
      var _a;
      return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LinkTitleEditor, {
        key: i,
        link: (_a = l.href) != null ? _a : "",
        title: l.title,
        focus: i === 0,
        onDelete: links.length > 1 ? () => {
          const newLinks = [...links];
          newLinks.splice(i, 1);
          onChange({
            ...value,
            data: {
              ...value.data,
              links: newLinks
            }
          });
        } : void 0,
        onChange: (link, title) => {
          const newLinks = [...links];
          newLinks[i] = {
            href: link,
            title
          };
          onChange({
            ...value,
            data: {
              ...value.data,
              links: newLinks
            }
          });
        }
      });
    }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("button", {
      disabled: links.length >= maxLinks,
      className: "add-link",
      onClick: () => {
        const newLinks = [...links, {
          title: ""
        }];
        onChange({
          ...value,
          data: {
            ...value.data,
            links: newLinks
          }
        });
      }
    }, "Add link"));
  },
  onPaste: (v, d) => {
    const split = v.split(",");
    if (d.links.some((l, i) => split[i] !== l.title)) return void 0;
    return {
      ...d,
      links: split.map(l => ({
        title: l
      }))
    };
  }
};
var LinksCellEditorStyle = /* @__PURE__ */(0,_chunk_ZLRFYDQA_js__WEBPACK_IMPORTED_MODULE_1__.styled_default)("div")({
  name: "LinksCellEditorStyle",
  class: "lneeve5"
});
function ignoreTab(e) {
  if (e.key === "Tab") {
    e.stopPropagation();
  }
}
var LinkTitleEditor = p => {
  const {
    link,
    onChange,
    title,
    onDelete,
    focus
  } = p;
  return /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
    className: "gdg-link-title-editor"
  }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("input", {
    className: "gdg-title-input",
    value: title,
    placeholder: "Title",
    autoFocus: focus,
    onChange: e => {
      onChange(link, e.target.value);
    }
  }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("input", {
    className: "gdg-link-input",
    value: link,
    placeholder: "URL",
    onChange: e => {
      onChange(e.target.value, title);
    }
  }), onDelete !== void 0 && /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("button", {
    onClick: onDelete
  }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    fill: "none",
    id: "icon-import",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
    d: "M3 6L5 6L21 6",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
    d: "M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
    d: "M14.4499 10.211L13.9949 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
    d: "M9.55499 10.211L10.0049 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("path", {
    d: "M7.5 2.25H16.5",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }))));
};
var links_cell_default = renderer10;

// src/cells/button-cell.tsx

function unpackColor(color, theme, hoverAmount) {
  if (typeof color === "string") {
    if (theme[color] !== void 0) return theme[color];
    return color;
  }
  let [normal, hover] = color;
  if (theme[normal] !== void 0) normal = theme[normal];
  if (theme[hover] !== void 0) hover = theme[hover];
  return (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.interpolateColors)(normal, hover, hoverAmount);
}
var renderer11 = {
  kind: _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom,
  isMatch: c => c.data.kind === "button-cell",
  needsHover: true,
  onSelect: a => a.preventDefault(),
  onClick: a => {
    var _a, _b;
    (_b = (_a = a.cell.data).onClick) == null ? void 0 : _b.call(_a);
    return void 0;
  },
  drawPrep: args => {
    const {
      ctx
    } = args;
    ctx.textAlign = "center";
    return {
      deprep: a => {
        a.ctx.textAlign = "start";
      }
    };
  },
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      title,
      backgroundColor,
      color,
      borderColor,
      borderRadius
    } = cell.data;
    const x = Math.floor(rect.x + theme.cellHorizontalPadding + 1);
    const y = Math.floor(rect.y + theme.cellVerticalPadding + 1);
    const width = Math.ceil(rect.width - theme.cellHorizontalPadding * 2 - 1);
    const height = Math.ceil(rect.height - theme.cellVerticalPadding * 2 - 1);
    if (backgroundColor !== void 0) {
      ctx.beginPath();
      roundedRect(ctx, x, y, width, height, borderRadius != null ? borderRadius : 0);
      ctx.fillStyle = unpackColor(backgroundColor, theme, hoverAmount);
      ctx.fill();
    }
    if (borderColor !== void 0) {
      ctx.beginPath();
      roundedRect(ctx, x + 0.5, y + 0.5, width - 1, height - 1, borderRadius != null ? borderRadius : 0);
      ctx.strokeStyle = unpackColor(borderColor, theme, hoverAmount);
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.fillStyle = unpackColor(color != null ? color : theme.accentColor, theme, hoverAmount);
    ctx.fillText(title, x + width / 2, y + height / 2 + (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, `${theme.baseFontStyle} ${theme.fontFamily}`));
    return true;
  },
  provideEditor: void 0
};
var button_cell_default = renderer11;

// src/index.ts
var cells = [star_cell_default, sparkline_cell_default, tags_cell_default, user_profile_cell_default, dropdown_cell_default, article_cell_default, spinner_cell_default, range_cell_default, date_picker_cell_default, links_cell_default, button_cell_default];
function useExtraCells() {
  return (0,_glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.useCustomCells)(cells);
}


/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid-source/dist/js/use-column-sort.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid-source/dist/js/use-column-sort.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compareRaw": () => (/* binding */ compareRaw),
/* harmony export */   "compareSmart": () => (/* binding */ compareSmart),
/* harmony export */   "useColumnSort": () => (/* binding */ useColumnSort)
/* harmony export */ });
/* harmony import */ var _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @glideapps/glide-data-grid */ "../../node_modules/@glideapps/glide-data-grid/dist/js/index.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/range.js */ "../../node_modules/lodash/range.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");



function cellToSortData(c) {
  var _c$data$toString, _c$data, _c$data$toString2, _c$data2, _c$data3;
  switch (c.kind) {
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Number:
      return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Boolean:
      return (_c$data$toString2 = (_c$data2 = c.data) === null || _c$data2 === void 0 ? void 0 : _c$data2.toString()) !== null && _c$data$toString2 !== void 0 ? _c$data$toString2 : "";
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Markdown:
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.RowID:
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Text:
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Uri:
      return (_c$data3 = c.data) !== null && _c$data3 !== void 0 ? _c$data3 : "";
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Bubble:
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Image:
      return c.data.join("");
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Drilldown:
      return c.data.map(x => x.text).join("");
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Protected:
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Loading:
      return "";
    case _glideapps_glide_data_grid__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Custom:
      return c.copyData;
  }
}
function tryParse(val) {
  if (typeof val === "number") return val;
  if (val.length > 0) {
    const x = parseFloat(val);
    if (!isNaN(x)) {
      val = x;
    }
  }
  return val;
}
function compareSmart(a, b) {
  a = tryParse(a);
  b = tryParse(b);
  if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else if (typeof a === "number" && typeof b === "number") {
    if (a === b) return 0;
    return a > b ? 1 : -1;
  } else if (a == b) {
    return 0;
  }
  return a > b ? 1 : -1;
}
function compareRaw(a, b) {
  if (a > b) return 1;
  if (a === b) return 0;
  return -1;
}
function useColumnSort(p) {
  var _sort$direction;
  const {
    sort,
    rows,
    getCellContent: getCellContentIn
  } = p;
  let sortCol = sort === undefined ? undefined : p.columns.findIndex(c => sort.column === c || c.id !== undefined && sort.column.id === c.id);
  if (sortCol === -1) sortCol = undefined;
  const dir = (_sort$direction = sort === null || sort === void 0 ? void 0 : sort.direction) !== null && _sort$direction !== void 0 ? _sort$direction : "asc";
  const sortMap = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    if (sortCol === undefined) return undefined;
    const vals = new Array(rows);
    const index = [sortCol, 0];
    for (let i = 0; i < rows; i++) {
      index[1] = i;
      vals[i] = cellToSortData(getCellContentIn(index));
    }
    let result;
    if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "raw") {
      result = lodash_range_js__WEBPACK_IMPORTED_MODULE_0__(rows).sort((a, b) => compareRaw(vals[a], vals[b]));
    } else if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "smart") {
      result = lodash_range_js__WEBPACK_IMPORTED_MODULE_0__(rows).sort((a, b) => compareSmart(vals[a], vals[b]));
    } else {
      result = lodash_range_js__WEBPACK_IMPORTED_MODULE_0__(rows).sort((a, b) => vals[a].localeCompare(vals[b]));
    }
    if (dir === "desc") {
      result.reverse();
    }
    return result;
  }, [getCellContentIn, rows, sort === null || sort === void 0 ? void 0 : sort.mode, dir, sortCol]);
  const getOriginalIndex = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(index => {
    if (sortMap === undefined) return index;
    return sortMap[index];
  }, [sortMap]);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(_ref => {
    let [col, row] = _ref;
    if (sortMap === undefined) return getCellContentIn([col, row]);
    row = sortMap[row];
    return getCellContentIn([col, row]);
  }, [getCellContentIn, sortMap]);
  if (sortMap === undefined) {
    return {
      getCellContent: p.getCellContent,
      getOriginalIndex
    };
  }
  return {
    getOriginalIndex,
    getCellContent
  };
}

/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid/dist/js/chunk-UM7QR3LO.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid/dist/js/chunk-UM7QR3LO.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "styled_default": () => (/* binding */ styled_default)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
// ../../node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default = memoize;

// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});
var is_prop_valid_browser_esm_default = index;

// ../../node_modules/@linaria/react/esm/styled.js


// ../../node_modules/@linaria/core/esm/cx.js
var cx = function cx2() {
  const presentClassNames = Array.prototype.slice.call(arguments).filter(Boolean);
  const atomicClasses = {};
  const nonAtomicClasses = [];
  presentClassNames.forEach(arg => {
    const individualClassNames = arg ? arg.split(" ") : [];
    individualClassNames.forEach(className => {
      if (className.startsWith("atm_")) {
        const [, keyHash] = className.split("_");
        atomicClasses[keyHash] = className;
      } else {
        nonAtomicClasses.push(className);
      }
    });
  });
  const result = [];
  for (const keyHash in atomicClasses) {
    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {
      result.push(atomicClasses[keyHash]);
    }
  }
  result.push(...nonAtomicClasses);
  return result.join(" ");
};
var cx_default = cx;

// ../../node_modules/@linaria/react/esm/styled.js
var isCapital = ch => ch.toUpperCase() === ch;
var filterKey = keys => key => keys.indexOf(key) === -1;
var omit = (obj, keys) => {
  const res = {};
  Object.keys(obj).filter(filterKey(keys)).forEach(key => {
    res[key] = obj[key];
  });
  return res;
};
function filterProps(component, props, omitKeys) {
  const filteredProps = omit(props, omitKeys);
  if (typeof component === "string" && component.indexOf("-") === -1 && !isCapital(component[0])) {
    Object.keys(filteredProps).forEach(key => {
      if (!is_prop_valid_browser_esm_default(key)) {
        delete filteredProps[key];
      }
    });
  }
  return filteredProps;
}
var warnIfInvalid = (value, componentName) => {
  if (true) {
    if (typeof value === "string" || typeof value === "number" && isFinite(value)) {
      return;
    }
    const stringified = typeof value === "object" ? JSON.stringify(value) : String(value);
    console.warn(`An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`);
  }
};
function styled(tag) {
  return options => {
    if (true) {
      if (Array.isArray(options)) {
        throw new Error('Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup');
      }
    }
    const render = (props, ref) => {
      const {
        as: component = tag,
        class: className
      } = props;
      const filteredProps = filterProps(component, props, ["as", "class"]);
      filteredProps.ref = ref;
      filteredProps.className = options.atomic ? cx_default(options.class, filteredProps.className || className) : cx_default(filteredProps.className || className, options.class);
      const {
        vars
      } = options;
      if (vars) {
        const style = {};
        for (const name in vars) {
          const variable = vars[name];
          const result = variable[0];
          const unit = variable[1] || "";
          const value = typeof result === "function" ? result(props) : result;
          warnIfInvalid(value, options.name);
          style[`--${name}`] = `${value}${unit}`;
        }
        const ownStyle = filteredProps.style || {};
        const keys = Object.keys(ownStyle);
        if (keys.length > 0) {
          keys.forEach(key => {
            style[key] = ownStyle[key];
          });
        }
        filteredProps.style = style;
      }
      if (tag.__linaria && tag !== component) {
        filteredProps.as = component;
        return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(tag, filteredProps);
      }
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, filteredProps);
    };
    const Result = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(render) : props => {
      const rest = omit(props, ["innerRef"]);
      return render(rest, props.innerRef);
    };
    Result.displayName = options.name;
    Result.__linaria = {
      className: options.class,
      extends: tag
    };
    return Result;
  };
}
var styled_default =  true ? new Proxy(styled, {
  get(o, prop) {
    return o(prop);
  }
}) : 0;


/***/ }),

/***/ "../../node_modules/@glideapps/glide-data-grid/dist/js/index.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@glideapps/glide-data-grid/dist/js/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BooleanEmpty": () => (/* binding */ BooleanEmpty),
/* harmony export */   "BooleanIndeterminate": () => (/* binding */ BooleanIndeterminate),
/* harmony export */   "CompactSelection": () => (/* binding */ CompactSelection),
/* harmony export */   "DataEditor": () => (/* binding */ DataEditor),
/* harmony export */   "GridCellKind": () => (/* binding */ GridCellKind),
/* harmony export */   "GridColumnIcon": () => (/* binding */ GridColumnIcon),
/* harmony export */   "ImageOverlayEditor": () => (/* binding */ ImageOverlayEditor),
/* harmony export */   "InnerGridCellKind": () => (/* binding */ InnerGridCellKind),
/* harmony export */   "MarkdownDiv": () => (/* binding */ MarkdownDiv),
/* harmony export */   "TextCellEntry": () => (/* binding */ GrowingEntry),
/* harmony export */   "blend": () => (/* binding */ blend),
/* harmony export */   "booleanCellIsEditable": () => (/* binding */ booleanCellIsEditable),
/* harmony export */   "default": () => (/* binding */ DataEditor),
/* harmony export */   "drawTextCell": () => (/* binding */ drawTextCellExternal),
/* harmony export */   "getDefaultTheme": () => (/* binding */ getDataEditorTheme),
/* harmony export */   "getMiddleCenterBias": () => (/* binding */ getMiddleCenterBias),
/* harmony export */   "gridSelectionHasItem": () => (/* binding */ gridSelectionHasItem),
/* harmony export */   "groupHeaderKind": () => (/* binding */ groupHeaderKind),
/* harmony export */   "headerCellCheckboxPrefix": () => (/* binding */ headerCellCheckboxPrefix),
/* harmony export */   "headerCellCheckedMarker": () => (/* binding */ headerCellCheckedMarker),
/* harmony export */   "headerCellIndeterminateMarker": () => (/* binding */ headerCellIndeterminateMarker),
/* harmony export */   "headerCellUnheckedMarker": () => (/* binding */ headerCellUnheckedMarker),
/* harmony export */   "headerKind": () => (/* binding */ headerKind),
/* harmony export */   "interpolateColors": () => (/* binding */ interpolateColors),
/* harmony export */   "isEditableGridCell": () => (/* binding */ isEditableGridCell),
/* harmony export */   "isInnerOnlyCell": () => (/* binding */ isInnerOnlyCell),
/* harmony export */   "isObjectEditorCallbackResult": () => (/* binding */ isObjectEditorCallbackResult),
/* harmony export */   "isReadWriteCell": () => (/* binding */ isReadWriteCell),
/* harmony export */   "isSizedGridColumn": () => (/* binding */ isSizedGridColumn),
/* harmony export */   "isTextEditableGridCell": () => (/* binding */ isTextEditableGridCell),
/* harmony export */   "measureTextCached": () => (/* binding */ measureTextCached),
/* harmony export */   "outOfBoundsKind": () => (/* binding */ outOfBoundsKind),
/* harmony export */   "parseToRgba": () => (/* binding */ parseToRgba),
/* harmony export */   "resolveCellsThunk": () => (/* binding */ resolveCellsThunk),
/* harmony export */   "useColumnSizer": () => (/* binding */ useColumnSizer),
/* harmony export */   "useCustomCells": () => (/* binding */ useCustomCells),
/* harmony export */   "useTheme": () => (/* binding */ useTheme),
/* harmony export */   "withAlpha": () => (/* binding */ withAlpha)
/* harmony export */ });
/* harmony import */ var _chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-UM7QR3LO.js */ "../../node_modules/@glideapps/glide-data-grid/dist/js/chunk-UM7QR3LO.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/clamp.js */ "../../node_modules/lodash/clamp.js");
/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ "../../node_modules/lodash/uniq.js");
/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/flatten.js */ "../../node_modules/lodash/flatten.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/range.js */ "../../node_modules/lodash/range.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce.js */ "../../node_modules/lodash/debounce.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/has.js */ "../../node_modules/lodash/has.js");
/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/throttle.js */ "../../node_modules/lodash/throttle.js");
/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! canvas-hypertxt */ "../../node_modules/canvas-hypertxt/dist/js/index.js");
/* harmony import */ var lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/groupBy.js */ "../../node_modules/lodash/groupBy.js");
/* harmony import */ var react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-responsive-carousel */ "../../node_modules/react-responsive-carousel/lib/js/index.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! marked */ "../../node_modules/marked/lib/marked.esm.js");


// src/data-editor/data-editor.tsx


// src/common/support.ts
function proveType(_val) {}
function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}
function assert(fact) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";
  if (fact) return;
  return panic(message);
}
function assertNever(_never) {
  return panic("Hell froze over");
}
function maybe(fn, defaultValue) {
  try {
    return fn();
  } catch (e) {
    return defaultValue;
  }
}
var has = Object.prototype.hasOwnProperty;
function deepEqual(foo, bar) {
  let ctor, len;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && deepEqual(foo[len], bar[len]));
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// src/data-editor/data-editor.tsx






// src/data-grid-overlay-editor/data-grid-overlay-editor.tsx



// src/click-outside-container/click-outside-container.tsx

var ClickOutsideContainer = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.wrapperRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();
    this.clickOutside = event => {
      if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
        let node = event.target;
        while (node !== null) {
          if (node.classList.contains("click-outside-ignore")) {
            return;
          }
          node = node.parentElement;
        }
        this.props.onClickOutside();
      }
    };
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.clickOutside, true);
    document.addEventListener("contextmenu", this.clickOutside, true);
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.clickOutside);
    document.removeEventListener("contextmenu", this.clickOutside);
  }
  render() {
    const {
      onClickOutside,
      ...rest
    } = this.props;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      ...rest,
      ref: this.wrapperRef
    }, this.props.children);
  }
};

// src/common/styles.ts

function makeCSSStyle(theme) {
  var _a, _b;
  return {
    "--gdg-accent-color": theme.accentColor,
    "--gdg-accent-fg": theme.accentFg,
    "--gdg-accent-light": theme.accentLight,
    "--gdg-text-dark": theme.textDark,
    "--gdg-text-medium": theme.textMedium,
    "--gdg-text-light": theme.textLight,
    "--gdg-text-bubble": theme.textBubble,
    "--gdg-bg-icon-header": theme.bgIconHeader,
    "--gdg-fg-icon-header": theme.fgIconHeader,
    "--gdg-text-header": theme.textHeader,
    "--gdg-text-group-header": (_a = theme.textGroupHeader) != null ? _a : theme.textHeader,
    "--gdg-text-header-selected": theme.textHeaderSelected,
    "--gdg-bg-cell": theme.bgCell,
    "--gdg-bg-cell-medium": theme.bgCellMedium,
    "--gdg-bg-header": theme.bgHeader,
    "--gdg-bg-header-has-focus": theme.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": theme.bgHeaderHovered,
    "--gdg-bg-bubble": theme.bgBubble,
    "--gdg-bg-bubble-selected": theme.bgBubbleSelected,
    "--gdg-bg-search-result": theme.bgSearchResult,
    "--gdg-border-color": theme.borderColor,
    "--gdg-horizontal-border-color": (_b = theme.horizontalBorderColor) != null ? _b : theme.borderColor,
    "--gdg-drilldown-border": theme.drilldownBorder,
    "--gdg-link-color": theme.linkColor,
    "--gdg-cell-horizontal-padding": `${theme.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${theme.cellVerticalPadding}px`,
    "--gdg-header-font-style": theme.headerFontStyle,
    "--gdg-base-font-style": theme.baseFontStyle,
    "--gdg-font-family": theme.fontFamily,
    "--gdg-editor-font-size": theme.editorFontSize
  };
}
var dataEditorBaseTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerIconSize: 18,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
};
function getDataEditorTheme() {
  return dataEditorBaseTheme;
}
var ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);
function useTheme() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);
}

// src/data-grid/data-grid-types.ts

function gridSelectionHasItem(sel, item) {
  const [col, row] = item;
  if (sel.columns.hasIndex(col) || sel.rows.hasIndex(row)) return true;
  if (sel.current !== void 0) {
    if (sel.current.cell[0] === col && sel.current.cell[1] === row) return true;
    const toCheck = [sel.current.range, ...sel.current.rangeStack];
    for (const r of toCheck) {
      if (col >= r.x && col < r.x + r.width && row >= r.y && row < r.y + r.height) return true;
    }
  }
  return false;
}
var BooleanEmpty = null;
var BooleanIndeterminate = void 0;
var headerKind = "header";
var groupHeaderKind = "group-header";
var outOfBoundsKind = "out-of-bounds";
var GridCellKind;
(function (GridCellKind2) {
  GridCellKind2["Uri"] = "uri";
  GridCellKind2["Text"] = "text";
  GridCellKind2["Image"] = "image";
  GridCellKind2["RowID"] = "row-id";
  GridCellKind2["Number"] = "number";
  GridCellKind2["Bubble"] = "bubble";
  GridCellKind2["Boolean"] = "boolean";
  GridCellKind2["Loading"] = "loading";
  GridCellKind2["Markdown"] = "markdown";
  GridCellKind2["Drilldown"] = "drilldown";
  GridCellKind2["Protected"] = "protected";
  GridCellKind2["Custom"] = "custom";
})(GridCellKind || (GridCellKind = {}));
var GridColumnIcon;
(function (GridColumnIcon2) {
  GridColumnIcon2["HeaderRowID"] = "headerRowID";
  GridColumnIcon2["HeaderCode"] = "headerCode";
  GridColumnIcon2["HeaderNumber"] = "headerNumber";
  GridColumnIcon2["HeaderString"] = "headerString";
  GridColumnIcon2["HeaderBoolean"] = "headerBoolean";
  GridColumnIcon2["HeaderAudioUri"] = "headerAudioUri";
  GridColumnIcon2["HeaderVideoUri"] = "headerVideoUri";
  GridColumnIcon2["HeaderEmoji"] = "headerEmoji";
  GridColumnIcon2["HeaderImage"] = "headerImage";
  GridColumnIcon2["HeaderUri"] = "headerUri";
  GridColumnIcon2["HeaderPhone"] = "headerPhone";
  GridColumnIcon2["HeaderMarkdown"] = "headerMarkdown";
  GridColumnIcon2["HeaderDate"] = "headerDate";
  GridColumnIcon2["HeaderTime"] = "headerTime";
  GridColumnIcon2["HeaderEmail"] = "headerEmail";
  GridColumnIcon2["HeaderReference"] = "headerReference";
  GridColumnIcon2["HeaderIfThenElse"] = "headerIfThenElse";
  GridColumnIcon2["HeaderSingleValue"] = "headerSingleValue";
  GridColumnIcon2["HeaderLookup"] = "headerLookup";
  GridColumnIcon2["HeaderTextTemplate"] = "headerTextTemplate";
  GridColumnIcon2["HeaderMath"] = "headerMath";
  GridColumnIcon2["HeaderRollup"] = "headerRollup";
  GridColumnIcon2["HeaderJoinStrings"] = "headerJoinStrings";
  GridColumnIcon2["HeaderSplitString"] = "headerSplitString";
  GridColumnIcon2["HeaderGeoDistance"] = "headerGeoDistance";
  GridColumnIcon2["HeaderArray"] = "headerArray";
  GridColumnIcon2["RowOwnerOverlay"] = "rowOwnerOverlay";
  GridColumnIcon2["ProtectedColumnOverlay"] = "protectedColumnOverlay";
})(GridColumnIcon || (GridColumnIcon = {}));
var headerCellCheckboxPrefix = "___gdg_header_cell_";
var headerCellCheckedMarker = headerCellCheckboxPrefix + "checked";
var headerCellUnheckedMarker = headerCellCheckboxPrefix + "unchecked";
var headerCellIndeterminateMarker = headerCellCheckboxPrefix + "indeterminate";
function isSizedGridColumn(c) {
  return "width" in c && typeof c.width === "number";
}
async function resolveCellsThunk(thunk) {
  if (typeof thunk === "object") return thunk;
  return await thunk();
}
function isEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown) {
    return false;
  }
  proveType(cell);
  return true;
}
function isTextEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown || cell.kind === GridCellKind.Boolean || cell.kind === GridCellKind.Image || cell.kind === GridCellKind.Custom) {
    return false;
  }
  proveType(cell);
  return true;
}
function isInnerOnlyCell(cell) {
  return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;
}
function isReadWriteCell(cell) {
  if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;
  if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number || cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri || cell.kind === GridCellKind.Custom || cell.kind === GridCellKind.Boolean) {
    return cell.readonly !== true;
  }
  assertNever(cell);
}
function isObjectEditorCallbackResult(obj) {
  return lodash_has_js__WEBPACK_IMPORTED_MODULE_7__(obj, "editor");
}
function booleanCellIsEditable(cell) {
  var _a;
  return !((_a = cell.readonly) != null ? _a : false);
}
var InnerGridCellKind;
(function (InnerGridCellKind2) {
  InnerGridCellKind2["NewRow"] = "new-row";
  InnerGridCellKind2["Marker"] = "marker";
})(InnerGridCellKind || (InnerGridCellKind = {}));
function mergeRanges(input) {
  if (input.length === 0) {
    return [];
  }
  const ranges = [...input];
  const stack = [];
  ranges.sort(function (a, b) {
    return a[0] - b[0];
  });
  stack.push([...ranges[0]]);
  for (const range2 of ranges.slice(1)) {
    const top = stack[stack.length - 1];
    if (top[1] < range2[0]) {
      stack.push([...range2]);
    } else if (top[1] < range2[1]) {
      top[1] = range2[1];
    }
  }
  return stack;
}
var emptyCompactSelection;
var _CompactSelection = class {
  constructor(items) {
    this.items = items;
    this.offset = amount => {
      if (amount === 0) return this;
      const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);
      return new _CompactSelection(newItems);
    };
    this.add = selection => {
      const slice = typeof selection === "number" ? [selection, selection + 1] : selection;
      const newItems = mergeRanges([...this.items, slice]);
      return new _CompactSelection(newItems);
    };
    this.remove = selection => {
      const items2 = [...this.items];
      const selMin = typeof selection === "number" ? selection : selection[0];
      const selMax = typeof selection === "number" ? selection + 1 : selection[1];
      for (const [i, slice] of items2.entries()) {
        const [start, end] = slice;
        if (start <= selMax && selMin <= end) {
          const toAdd = [];
          if (start < selMin) {
            toAdd.push([start, selMin]);
          }
          if (selMax < end) {
            toAdd.push([selMax, end]);
          }
          items2.splice(i, 1, ...toAdd);
        }
      }
      return new _CompactSelection(items2);
    };
    this.first = () => {
      if (this.items.length === 0) return void 0;
      return this.items[0][0];
    };
    this.last = () => {
      if (this.items.length === 0) return void 0;
      return this.items.slice(-1)[0][1] - 1;
    };
    this.hasIndex = index => {
      for (let i = 0; i < this.items.length; i++) {
        const [start, end] = this.items[i];
        if (index >= start && index < end) return true;
      }
      return false;
    };
    this.hasAll = index => {
      for (let x = index[0]; x < index[1]; x++) {
        if (!this.hasIndex(x)) return false;
      }
      return true;
    };
    this.some = predicate => {
      for (const i of this) {
        if (predicate(i)) return true;
      }
      return false;
    };
    this.equals = other => {
      if (other === this) return true;
      if (other.items.length !== this.items.length) return false;
      for (let i = 0; i < this.items.length; i++) {
        const left = other.items[i];
        const right = this.items[i];
        if (left[0] !== right[0] || left[1] !== right[1]) return false;
      }
      return true;
    };
    this.toArray = () => {
      const result = [];
      for (const [start, end] of this.items) {
        for (let x = start; x < end; x++) {
          result.push(x);
        }
      }
      return result;
    };
  }
  get length() {
    let len = 0;
    for (const [start, end] of this.items) {
      len += end - start;
    }
    return len;
  }
  *[Symbol.iterator]() {
    for (const [start, end] of this.items) {
      for (let x = start; x < end; x++) {
        yield x;
      }
    }
  }
};
var CompactSelection = _CompactSelection;
CompactSelection.empty = () => {
  return emptyCompactSelection != null ? emptyCompactSelection : emptyCompactSelection = new _CompactSelection([]);
};
CompactSelection.fromSingleSelection = selection => {
  return _CompactSelection.empty().add(selection);
};

// src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx
var _exp = () => p => p.targetY;
var _exp2 = () => p => p.targetX - 1;
var _exp3 = () => p => p.targetY - 1;
var _exp4 = () => p => p.targetWidth + 2;
var _exp5 = () => p => p.targetHeight + 2;
var _exp6 = () => p => p.targetY + 10;
var _exp7 = () => p => Math.max(0, (p.targetHeight - 28) / 2);
var DataGridOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "DataGridOverlayEditorStyle",
  class: "d1t1th9s",
  vars: {
    "d1t1th9s-0": [_exp(), "px"],
    "d1t1th9s-1": [_exp2(), "px"],
    "d1t1th9s-2": [_exp3(), "px"],
    "d1t1th9s-3": [_exp4(), "px"],
    "d1t1th9s-4": [_exp5(), "px"],
    "d1t1th9s-5": [_exp6(), "px"],
    "d1t1th9s-6": [_exp7(), "px"]
  }
});

// src/data-grid-overlay-editor/use-stay-on-screen.ts

function useRefState() {
  const [refState, setRefState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  return [refState != null ? refState : void 0, setRefState];
}
function useStayOnScreen() {
  const [ref, setRef] = useRefState();
  const [xOffset, setXOffset] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [isIntersecting, setIsIntersecting] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (ref === void 0) return;
    if (!("IntersectionObserver" in window)) return;
    const observer = new IntersectionObserver(ents => {
      if (ents.length === 0) return;
      setIsIntersecting(ents[0].isIntersecting);
    }, {
      threshold: 1
    });
    observer.observe(ref);
    return () => observer.disconnect();
  }, [ref]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (isIntersecting || ref === void 0) return;
    let rafHandle;
    const fn = () => {
      const {
        right: refRight
      } = ref.getBoundingClientRect();
      setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
      rafHandle = requestAnimationFrame(fn);
    };
    rafHandle = requestAnimationFrame(fn);
    return () => {
      if (rafHandle !== void 0) {
        cancelAnimationFrame(rafHandle);
      }
    };
  }, [ref, isIntersecting]);
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      transform: `translateX(${xOffset}px)`
    };
  }, [xOffset]);
  return {
    ref: setRef,
    style
  };
}

// src/data-grid-overlay-editor/data-grid-overlay-editor.tsx
var DataGridOverlayEditor = p => {
  const {
    target,
    content,
    onFinishEditing: onFinishEditingIn,
    forceEditMode,
    initialValue,
    imageEditorOverride,
    markdownDivCreateNode,
    highlight,
    className,
    theme,
    id,
    cell,
    validateCell,
    getCellRenderer,
    provideEditor
  } = p;
  const [tempValue, setTempValueRaw] = react__WEBPACK_IMPORTED_MODULE_0__.useState(forceEditMode ? content : void 0);
  const lastValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(tempValue != null ? tempValue : content);
  lastValueRef.current = tempValue != null ? tempValue : content;
  const [isValid, setIsValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    if (validateCell === void 0) return true;
    return !(isEditableGridCell(content) && (validateCell == null ? void 0 : validateCell(cell, content, lastValueRef.current)) === false);
  });
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCell, movement) => {
    onFinishEditingIn(isValid ? newCell : void 0, movement);
  }, [isValid, onFinishEditingIn]);
  const setTempValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newVal => {
    if (validateCell !== void 0 && newVal !== void 0 && isEditableGridCell(newVal)) {
      const validResult = validateCell(cell, newVal, lastValueRef.current);
      if (validResult === false) {
        setIsValid(false);
      } else if (typeof validResult === "object") {
        newVal = validResult;
        setIsValid(true);
      } else {
        setIsValid(true);
      }
    }
    setTempValueRaw(newVal);
  }, [cell, validateCell]);
  const finished = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const customMotion = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);
  const onClickOutside = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onFinishEditing(tempValue, [0, 0]);
    finished.current = true;
  }, [tempValue, onFinishEditing]);
  const onEditorFinished = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newValue => {
    var _a;
    onFinishEditing(newValue, (_a = customMotion.current) != null ? _a : [0, 0]);
    finished.current = true;
  }, [onFinishEditing]);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async event => {
    let save = false;
    if (event.key === "Escape") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 0];
    } else if (event.key === "Enter" && !event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 1];
      save = true;
    } else if (event.key === "Tab") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [event.shiftKey ? -1 : 1, 0];
      save = true;
    }
    window.setTimeout(() => {
      if (!finished.current && customMotion.current !== void 0) {
        onFinishEditing(save ? tempValue : void 0, customMotion.current);
        finished.current = true;
      }
    }, 0);
  }, [onFinishEditing, tempValue]);
  const targetValue = tempValue != null ? tempValue : content;
  const [editorProvider, useLabel] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b;
    if (isInnerOnlyCell(content)) return [];
    const external = provideEditor == null ? void 0 : provideEditor(content);
    if (external !== void 0) return [external, false];
    return [(_b = (_a = getCellRenderer(content)) == null ? void 0 : _a.provideEditor) == null ? void 0 : _b.call(_a, content), false];
  }, [content, getCellRenderer, provideEditor]);
  const {
    ref,
    style: stayOnScreenStyle
  } = useStayOnScreen();
  let pad = true;
  let editor;
  let style = true;
  let styleOverride;
  if (editorProvider !== void 0) {
    pad = editorProvider.disablePadding !== true;
    style = editorProvider.disableStyling !== true;
    const isObjectEditor = isObjectEditorCallbackResult(editorProvider);
    if (isObjectEditor) {
      styleOverride = editorProvider.styleOverride;
    }
    const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
    editor = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomEditor, {
      isHighlighted: highlight,
      onChange: setTempValue,
      value: targetValue,
      initialValue,
      onFinishedEditing: onEditorFinished,
      validatedSelection: isEditableGridCell(targetValue) ? targetValue.selectionRange : void 0,
      forceEditMode,
      target,
      imageEditorOverride,
      markdownDivCreateNode,
      isValid
    });
  }
  styleOverride = {
    ...styleOverride,
    ...stayOnScreenStyle
  };
  const portalElement = document.getElementById("portal");
  if (portalElement === null) {
    console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
    return null;
  }
  let classWrap = style ? "gdg-style" : "gdg-unstyle";
  if (!isValid) {
    classWrap += " invalid";
  }
  if (pad) {
    classWrap += " pad";
  }
  return (0,react_dom__WEBPACK_IMPORTED_MODULE_6__.createPortal)( /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: theme
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: makeCSSStyle(theme),
    className,
    onClickOutside
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataGridOverlayEditorStyle, {
    ref,
    id,
    className: classWrap,
    style: styleOverride,
    as: useLabel === true ? "label" : void 0,
    targetX: target.x,
    targetY: target.y,
    targetWidth: target.width,
    targetHeight: target.height
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "clip-region",
    onKeyDown
  }, editor)))), portalElement);
};
var data_grid_overlay_editor_default = DataGridOverlayEditor;

// src/data-grid-search/data-grid-search.tsx


// src/scrolling-data-grid/scrolling-data-grid.tsx


// src/data-grid-dnd/data-grid-dnd.tsx



// src/data-grid/data-grid.tsx


// src/common/image-window-loader.ts

var rowShift = 1 << 16;
var imgPool = [];
function packColRowToNumber(col, row) {
  return row * rowShift + col;
}
function unpackCol(packed) {
  return packed % rowShift;
}
function unpackRow(packed, col) {
  return (packed - col) / rowShift;
}
function unpackNumberToColRow(packed) {
  const col = unpackCol(packed);
  const row = unpackRow(packed, col);
  return [col, row];
}
var ImageWindowLoaderImpl = class {
  constructor() {
    this.imageLoaded = () => void 0;
    this.loadedLocations = [];
    this.visibleWindow = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.freezeCols = 0;
    this.isInWindow = packed => {
      const col = unpackCol(packed);
      const row = unpackRow(packed, col);
      const w = this.visibleWindow;
      if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;
      return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    };
    this.cache = {};
    this.sendLoaded = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__(() => {
      this.imageLoaded(this.loadedLocations);
      this.loadedLocations = [];
    }, 20);
    this.clearOutOfWindow = () => {
      const keys = Object.keys(this.cache);
      for (const key of keys) {
        const obj = this.cache[key];
        let keep = false;
        for (let j = 0; j < obj.cells.length; j++) {
          const packed = obj.cells[j];
          if (this.isInWindow(packed)) {
            keep = true;
            break;
          }
        }
        if (keep) {
          obj.cells = obj.cells.filter(this.isInWindow);
        } else {
          obj.cancel();
          delete this.cache[key];
        }
      }
    };
  }
  setCallback(imageLoaded) {
    this.imageLoaded = imageLoaded;
  }
  setWindow(newWindow, freezeCols) {
    if (this.visibleWindow.x === newWindow.x && this.visibleWindow.y === newWindow.y && this.visibleWindow.width === newWindow.width && this.visibleWindow.height === newWindow.height && this.freezeCols === freezeCols) return;
    this.visibleWindow = newWindow;
    this.freezeCols = freezeCols;
    this.clearOutOfWindow();
  }
  loadImage(url, col, row, key) {
    var _a;
    let loaded = false;
    const img = (_a = imgPool.pop()) != null ? _a : new Image();
    let canceled = false;
    const result = {
      img: void 0,
      cells: [packColRowToNumber(col, row)],
      url,
      cancel: () => {
        if (canceled) return;
        canceled = true;
        if (imgPool.length < 12) {
          imgPool.unshift(img);
        } else if (!loaded) {
          img.src = "";
        }
      }
    };
    const loadPromise = new Promise(r => img.addEventListener("load", () => r(null)));
    requestAnimationFrame(async () => {
      try {
        img.src = url;
        await loadPromise;
        await img.decode();
        const toWrite = this.cache[key];
        if (toWrite !== void 0 && !canceled) {
          toWrite.img = img;
          for (const packed of toWrite.cells) {
            this.loadedLocations.push(unpackNumberToColRow(packed));
          }
          loaded = true;
          this.sendLoaded();
        }
      } catch (e) {
        result.cancel();
      }
    });
    this.cache[key] = result;
  }
  loadOrGetImage(url, col, row) {
    const key = url;
    const current = this.cache[key];
    if (current !== void 0) {
      const packed = packColRowToNumber(col, row);
      if (!current.cells.includes(packed)) {
        current.cells.push(packed);
      }
      return current.img;
    } else {
      this.loadImage(url, col, row, key);
    }
    return void 0;
  }
};
var image_window_loader_default = ImageWindowLoaderImpl;

// src/common/utils.tsx


function useEventListener(eventName, handler, element, passive) {
  let capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  savedHandler.current = handler;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (element === null || element.addEventListener === void 0) return;
    const el = element;
    const eventListener = event => {
      var _a;
      (_a = savedHandler.current) == null ? void 0 : _a.call(el, event);
    };
    el.addEventListener(eventName, eventListener, {
      passive,
      capture
    });
    return () => {
      el.removeEventListener(eventName, eventListener, {
        capture
      });
    };
  }, [eventName, element, passive, capture]);
}
function whenDefined(obj, result) {
  return obj === void 0 ? void 0 : result;
}
var PI = Math.PI;
function degreesToRadians(degrees) {
  return degrees * PI / 180;
}
var EditPencil = props => {
  var _a;
  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }));
};
var Checkmark = props => {
  var _a;
  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M19 6L10.3802 17L5.34071 11.8758",
    vectorEffect: "non-scaling-stroke",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
function useDebouncedMemo(factory, deps, time) {
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);
  const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {
    mountedRef.current = false;
  }, []);
  const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(x => {
    if (mountedRef.current) {
      setState(x);
    }
  }, time));
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (mountedRef.current) {
      debouncedSetState.current(() => factory());
    }
  }, deps);
  return state;
}
var rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
var ltrRange = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
var rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
var ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  return rtl.test(value) ? "rtl" : ltr.test(value) ? "ltr" : "neutral";
}
var scrollbarWidthCache = void 0;
function getScrollBarWidth() {
  if (scrollbarWidthCache !== void 0) return scrollbarWidthCache;
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.id = "testScrollbar";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.append(inner);
  document.body.append(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  outer.remove();
  scrollbarWidthCache = w1 - w2;
  return scrollbarWidthCache;
}
var empty = Symbol();
function useStateWithReactiveInput(inputState) {
  const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);
  if (inputStateRef.current[1] !== inputState) {
    inputStateRef.current[0] = inputState;
  }
  inputStateRef.current[1] = inputState;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);
  const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {
    const s = inputStateRef.current[0];
    if (s !== empty) {
      nv = typeof nv === "function" ? nv(s) : nv;
      if (nv === s) return;
    }
    if (s !== empty) forceRender({});
    setState(pv => {
      if (typeof nv === "function") {
        return nv(s === empty ? pv : s);
      }
      return nv;
    });
    inputStateRef.current[0] = empty;
  }, []);
  const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    inputStateRef.current[0] = empty;
    forceRender({});
  }, []);
  return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];
}

// src/data-grid/data-grid-lib.ts


function useMappedColumns(columns, freezeColumns) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({
    ...c,
    sourceIndex: i,
    sticky: i < freezeColumns
  })), [columns, freezeColumns]);
}
function isGroupEqual(left, right) {
  return (left != null ? left : "") === (right != null ? right : "");
}
function cellIsSelected(location, cell, selection) {
  if ((selection == null ? void 0 : selection.current) === void 0) return false;
  const [col, row] = selection.current.cell;
  const [cellCol, cellRow] = location;
  if (cellRow !== row) return false;
  if (cell.span === void 0) {
    return col === cellCol;
  }
  return col >= cell.span[0] && col <= cell.span[1];
}
function cellIsInRect(location, cell, rect) {
  const startX = rect.x;
  const endX = rect.x + rect.width - 1;
  const startY = rect.y;
  const endY = rect.y + rect.height - 1;
  const [cellCol, cellRow] = location;
  if (cellRow < startY || cellRow > endY) return false;
  if (cell.span === void 0) {
    return cellCol >= startX && cellCol <= endX;
  }
  const [spanStart, spanEnd] = cell.span;
  return spanStart >= startX && spanStart <= endX || spanEnd >= startX && spanStart <= endX || spanStart < startX && spanEnd > endX;
}
function cellIsInRange(location, cell, selection) {
  let result = 0;
  if (selection.current === void 0) return result;
  if (cellIsInRect(location, cell, selection.current.range)) result++;
  for (const r of selection.current.rangeStack) {
    if (cellIsInRect(location, cell, r)) {
      result++;
    }
  }
  return result;
}
function remapForDnDState(columns, dndState) {
  let mappedCols = columns;
  if (dndState !== void 0) {
    let writable = [...columns];
    const temp = mappedCols[dndState.src];
    if (dndState.src > dndState.dest) {
      writable.splice(dndState.src, 1);
      writable.splice(dndState.dest, 0, temp);
    } else {
      writable.splice(dndState.dest + 1, 0, temp);
      writable.splice(dndState.src, 1);
    }
    writable = writable.map((c, i) => ({
      ...c,
      sticky: columns[i].sticky
    }));
    mappedCols = writable;
  }
  return mappedCols;
}
function getStickyWidth(columns, dndState) {
  let result = 0;
  const remapped = remapForDnDState(columns, dndState);
  for (let i = 0; i < remapped.length; i++) {
    const c = remapped[i];
    if (c.sticky) result += c.width;else break;
  }
  return result;
}
function getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {
  const mappedCols = remapForDnDState(columns, dndState);
  const sticky = [];
  for (const c of mappedCols) {
    if (c.sticky) {
      sticky.push(c);
    } else {
      break;
    }
  }
  if (sticky.length > 0) {
    for (const c of sticky) {
      width -= c.width;
    }
  }
  let endIndex = cellXOffset;
  let curX = tx != null ? tx : 0;
  while (curX <= width && endIndex < mappedCols.length) {
    curX += mappedCols[endIndex].width;
    endIndex++;
  }
  for (let i = cellXOffset; i < endIndex; i++) {
    const c = mappedCols[i];
    if (!c.sticky) {
      sticky.push(c);
    }
  }
  return sticky;
}
function getColumnIndexForX(targetX, effectiveColumns, translateX) {
  let x = 0;
  for (const c of effectiveColumns) {
    const cx = c.sticky ? x : x + (translateX != null ? translateX : 0);
    if (targetX <= cx + c.width) {
      return c.sourceIndex;
    }
    x += c.width;
  }
  return -1;
}
function getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, lastRowSticky) {
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (hasGroups && targetY <= groupHeaderHeight) return -2;
  if (targetY <= totalHeaderHeight) return -1;
  const lastRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows - 1);
  if (lastRowSticky && targetY > height - lastRowHeight) {
    return rows - 1;
  }
  const effectiveRows = rows - (lastRowSticky ? 1 : 0);
  const ty = targetY - (translateY != null ? translateY : 0);
  if (typeof rowHeight === "number") {
    const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;
    if (target >= effectiveRows) return void 0;
    return target;
  } else {
    let curY = totalHeaderHeight;
    for (let i = cellYOffset; i < effectiveRows; i++) {
      const rh = rowHeight(i);
      if (ty <= curY + rh) return i;
      curY += rh;
    }
    return void 0;
  }
}
var metricsSize = 0;
var metricsCache = {};
var isSSR = typeof window === "undefined";
async function clearCacheOnLoad() {
  var _a;
  if (isSSR || ((_a = document == null ? void 0 : document.fonts) == null ? void 0 : _a.ready) === void 0) return;
  await document.fonts.ready;
  metricsSize = 0;
  metricsCache = {};
  (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__.clearCache)();
}
void clearCacheOnLoad();
function makeCacheKey(s, ctx, baseline, font) {
  return `${s}_${font != null ? font : ctx.font}_${baseline}`;
}
function measureTextCached(s, ctx, font) {
  const key = makeCacheKey(s, ctx, "middle", font);
  let metrics = metricsCache[key];
  if (metrics === void 0) {
    metrics = ctx.measureText(s);
    metricsCache[key] = metrics;
    metricsSize++;
  }
  if (metricsSize > 1e4) {
    metricsCache = {};
    metricsSize = 0;
  }
  return metrics;
}
function getMiddleCenterBias(ctx, font) {
  if (typeof font !== "string") {
    font = `${font.baseFontStyle} ${font.fontFamily}`;
  }
  return getMiddleCenterBiasInner(ctx, font);
}
function loadMetric(ctx, baseline) {
  const sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  ctx.save();
  ctx.textBaseline = baseline;
  const result = ctx.measureText(sample);
  ctx.restore();
  return result;
}
var biasCache = [];
function getMiddleCenterBiasInner(ctx, font) {
  for (const x of biasCache) {
    if (x.key === font) return x.val;
  }
  const alphabeticMetrics = loadMetric(ctx, "alphabetic");
  const middleMetrics = loadMetric(ctx, "middle");
  const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) + alphabeticMetrics.actualBoundingBoxAscent / 2;
  biasCache.push({
    key: font,
    val: bias
  });
  return bias;
}
function drawWithLastUpdate(args, lastUpdate, frameTime, lastPrep, draw) {
  const {
    ctx,
    rect,
    theme
  } = args;
  let progress = Number.MAX_SAFE_INTEGER;
  const animTime = 500;
  if (lastUpdate !== void 0) {
    progress = frameTime - lastUpdate;
    if (progress < animTime) {
      const fade = 1 - progress / animTime;
      ctx.globalAlpha = fade;
      ctx.fillStyle = theme.bgSearchResult;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      ctx.globalAlpha = 1;
      if (lastPrep !== void 0) {
        lastPrep.fillStyle = theme.bgSearchResult;
      }
    }
  }
  draw();
  return progress < animTime;
}
function prepTextCell(args, lastPrep, overrideColor) {
  const {
    ctx,
    theme
  } = args;
  const result = lastPrep != null ? lastPrep : {};
  const newFill = overrideColor != null ? overrideColor : theme.textDark;
  if (newFill !== result.fillStyle) {
    ctx.fillStyle = newFill;
    result.fillStyle = newFill;
  }
  return result;
}
function drawTextCellExternal(args, data, contentAlign) {
  const {
    rect,
    ctx,
    theme
  } = args;
  ctx.fillStyle = theme.textDark;
  drawTextCell({
    ctx,
    rect,
    theme
  }, data, contentAlign);
}
function drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {
  if (contentAlign === "right") {
    ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);
  } else if (contentAlign === "center") {
    ctx.fillText(data, x + w / 2, y + h / 2 + bias);
  } else {
    ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);
  }
}
function getEmHeight(ctx, fontStyle) {
  const textMetrics = measureTextCached("ABCi09jgqpy", ctx, fontStyle);
  return textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
}
function drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {
  const {
    ctx,
    rect,
    theme
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  allowWrapping = allowWrapping != null ? allowWrapping : false;
  if (!allowWrapping) {
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }
    const max = w / 4;
    if (data.length > max) {
      data = data.slice(0, max);
    }
  }
  const bias = getMiddleCenterBias(ctx, theme);
  const isRtl = direction(data) === "rtl";
  if (contentAlign === void 0 && isRtl) {
    contentAlign = "right";
  }
  if (isRtl) {
    ctx.direction = "rtl";
  }
  if (data.length > 0) {
    let changed = false;
    if (contentAlign === "right") {
      ctx.textAlign = "right";
      changed = true;
    } else if (contentAlign !== void 0 && contentAlign !== "left") {
      ctx.textAlign = contentAlign;
      changed = true;
    }
    if (!allowWrapping) {
      drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);
    } else {
      const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;
      const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__.split)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping != null ? hyperWrapping : false);
      const emHeight = getEmHeight(ctx, fontStyle);
      const lineHeight = theme.lineHeight * emHeight;
      const actualHeight = emHeight + lineHeight * (split.length - 1);
      const mustClip = actualHeight + theme.cellVerticalPadding > h;
      if (mustClip) {
        ctx.save();
        ctx.rect(x, y, w, h);
        ctx.clip();
      }
      const optimalY = y + h / 2 - actualHeight / 2;
      let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);
      for (const line of split) {
        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);
        drawY += lineHeight;
        if (drawY > y + h) break;
      }
      if (mustClip) {
        ctx.restore();
      }
    }
    if (changed) {
      ctx.textAlign = "start";
    }
    if (isRtl) {
      ctx.direction = "inherit";
    }
  }
}
function drawNewRowCell(args, data, icon) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme,
    spriteManager
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  ctx.beginPath();
  ctx.globalAlpha = hoverAmount;
  ctx.rect(x, y, w, h);
  ctx.fillStyle = theme.bgHeaderHovered;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  const alwaysShowIcon = data !== "";
  let textX = 0;
  if (icon !== void 0) {
    const padding = 8;
    const size = h - padding;
    const px = x + padding / 2;
    const py = y + padding / 2;
    spriteManager.drawSprite(icon, "normal", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);
    textX = size;
  } else {
    textX = 24;
    const finalLineSize = 12;
    const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;
    const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;
    const padPlus = theme.cellHorizontalPadding + 4;
    if (lineSize > 0) {
      ctx.moveTo(x + padPlus + xTranslate, y + h / 2);
      ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);
      ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);
      ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme.bgIconHeader;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }
  ctx.fillStyle = theme.textMedium;
  ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));
  ctx.beginPath();
}
function drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted) {
  let hoverX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : -20;
  let hoverY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -20;
  const centerX = x + width / 2;
  const centerY = y + height / 2;
  const checkBoxWidth = height / 1.89;
  const emptyCheckBoxWidth = height / 2;
  const hoverHelper = height / 3.4;
  const hovered = Math.abs(hoverX - width / 2) < hoverHelper && Math.abs(hoverY - height / 2) < hoverHelper;
  const rectBordRadius = 4;
  const posHelperChecked = height / 4.25;
  const posHelperEmpty = height / 4;
  const posHelperInter = height / 8.5;
  switch (checked) {
    case true:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperChecked + height / 9.31, centerY - posHelperChecked + height / 4.33);
        ctx.lineTo(centerX - posHelperChecked + height / 5.33, centerY - posHelperChecked + height / 3.17);
        ctx.lineTo(centerX - posHelperChecked + height / 2.83, centerY - posHelperChecked + height / 7.16);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }
    case BooleanEmpty:
    case false:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.lineWidth = 1;
        ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;
        ctx.stroke();
        break;
      }
    case BooleanIndeterminate:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperInter, centerY);
        ctx.lineTo(centerX + posHelperInter, centerY);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }
    default:
      assertNever(checked);
  }
}
function prepMarkerRowCell(args, lastPrep) {
  const {
    ctx,
    theme
  } = args;
  const newFont = `9px ${theme.fontFamily}`;
  const result = lastPrep != null ? lastPrep : {};
  if ((result == null ? void 0 : result.font) !== newFont) {
    ctx.font = newFont;
    result.font = newFont;
  }
  result.deprep = deprepMarkerRowCell;
  ctx.textAlign = "center";
  return result;
}
function deprepMarkerRowCell(args) {
  const {
    ctx
  } = args;
  ctx.textAlign = "start";
}
function drawMarkerRowCell(args, index, checked, markerKind, drawHandle) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme
  } = args;
  const {
    x,
    y,
    width,
    height
  } = rect;
  const checkedboxAlpha = checked ? 1 : hoverAmount;
  if (markerKind !== "number" && checkedboxAlpha > 0) {
    ctx.globalAlpha = checkedboxAlpha;
    const offsetAmount = 7 * (checked ? hoverAmount : 1);
    drawCheckbox(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true);
    if (drawHandle) {
      ctx.globalAlpha = hoverAmount;
      ctx.beginPath();
      for (const xOffset of [3, 6]) {
        for (const yOffset of [-5, -1, 3]) {
          ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);
        }
      }
      ctx.fillStyle = theme.textLight;
      ctx.fill();
      ctx.beginPath();
    }
    ctx.globalAlpha = 1;
  }
  if (markerKind === "number" || markerKind === "both" && !checked) {
    const text = index.toString();
    const start = x + width / 2;
    if (markerKind === "both" && hoverAmount !== 0) {
      ctx.globalAlpha = 1 - hoverAmount;
    }
    ctx.fillStyle = theme.textLight;
    ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));
    if (hoverAmount !== 0) {
      ctx.globalAlpha = 1;
    }
  }
}
function drawProtectedCell(args) {
  const {
    ctx,
    theme,
    rect
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  ctx.beginPath();
  const radius = 2.5;
  let xStart = x + theme.cellHorizontalPadding + radius;
  const center = y + h / 2;
  const p = Math.cos(degreesToRadians(30)) * radius;
  const q = Math.sin(degreesToRadians(30)) * radius;
  for (let i = 0; i < 12; i++) {
    ctx.moveTo(xStart, center - radius);
    ctx.lineTo(xStart, center + radius);
    ctx.moveTo(xStart + p, center - q);
    ctx.lineTo(xStart - p, center + q);
    ctx.moveTo(xStart - p, center - q);
    ctx.lineTo(xStart + p, center + q);
    xStart += 8;
  }
  ctx.lineWidth = 1.1;
  ctx.lineCap = "square";
  ctx.strokeStyle = theme.textLight;
  ctx.stroke();
}
function roundedRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }
  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}
function drawBoolean(args, data, canEdit) {
  if (!canEdit && data === BooleanEmpty) {
    return;
  }
  const {
    ctx,
    hoverAmount,
    theme,
    rect,
    highlighted,
    hoverX,
    hoverY
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const hoverEffect = 0.35;
  let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;
  if (data === BooleanEmpty) {
    alpha *= hoverAmount;
  }
  if (alpha === 0) {
    return;
  }
  ctx.globalAlpha = alpha;
  drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY);
  ctx.globalAlpha = 1;
}
var itemMargin = 4;
function drawBubbles(args, data) {
  const {
    rect,
    theme,
    ctx,
    highlighted
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 20;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const renderBoxes = [];
  for (const s of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    renderBoxes.push({
      x: renderX,
      width: textWidth
    });
    renderX += textWidth + bubblePad * 2 + bubbleMargin;
  }
  ctx.beginPath();
  for (const rectInfo of renderBoxes) {
    roundedRect(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, bubbleHeight / 2);
  }
  ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;
  ctx.fill();
  for (const [i, rectInfo] of renderBoxes.entries()) {
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
var drilldownCache = {};
function getAndCacheDrilldownBorder(bgCell, border, height) {
  const dpr = Math.ceil(window.devicePixelRatio);
  const shadowBlur = 5;
  const targetHeight = height - shadowBlur * 2;
  const middleWidth = 4;
  const rounding = 6;
  const innerHeight = height * dpr;
  const sideWidth = rounding + shadowBlur;
  const targetWidth = rounding * 3;
  const innerWidth = (targetWidth + shadowBlur * 2) * dpr;
  const key = `${bgCell},${border},${dpr},${height}`;
  if (drilldownCache[key] !== void 0) {
    return {
      el: drilldownCache[key],
      height: innerHeight,
      width: innerWidth,
      middleWidth: middleWidth * dpr,
      sideWidth: sideWidth * dpr,
      padding: shadowBlur * dpr,
      dpr
    };
  }
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (ctx === null) return null;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  ctx.scale(dpr, dpr);
  drilldownCache[key] = canvas;
  const trueRounding = Math.min(rounding, targetWidth / 2, targetHeight / 2);
  ctx.beginPath();
  roundedRect(ctx, shadowBlur, shadowBlur, targetWidth, targetHeight, trueRounding);
  ctx.shadowColor = "rgba(24, 25, 34, 0.4)";
  ctx.shadowBlur = 1;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowColor = "rgba(24, 25, 34, 0.3)";
  ctx.shadowOffsetY = 1;
  ctx.shadowBlur = 5;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.shadowBlur = 0;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetWidth, targetHeight, trueRounding);
  ctx.strokeStyle = border;
  ctx.lineWidth = 1;
  ctx.stroke();
  return {
    el: canvas,
    height: innerHeight,
    width: innerWidth,
    sideWidth: sideWidth * dpr,
    middleWidth: rounding * dpr,
    padding: shadowBlur * dpr,
    dpr
  };
}
function drawDrilldownCell(args, data) {
  const {
    rect,
    theme,
    ctx,
    imageLoader,
    col,
    row
  } = args;
  const {
    x,
    width: w
  } = rect;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  const emHeight = getEmHeight(ctx, font);
  const h = Math.min(rect.height, Math.max(16, Math.ceil(emHeight * theme.lineHeight) * 2));
  const y = Math.floor(rect.y + (rect.height - h) / 2);
  const bubbleHeight = h - 10;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder, h);
  const renderBoxes = [];
  for (const el of data) {
    if (renderX > x + w) break;
    const textMetrics = measureTextCached(el.text, ctx, font);
    const textWidth = textMetrics.width;
    let imgWidth = 0;
    if (el.img !== void 0) {
      const img = imageLoader.loadOrGetImage(el.img, col, row);
      if (img !== void 0) {
        imgWidth = bubbleHeight - 8 + 4;
      }
    }
    const renderWidth = textWidth + imgWidth + bubblePad * 2;
    renderBoxes.push({
      x: renderX,
      width: renderWidth
    });
    renderX += renderWidth + bubbleMargin;
  }
  if (tileMap !== null) {
    const {
      el,
      height,
      middleWidth,
      sideWidth,
      width,
      dpr,
      padding
    } = tileMap;
    const outerSideWidth = sideWidth / dpr;
    const outerPadding = padding / dpr;
    for (const rectInfo of renderBoxes) {
      const rx = Math.floor(rectInfo.x);
      const rw = Math.floor(rectInfo.width);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(el, 0, 0, sideWidth, height, rx - outerPadding, y, outerSideWidth, h);
      if (rectInfo.width > sideWidth * 2) ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + (outerSideWidth - outerPadding), y, rw - (outerSideWidth - outerPadding) * 2, h);
      ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (outerSideWidth - outerPadding), y, outerSideWidth, h);
      ctx.imageSmoothingEnabled = true;
    }
  }
  ctx.beginPath();
  for (const [i, rectInfo] of renderBoxes.entries()) {
    const d = data[i];
    let drawX = rectInfo.x + bubblePad;
    if (d.img !== void 0) {
      const img = imageLoader.loadOrGetImage(d.img, col, row);
      if (img !== void 0) {
        const imgSize = bubbleHeight - 8;
        let srcX = 0;
        let srcY = 0;
        let srcWidth = img.width;
        let srcHeight = img.height;
        if (srcWidth > srcHeight) {
          srcX += (srcWidth - srcHeight) / 2;
          srcWidth = srcHeight;
        } else if (srcHeight > srcWidth) {
          srcY += (srcHeight - srcWidth) / 2;
          srcHeight = srcWidth;
        }
        ctx.beginPath();
        roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);
        ctx.save();
        ctx.clip();
        ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);
        ctx.restore();
        drawX += imgSize + 4;
      }
    }
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
function drawImage(args, data) {
  let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  const {
    rect,
    col,
    row,
    theme,
    ctx,
    imageLoader
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  let drawX = x + theme.cellHorizontalPadding;
  for (const i of data) {
    if (i.length === 0) continue;
    const img = imageLoader.loadOrGetImage(i, col, row);
    if (img !== void 0) {
      const imgHeight = h - theme.cellVerticalPadding * 2;
      const imgWidth = img.width * (imgHeight / img.height);
      if (rounding > 0) {
        roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);
        ctx.save();
        ctx.clip();
      }
      ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);
      if (rounding > 0) {
        ctx.restore();
      }
      drawX += imgWidth + itemMargin;
    }
  }
}
function roundedPoly(ctx, points, radiusAll) {
  const asVec = function (p, pp) {
    const vx = pp.x - p.x;
    const vy = pp.y - p.y;
    const vlen = Math.sqrt(vx * vx + vy * vy);
    const vnx = vx / vlen;
    const vny = vy / vlen;
    return {
      x: vx,
      y: pp.y - p.y,
      len: vlen,
      nx: vnx,
      ny: vny,
      ang: Math.atan2(vny, vnx)
    };
  };
  let radius;
  const len = points.length;
  let p1 = points[len - 1];
  for (let i = 0; i < len; i++) {
    let p2 = points[i % len];
    const p3 = points[(i + 1) % len];
    const v1 = asVec(p2, p1);
    const v2 = asVec(p2, p3);
    const sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);
    let radDirection = 1;
    let drawDirection = false;
    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }
    radius = p2.radius !== void 0 ? p2.radius : radiusAll;
    const halfAngle = angle / 2;
    let lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    let cRadius;
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }
    let x = p2.x + v2.nx * lenOut;
    let y = p2.y + v2.ny * lenOut;
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    p1 = p2;
    p2 = p3;
  }
  ctx.closePath();
}
function computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight) {
  const result = {
    x: 0,
    y: totalHeaderHeight + translateY,
    width: 0,
    height: 0
  };
  const headerHeight = totalHeaderHeight - groupHeaderHeight;
  if (col >= freezeColumns) {
    const dir = cellXOffset > col ? -1 : 1;
    const freezeWidth = getStickyWidth(mappedColumns);
    result.x += freezeWidth + translateX;
    for (let i = cellXOffset; i !== col; i += dir) {
      result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;
    }
  } else {
    for (let i = 0; i < col; i++) {
      result.x += mappedColumns[i].width;
    }
  }
  result.width = mappedColumns[col].width + 1;
  if (row === -1) {
    result.y = groupHeaderHeight;
    result.height = headerHeight;
  } else if (row === -2) {
    result.y = 0;
    result.height = groupHeaderHeight;
    let start = col;
    const group = mappedColumns[col].group;
    const sticky = mappedColumns[col].sticky;
    while (start > 0 && isGroupEqual(mappedColumns[start - 1].group, group) && mappedColumns[start - 1].sticky === sticky) {
      const c = mappedColumns[start - 1];
      result.x -= c.width;
      result.width += c.width;
      start--;
    }
    let end = col;
    while (end + 1 < mappedColumns.length && isGroupEqual(mappedColumns[end + 1].group, group) && mappedColumns[end + 1].sticky === sticky) {
      const c = mappedColumns[end + 1];
      result.width += c.width;
      end++;
    }
    if (!sticky) {
      const freezeWidth = getStickyWidth(mappedColumns);
      const clip = result.x - freezeWidth;
      if (clip < 0) {
        result.x -= clip;
        result.width += clip;
      }
      if (result.x + result.width > width) {
        result.width = width - result.x;
      }
    }
  } else if (lastRowSticky && row === rows - 1) {
    const stickyHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(row);
    result.y = height - stickyHeight;
    result.height = stickyHeight;
  } else {
    const dir = cellYOffset > row ? -1 : 1;
    if (typeof rowHeight === "number") {
      const delta = row - cellYOffset;
      result.y += delta * rowHeight;
    } else {
      for (let r = cellYOffset; r !== row; r += dir) {
        result.y += rowHeight(r) * dir;
      }
    }
    result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
  }
  return result;
}

// src/data-grid/sprites.ts
var iconHead = `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">`;
var headerRowID = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${fg}"/></svg>`;
};
var headerCode = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="4" fill="${bg}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${fg}"/></svg>`;
};
var headerNumber = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${fg}"/>
  </svg>`;
};
var headerString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${fg}"/>
</svg>`;
};
var headerBoolean = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${bg}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${fg}"
    />
</svg>`;
};
var headerUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${fg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${fg}"/>
</svg>
  `;
};
var renameIcon = props => {
  const bg = props.bgColor;
  return `${iconHead}
    <path stroke="${bg}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${bg}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${bg}"/>
  </svg>
`;
};
var headerAudioUri = headerUri;
var headerVideoUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${fg}"/>
</svg>`;
};
var headerEmoji = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${fg}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${fg}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
  </svg>`;
};
var headerImage = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${fg}"/>
</svg>`;
};
var headerPhone = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path fill="${fg}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${bg}"/>
  </svg>`;
};
var headerMarkdown = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${fg}"/>
  </svg>`;
};
var headerDate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${fg}"/>
</svg>`;
};
var headerTime = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${fg}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${fg}"/>
  </svg>`;
};
var headerEmail = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${fg}"/>
</svg>`;
};
var headerReference = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${fg}"/>
  </svg>`;
};
var headerIfThenElse = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path fill="${fg}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${bg}"/>
</svg>`;
};
var headerSingleValue = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${fg}"/>
  </svg>`;
};
var headerLookup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${fg}"/>
  </svg>`;
};
var headerTextTemplate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${fg}"/>
</svg>`;
};
var headerMath = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${fg}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${fg}"/>
</svg>`;
};
var headerRollup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${fg}"/>
  </svg>`;
};
var headerJoinStrings = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${fg}"/>
</svg>`;
};
var headerSplitString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${fg}"/>
  </svg>`;
};
var headerGeoDistance = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${fg}"/>
</svg>`;
};
var headerArray = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${fg}"/>
</svg>`;
};
var rowOwnerOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>`;
};
var protectedColumnOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>
`;
};
var sprites = {
  headerRowID,
  headerNumber,
  headerCode,
  headerString,
  headerBoolean,
  headerAudioUri,
  headerVideoUri,
  headerEmoji,
  headerImage,
  headerUri,
  headerPhone,
  headerMarkdown,
  headerDate,
  headerTime,
  headerEmail,
  headerReference,
  headerIfThenElse,
  headerSingleValue,
  headerLookup,
  headerTextTemplate,
  headerMath,
  headerRollup,
  headerJoinStrings,
  headerSplitString,
  headerGeoDistance,
  headerArray,
  rowOwnerOverlay,
  protectedColumnOverlay,
  renameIcon
};

// src/data-grid/data-grid-sprites.ts
function getColors(variant, theme) {
  if (variant === "normal") {
    return [theme.bgIconHeader, theme.fgIconHeader];
  } else if (variant === "selected") {
    return ["white", theme.accentColor];
  } else {
    return [theme.accentColor, theme.bgHeader];
  }
}
var SpriteManager = class {
  constructor(headerIcons, onSettled) {
    this.onSettled = onSettled;
    this.spriteMap = /* @__PURE__ */new Map();
    this.inFlight = 0;
    this.headerIcons = {
      ...sprites,
      ...headerIcons
    };
  }
  drawSprite(sprite, variant, ctx, x, y, size, theme) {
    let alpha = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    const [bgColor, fgColor] = getColors(variant, theme);
    const rSize = size * Math.ceil(window.devicePixelRatio);
    const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;
    let spriteCanvas = this.spriteMap.get(key);
    if (spriteCanvas === void 0) {
      const spriteCb = this.headerIcons[sprite];
      if (spriteCb === void 0) return;
      spriteCanvas = document.createElement("canvas");
      const spriteCtx = spriteCanvas.getContext("2d");
      if (spriteCtx === null) return;
      const imgSource = new Image();
      imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({
        fgColor,
        bgColor
      }))}`;
      this.spriteMap.set(key, spriteCanvas);
      const promise = imgSource.decode();
      if (promise === void 0) return;
      this.inFlight++;
      promise.then(() => {
        spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);
      }).finally(() => {
        this.inFlight--;
        if (this.inFlight === 0) {
          this.onSettled();
        }
      });
    } else {
      if (alpha < 1) {
        ctx.globalAlpha = alpha;
      }
      ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);
      if (alpha < 1) {
        ctx.globalAlpha = 1;
      }
    }
  }
};

// src/data-grid/data-grid.tsx



// src/data-grid/data-grid-render.tsx


// src/data-grid/color-parser.ts
var cache = {};
var div = null;
function createDiv() {
  const d = document.createElement("div");
  d.style.opacity = "0";
  d.style.pointerEvents = "none";
  d.style.position = "fixed";
  document.body.append(d);
  return d;
}
function parseToRgba(color) {
  const normalizedColor = color.toLowerCase().trim();
  if (cache[normalizedColor] !== void 0) return cache[normalizedColor];
  div = div || createDiv();
  div.style.color = "#000";
  div.style.color = normalizedColor;
  const control = getComputedStyle(div).color;
  div.style.color = "#fff";
  div.style.color = normalizedColor;
  const computedColor = getComputedStyle(div).color;
  if (computedColor !== control) throw new Error("Could not parse color");
  const result = computedColor.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);
  if (result.length < 4) {
    result.push(1);
  }
  cache[normalizedColor] = result;
  return result;
}
function withAlpha(color, alpha) {
  const [r, g, b] = parseToRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
function blend(color, background) {
  if (background === void 0) return color;
  const [r, g, b, a] = parseToRgba(color);
  if (a === 1) return color;
  const [br, bg, bb, ba] = parseToRgba(background);
  const ao = a + ba * (1 - a);
  const ro = (a * r + ba * br * (1 - a)) / ao;
  const go = (a * g + ba * bg * (1 - a)) / ao;
  const bo = (a * b + ba * bb * (1 - a)) / ao;
  return `rgba(${ro}, ${go}, ${bo}, ${ao})`;
}
function interpolateColors(leftColor, rightColor, val) {
  if (val <= 0) return leftColor;
  if (val >= 1) return rightColor;
  const left = [...parseToRgba(leftColor)];
  left[0] = left[0] * left[3];
  left[1] = left[1] * left[3];
  left[2] = left[2] * left[3];
  const right = [...parseToRgba(rightColor)];
  right[0] = right[0] * right[3];
  right[1] = right[1] * right[3];
  right[2] = right[2] * right[3];
  const hScaler = val;
  const nScaler = 1 - val;
  const a = left[3] * nScaler + right[3] * hScaler;
  const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);
  const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);
  const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// src/data-grid/data-grid-render.tsx
var loadingCell = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};
function drawCell(ctx, row, cell, col, x, y, w, h, highlighted, theme, drawCustomCell, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, lastPrep, enqueue, getCellRenderer) {
  let hoverX;
  let hoverY;
  if (hoverInfo !== void 0 && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {
    hoverX = hoverInfo[1][0];
    hoverY = hoverInfo[1][1];
  }
  let result = void 0;
  const args = {
    ctx,
    theme,
    col,
    row,
    cell,
    rect: {
      x,
      y,
      width: w,
      height: h
    },
    highlighted,
    hoverAmount,
    hoverX,
    hoverY,
    imageLoader,
    spriteManager,
    hyperWrapping,
    requestAnimationFrame: () => {
      forceAnim = true;
    }
  };
  let forceAnim = false;
  const needsAnim = drawWithLastUpdate(args, cell.lastUpdated, frameTime, lastPrep, () => {
    var _a, _b;
    const drawn = isInnerOnlyCell(cell) ? false : (drawCustomCell == null ? void 0 : drawCustomCell(args)) === true;
    if (!drawn) {
      const r = getCellRenderer(cell);
      if (r !== void 0) {
        if ((lastPrep == null ? void 0 : lastPrep.renderer) !== r) {
          (_a = lastPrep == null ? void 0 : lastPrep.deprep) == null ? void 0 : _a.call(lastPrep, args);
          lastPrep = void 0;
        }
        const partialPrepResult = (_b = r.drawPrep) == null ? void 0 : _b.call(r, args, lastPrep);
        r.draw(args, cell);
        result = {
          deprep: partialPrepResult == null ? void 0 : partialPrepResult.deprep,
          fillStyle: partialPrepResult == null ? void 0 : partialPrepResult.fillStyle,
          font: partialPrepResult == null ? void 0 : partialPrepResult.font,
          renderer: r
        };
      }
    }
  });
  if (needsAnim || forceAnim) enqueue == null ? void 0 : enqueue([col, row]);
  return result;
}
function blitLastFrame(ctx, canvas, last, cellXOffset, cellYOffset, translateX, translateY, lastRowSticky, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {
  const drawRegions = [];
  let blittedYOnly = false;
  ctx.imageSmoothingEnabled = false;
  const minY = Math.min(last.cellYOffset, cellYOffset);
  const maxY = Math.max(last.cellYOffset, cellYOffset);
  let deltaY = 0;
  if (typeof getRowHeight === "number") {
    deltaY += (maxY - minY) * getRowHeight;
  } else {
    for (let i = minY; i < maxY; i++) {
      deltaY += getRowHeight(i);
    }
  }
  if (cellYOffset > last.cellYOffset) {
    deltaY = -deltaY;
  }
  deltaY += translateY - last.translateY;
  const minX = Math.min(last.cellXOffset, cellXOffset);
  const maxX = Math.max(last.cellXOffset, cellXOffset);
  let deltaX = 0;
  for (let i = minX; i < maxX; i++) {
    deltaX += mappedColumns[i].width;
  }
  if (cellXOffset > last.cellXOffset) {
    deltaX = -deltaX;
  }
  deltaX += translateX - last.translateX;
  let stickyWidth = getStickyWidth(effectiveCols);
  if (stickyWidth > 0) stickyWidth++;
  if (deltaX !== 0 && deltaY !== 0) {
    return {
      regions: [],
      yOnly: false
    };
  }
  const stickyRowHeight = lastRowSticky ? typeof getRowHeight === "number" ? getRowHeight : getRowHeight(rows - 1) : 0;
  const blitWidth = width - stickyWidth - Math.abs(deltaX);
  const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;
  if (blitWidth > 150 && blitHeight > 150) {
    blittedYOnly = deltaX === 0;
    const args = {
      sx: 0,
      sy: 0,
      sw: width * dpr,
      sh: height * dpr,
      dx: 0,
      dy: 0,
      dw: width * dpr,
      dh: height * dpr
    };
    if (deltaY > 0) {
      args.sy = (totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (deltaY + totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: totalHeaderHeight,
        width,
        height: deltaY + 1
      });
    } else if (deltaY < 0) {
      args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: height + deltaY - stickyRowHeight,
        width,
        height: -deltaY + stickyRowHeight
      });
    }
    if (deltaX > 0) {
      args.sx = stickyWidth * dpr;
      args.sw = blitWidth * dpr;
      args.dx = (deltaX + stickyWidth) * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: stickyWidth - 1,
        y: 0,
        width: deltaX + 2,
        height
      });
    } else if (deltaX < 0) {
      args.sx = (stickyWidth - deltaX) * dpr;
      args.sw = blitWidth * dpr;
      args.dx = stickyWidth * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: width + deltaX,
        y: 0,
        width: -deltaX,
        height
      });
    }
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (stickyWidth > 0 && deltaX !== 0 && deltaY === 0 && doubleBuffer) {
      ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);
    }
    ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);
    ctx.scale(dpr, dpr);
  }
  ctx.imageSmoothingEnabled = true;
  return {
    regions: drawRegions,
    yOnly: blittedYOnly
  };
}
function blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {
  const drawRegions = [];
  if (cellXOffset !== last.cellXOffset || cellYOffset !== last.cellYOffset || translateX !== last.translateX || translateY !== last.translateY) {
    return drawRegions;
  }
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {
    if (c.sourceIndex === resizedIndex) {
      const x = Math.max(drawX, clipX) + 1;
      drawRegions.push({
        x,
        y: 0,
        width: width - x,
        height
      });
      return true;
    }
  });
  return drawRegions;
}
function drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme) {
  let verticalOnly = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : false;
  var _a, _b, _c;
  if (spans !== void 0) {
    ctx.beginPath();
    ctx.save();
    ctx.rect(0, 0, width, height);
    for (const span of spans) {
      ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);
    }
    ctx.clip("evenodd");
  }
  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  let minX = 0;
  let maxX = width;
  let minY = 0;
  let maxY = height;
  if (drawRegions !== void 0 && drawRegions.length > 0) {
    minX = Number.MAX_SAFE_INTEGER;
    minY = Number.MAX_SAFE_INTEGER;
    maxX = Number.MIN_SAFE_INTEGER;
    maxY = Number.MIN_SAFE_INTEGER;
    for (const r of drawRegions) {
      minX = Math.min(minX, r.x - 1);
      maxX = Math.max(maxX, r.x + r.width + 1);
      minY = Math.min(minY, r.y - 1);
      maxY = Math.max(maxY, r.y + r.height + 1);
    }
  }
  const toDraw = [];
  ctx.beginPath();
  let x = 0.5;
  for (let index = 0; index < effectiveCols.length; index++) {
    const c = effectiveCols[index];
    if (c.width === 0) continue;
    x += c.width;
    const tx = c.sticky ? x : x + translateX;
    if (tx >= minX && tx <= maxX && verticalBorder(index + 1)) {
      toDraw.push({
        x1: tx,
        y1: Math.max(groupHeaderHeight, minY),
        x2: tx,
        y2: Math.min(height, maxY),
        color: vColor
      });
    }
  }
  const stickyHeight = getRowHeight(rows - 1);
  const stickyRowY = height - stickyHeight + 0.5;
  const lastRowSticky = trailingRowType === "sticky";
  if (lastRowSticky) {
    toDraw.push({
      x1: minX,
      y1: stickyRowY,
      x2: maxX,
      y2: stickyRowY,
      color: hColor
    });
  }
  if (verticalOnly !== true) {
    let y = totalHeaderHeight + 0.5;
    let row = cellYOffset;
    const target = lastRowSticky ? height - stickyHeight : height;
    while (y + translateY <= target) {
      const ty = y + translateY;
      if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {
        const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
        toDraw.push({
          x1: minX,
          y1: ty,
          x2: maxX,
          y2: ty,
          color: (_c = (_b = rowTheme == null ? void 0 : rowTheme.horizontalBorderColor) != null ? _b : rowTheme == null ? void 0 : rowTheme.borderColor) != null ? _c : hColor
        });
      }
      y += getRowHeight(row);
      row++;
    }
  }
  const groups = lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__(toDraw, line => line.color);
  for (const g of Object.keys(groups)) {
    ctx.strokeStyle = g;
    for (const line of groups[g]) {
      ctx.moveTo(line.x1, line.y1);
      ctx.lineTo(line.x2, line.y2);
    }
    ctx.stroke();
    ctx.beginPath();
  }
  if (spans !== void 0) {
    ctx.restore();
  }
}
function getActionBoundsForGroup(box, actions) {
  const result = [];
  let x = box.x + box.width - 26 * actions.length;
  const y = box.y + box.height / 2 - 13;
  const height = 26;
  const width = 26;
  for (let i = 0; i < actions.length; i++) {
    result.push({
      x,
      y,
      width,
      height
    });
    x += 26;
  }
  return result;
}
function pointInRect(rect, x, y) {
  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
}
function drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {
  var _a;
  const xPad = 8;
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  let finalX = 0;
  walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {
    var _a2, _b;
    if (damage !== void 0 && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    const group = getGroupDetails(groupName);
    const groupTheme = (group == null ? void 0 : group.overrideTheme) === void 0 ? theme : {
      ...theme,
      ...group.overrideTheme
    };
    const isHovered = hRow === -2 && hCol !== void 0 && hCol >= span[0] && hCol <= span[1];
    const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;
    if (fillColor !== theme.bgHeader) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    ctx.fillStyle = (_a2 = groupTheme.textGroupHeader) != null ? _a2 : groupTheme.textHeader;
    if (group !== void 0) {
      let drawX = x;
      if (group.icon !== void 0) {
        spriteManager.drawSprite(group.icon, "normal", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);
        drawX += 26;
      }
      ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));
      if (group.actions !== void 0 && isHovered) {
        const actionBoxes = getActionBoundsForGroup({
          x,
          y,
          width: w,
          height: h
        }, group.actions);
        ctx.beginPath();
        const fadeStartX = actionBoxes[0].x - 10;
        const fadeWidth = x + w - fadeStartX;
        ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);
        const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);
        const trans = withAlpha(fillColor, 0);
        grad.addColorStop(0, trans);
        grad.addColorStop(10 / fadeWidth, fillColor);
        grad.addColorStop(1, fillColor);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 0.6;
        const [mouseX, mouseY] = (_b = hovered == null ? void 0 : hovered[1]) != null ? _b : [-1, -1];
        for (let i = 0; i < group.actions.length; i++) {
          const action = group.actions[i];
          const box = actionBoxes[i];
          const actionHovered = pointInRect(box, mouseX + x, mouseY);
          if (actionHovered) {
            ctx.globalAlpha = 1;
          }
          spriteManager.drawSprite(action.icon, "normal", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);
          if (actionHovered) {
            ctx.globalAlpha = 0.6;
          }
        }
        ctx.globalAlpha = 1;
      }
    }
    if (x !== 0 && verticalBorder(span[0])) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, groupHeaderHeight);
      ctx.strokeStyle = theme.borderColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
    finalX = x + w;
  });
  ctx.beginPath();
  ctx.moveTo(finalX + 0.5, 0);
  ctx.lineTo(finalX + 0.5, groupHeaderHeight);
  ctx.moveTo(0, groupHeaderHeight + 0.5);
  ctx.lineTo(width, groupHeaderHeight + 0.5);
  ctx.strokeStyle = theme.borderColor;
  ctx.lineWidth = 1;
  ctx.stroke();
}
var menuButtonSize = 30;
function getHeaderMenuBounds(x, y, width, height) {
  return {
    x: x + width - menuButtonSize,
    y: Math.max(y, y + height / 2 - menuButtonSize / 2),
    width: menuButtonSize,
    height: Math.min(menuButtonSize, height)
  };
}
function drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {
  const isCheckboxHeader = c.title.startsWith(headerCellCheckboxPrefix);
  const menuBounds = getHeaderMenuBounds(x, y, width, height);
  if (drawHeaderCallback !== void 0) {
    let passCol = c;
    if (isCheckboxHeader) {
      passCol = {
        ...c,
        title: ""
      };
    }
    if (drawHeaderCallback({
      ctx,
      theme,
      rect: {
        x,
        y,
        width,
        height
      },
      column: passCol,
      columnIndex: passCol.sourceIndex,
      isSelected: selected,
      hoverAmount,
      isHovered,
      hasSelectedCell,
      spriteManager,
      menuBounds
    })) {
      return;
    }
  }
  if (isCheckboxHeader) {
    let checked = void 0;
    if (c.title === headerCellCheckedMarker) checked = true;
    if (c.title === headerCellUnheckedMarker) checked = false;
    if (checked !== true) {
      ctx.globalAlpha = hoverAmount;
    }
    drawCheckbox(ctx, theme, checked, x, y, width, height, false, void 0, void 0);
    if (checked !== true) {
      ctx.globalAlpha = 1;
    }
    return;
  }
  const xPad = theme.cellHorizontalPadding;
  const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;
  const shouldDrawMenu = c.hasMenu === true && (isHovered || touchMode && selected);
  let drawX = x + xPad;
  if (c.icon !== void 0) {
    let variant = selected ? "selected" : "normal";
    if (c.style === "highlight") {
      variant = selected ? "selected" : "special";
    }
    const headerSize = theme.headerIconSize;
    spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - headerSize) / 2, headerSize, theme);
    if (c.overlayIcon !== void 0) {
      spriteManager.drawSprite(c.overlayIcon, selected ? "selected" : "special", ctx, drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);
    }
    drawX += Math.ceil(headerSize * 1.3);
  }
  if (shouldDrawMenu && c.hasMenu === true && width > 35) {
    const fadeWidth = 35;
    const fadeStart = width - fadeWidth;
    const fadeEnd = width - fadeWidth * 0.7;
    const fadeStartPercent = fadeStart / width;
    const fadeEndPercent = fadeEnd / width;
    const grad = ctx.createLinearGradient(x, 0, x + width, 0);
    const trans = withAlpha(fillStyle, 0);
    grad.addColorStop(0, fillStyle);
    grad.addColorStop(fadeStartPercent, fillStyle);
    grad.addColorStop(fadeEndPercent, trans);
    grad.addColorStop(1, trans);
    ctx.fillStyle = grad;
  } else {
    ctx.fillStyle = fillStyle;
  }
  ctx.fillText(c.title, drawX, y + height / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));
  if (shouldDrawMenu && c.hasMenu === true) {
    ctx.beginPath();
    const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;
    const triangleY = menuBounds.y + menuBounds.height / 2 - 3;
    roundedPoly(ctx, [{
      x: triangleX,
      y: triangleY
    }, {
      x: triangleX + 11,
      y: triangleY
    }, {
      x: triangleX + 5.5,
      y: triangleY + 6
    }], 1);
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}
function drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {
  var _a;
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (totalHeaderHeight <= 0) return;
  ctx.fillStyle = outerTheme.bgHeader;
  ctx.fillRect(0, 0, width, totalHeaderHeight);
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {
    var _a2, _b, _c;
    if (damage !== void 0 && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;
    const diff = Math.max(0, clipX - x);
    ctx.save();
    ctx.beginPath();
    ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);
    ctx.clip();
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const theme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : {
      ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    if (theme.bgHeader !== outerTheme.bgHeader) {
      ctx.fillStyle = theme.bgHeader;
      ctx.fill();
    }
    const f = `${theme.headerFontStyle} ${theme.fontFamily}`;
    if (font !== f) {
      ctx.font = f;
    }
    const selected = selection.columns.hasIndex(c.sourceIndex);
    const noHover = dragAndDropState !== void 0 || isResizing;
    const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;
    const hover = noHover ? 0 : (_c = (_b = hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)) == null ? void 0 : _b.hoverAmount) != null ? _c : 0;
    const hasSelectedCell = (selection == null ? void 0 : selection.current) !== void 0 && selection.current.cell[0] === c.sourceIndex;
    const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;
    const y = enableGroups ? groupHeaderHeight : 0;
    const xOffset = c.sourceIndex === 0 ? 0 : 1;
    if (selected) {
      ctx.fillStyle = bgFillStyle;
      ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);
    } else if (hasSelectedCell || hover > 0) {
      ctx.beginPath();
      ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);
      if (hasSelectedCell) {
        ctx.fillStyle = theme.bgHeaderHasFocus;
        ctx.fill();
      }
      if (hover > 0) {
        ctx.globalAlpha = hover;
        ctx.fillStyle = theme.bgHeaderHovered;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);
    ctx.restore();
  });
  if (enableGroups) {
    drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);
  }
}
function intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
}
function clipDamage(ctx, effectiveColumns, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, includeCells) {
  if (damage === void 0 || damage.length === 0) return;
  const stickyRowHeight = trailingRowType === "sticky" ? getRowHeight(rows - 1) : 0;
  ctx.beginPath();
  walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];
      if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {
        ctx.rect(x, y, w, h);
        break;
      }
    }
  });
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    const diff = Math.max(0, clipX - drawX);
    const finalX = drawX + diff + 1;
    const finalWidth = c.width - diff - 1;
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];
      if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === void 0)) {
        ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);
        break;
      }
    }
    if (!includeCells) return;
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      let isDamaged = false;
      for (let i = 0; i < damage.length; i++) {
        const d = damage[i];
        if (d[0] === c.sourceIndex && d[1] === row) {
          isDamaged = true;
          break;
        }
      }
      if (isDamaged) {
        const top = drawY + 1;
        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);
        const h = bottom - top;
        if (h > 0) {
          ctx.rect(finalX, top, finalWidth, h);
        }
      }
    });
  });
  ctx.clip();
}
function getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {
  var _a, _b;
  const [startCol, endCol] = span;
  let frozenRect;
  let contentRect;
  const firstNonSticky = (_b = (_a = allColumns.find(x => !x.sticky)) == null ? void 0 : _a.sourceIndex) != null ? _b : 0;
  if (endCol > firstNonSticky) {
    const renderFromCol = Math.max(startCol, firstNonSticky);
    let tempX = cellX;
    let tempW = cellW;
    for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }
    for (let x = column.sourceIndex + 1; x <= endCol; x++) {
      tempW += allColumns[x].width;
    }
    contentRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }
  if (firstNonSticky > startCol) {
    const renderToCol = Math.min(endCol, firstNonSticky - 1);
    let tempX = cellX;
    let tempW = cellW;
    for (let x = column.sourceIndex - 1; x >= startCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }
    for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {
      tempW += allColumns[x].width;
    }
    frozenRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }
  return [frozenRect, contentRect];
}
function drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, outerTheme, enqueue, getCellRenderer) {
  var _a;
  let toDraw = (_a = damage == null ? void 0 : damage.length) != null ? _a : Number.MAX_SAFE_INTEGER;
  const frameTime = performance.now();
  let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  let result;
  const handledSpans = /* @__PURE__ */new Set();
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {
    var _a2;
    const diff = Math.max(0, clipX - drawX);
    const colDrawX = drawX + diff;
    const colDrawY = totalHeaderHeight + 1;
    const colWidth = c.width - diff;
    const colHeight = height - totalHeaderHeight - 1;
    if (drawRegions.length > 0) {
      let found = false;
      for (let i = 0; i < drawRegions.length; i++) {
        const dr = drawRegions[i];
        if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {
          found = true;
          break;
        }
      }
      if (!found) return;
    }
    const reclip = () => {
      ctx.save();
      ctx.beginPath();
      ctx.rect(colDrawX, colDrawY, colWidth, colHeight);
      ctx.clip();
    };
    const colSelected = selection.columns.hasIndex(c.sourceIndex);
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const colTheme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : {
      ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;
    if (colFont !== font) {
      font = colFont;
      ctx.font = colFont;
    }
    reclip();
    let prepResult = void 0;
    walkRowsInCol(startRow, colDrawStartY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky, isTrailingRow) => {
      var _a3, _b, _c, _d;
      if (row < 0) return;
      if (damage !== void 0) {
        let found = false;
        for (let i = 0; i < damage.length; i++) {
          const d = damage[i];
          if (d[0] === c.sourceIndex && d[1] === row) {
            found = true;
            break;
          }
        }
        if (!found) return;
      }
      if (drawRegions.length > 0) {
        let found = false;
        for (let i = 0; i < drawRegions.length; i++) {
          const dr = drawRegions[i];
          if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {
            found = true;
            break;
          }
        }
        if (!found) return;
      }
      const rowSelected = selection.rows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      const cell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;
      let cellX = drawX;
      let cellWidth = c.width;
      let drawingSpan = false;
      let skipContents = false;
      if (cell.span !== void 0) {
        const [startCol, endCol] = cell.span;
        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;
        if (!handledSpans.has(spanKey)) {
          const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);
          const area = c.sticky ? areas[0] : areas[1];
          if (!c.sticky && areas[0] !== void 0) {
            skipContents = true;
          }
          if (area !== void 0) {
            cellX = area.x;
            cellWidth = area.width;
            handledSpans.add(spanKey);
            ctx.restore();
            prepResult = void 0;
            ctx.save();
            ctx.beginPath();
            const d = Math.max(0, clipX - area.x);
            ctx.rect(area.x + d, drawY, area.width - d, rh);
            if (result === void 0) {
              result = [];
            }
            result.push({
              x: area.x + d,
              y: drawY,
              width: area.width - d,
              height: rh
            });
            ctx.clip();
            drawingSpan = true;
          }
        } else {
          toDraw--;
          return;
        }
      }
      const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
      const trailingTheme = isTrailingRow && ((_a3 = c.trailingRowOptions) == null ? void 0 : _a3.themeOverride) !== void 0 ? (_b = c.trailingRowOptions) == null ? void 0 : _b.themeOverride : void 0;
      const theme = cell.themeOverride === void 0 && rowTheme === void 0 && trailingTheme === void 0 ? colTheme : {
        ...colTheme,
        ...rowTheme,
        ...trailingTheme,
        ...cell.themeOverride
      };
      ctx.beginPath();
      const cellIndex = [c.sourceIndex, row];
      const isSelected = cellIsSelected(cellIndex, cell, selection);
      let accentCount = cellIsInRange(cellIndex, cell, selection);
      const spanIsHighlighted = cell.span !== void 0 && selection.columns.some(index => cell.span !== void 0 && index >= cell.span[0] && index <= cell.span[1]);
      if (isSelected && !isFocused && drawFocus) {
        accentCount = 0;
      } else if (isSelected) {
        accentCount = Math.max(accentCount, 1);
      }
      if (spanIsHighlighted) {
        accentCount++;
      }
      if (!isSelected) {
        if (rowSelected) accentCount++;
        if (colSelected && !isSticky) accentCount++;
      }
      const bgCell = cell.kind === GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;
      let fill;
      if (isSticky || bgCell !== outerTheme.bgCell) {
        fill = blend(bgCell, fill);
      }
      if (accentCount > 0 || rowDisabled) {
        if (rowDisabled) {
          fill = blend(theme.bgHeader, fill);
        }
        for (let i = 0; i < accentCount; i++) {
          fill = blend(theme.accentLight, fill);
        }
      } else {
        if ((prelightCells == null ? void 0 : prelightCells.some(pre => pre[0] === c.sourceIndex && pre[1] === row)) === true) {
          fill = blend(theme.bgSearchResult, fill);
        }
      }
      if (highlightRegions !== void 0) {
        for (const region of highlightRegions) {
          const r = region.range;
          if (r.x <= c.sourceIndex && c.sourceIndex < r.x + r.width && r.y <= row && row < r.y + r.height) {
            fill = blend(region.color, fill);
          }
        }
      }
      if (fill !== void 0) {
        ctx.fillStyle = fill;
        if (prepResult !== void 0) {
          prepResult.fillStyle = fill;
        }
        ctx.fillRect(cellX, drawY, cellWidth, rh);
      }
      if (cell.style === "faded") {
        ctx.globalAlpha = 0.6;
      }
      const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);
      if (cellWidth > 10 && !skipContents) {
        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;
        if (cellFont !== font) {
          ctx.font = cellFont;
          font = cellFont;
        }
        prepResult = drawCell(ctx, row, cell, c.sourceIndex, cellX, drawY, cellWidth, rh, accentCount > 0, theme, drawCustomCell, imageLoader, spriteManager, (_c = hoverValue == null ? void 0 : hoverValue.hoverAmount) != null ? _c : 0, hoverInfo, hyperWrapping, frameTime, prepResult, enqueue, getCellRenderer);
      }
      if (cell.style === "faded") {
        ctx.globalAlpha = 1;
      }
      toDraw--;
      if (drawingSpan) {
        ctx.restore();
        (_d = prepResult == null ? void 0 : prepResult.deprep) == null ? void 0 : _d.call(prepResult, {
          ctx
        });
        prepResult = void 0;
        reclip();
        font = colFont;
        ctx.font = colFont;
      }
      return toDraw <= 0;
    });
    ctx.restore();
    return toDraw <= 0;
  });
  return result;
}
function drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, trailingRowType, drawRegions, damage, theme) {
  if (damage !== void 0 || effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]) return;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    if (c !== effectiveColumns[effectiveColumns.length - 1]) return;
    drawX += c.width;
    const x = Math.max(drawX, clipX);
    if (x > width) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, totalHeaderHeight + 1, 1e4, height - totalHeaderHeight - 1);
    ctx.clip();
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      if (!isSticky && drawRegions.length > 0 && !drawRegions.some(dr => intersectRect(drawX, drawY, 1e4, rh, dr.x, dr.y, dr.width, dr.height))) {
        return;
      }
      const rowSelected = selectedRows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      ctx.beginPath();
      const rowTheme = getRowTheme == null ? void 0 : getRowTheme(row);
      const blankTheme = rowTheme === void 0 ? theme : {
        ...theme,
        ...rowTheme
      };
      if (blankTheme.bgCell !== theme.bgCell) {
        ctx.fillStyle = blankTheme.bgCell;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }
      if (rowDisabled) {
        ctx.fillStyle = blankTheme.bgHeader;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }
      if (rowSelected) {
        ctx.fillStyle = blankTheme.accentLight;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }
    });
    ctx.restore();
  });
}
function overdrawStickyBoundaries(ctx, effectiveCols, width, height, lastRowSticky, rows, verticalBorder, getRowHeight, theme) {
  var _a;
  let drawFreezeBorder = false;
  for (const c of effectiveCols) {
    if (c.sticky) continue;
    drawFreezeBorder = verticalBorder(c.sourceIndex);
    break;
  }
  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  const drawX = drawFreezeBorder ? getStickyWidth(effectiveCols) : 0;
  if (drawX !== 0) {
    ctx.beginPath();
    ctx.moveTo(drawX + 0.5, 0);
    ctx.lineTo(drawX + 0.5, height);
    ctx.strokeStyle = blend(vColor, theme.bgCell);
    ctx.stroke();
  }
  if (lastRowSticky) {
    const h = getRowHeight(rows - 1);
    ctx.beginPath();
    ctx.moveTo(0, height - h + 0.5);
    ctx.lineTo(width, height - h + 0.5);
    ctx.strokeStyle = blend(hColor, theme.bgCell);
    ctx.stroke();
  }
}
function drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, lastRowSticky, rows, allHighlightRegions) {
  const highlightRegions = allHighlightRegions == null ? void 0 : allHighlightRegions.filter(x => x.style !== "no-outline");
  if (highlightRegions === void 0 || highlightRegions.length === 0) return void 0;
  const drawRects = highlightRegions.map(h => {
    var _a, _b, _c, _d, _e;
    const r = h.range;
    const topLeftBounds = computeBounds(r.x, r.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
    if (r.width === 1 && r.height === 1) {
      if (r.x < freezeColumns) {
        return [{
          color: h.color,
          style: (_a = h.style) != null ? _a : "dashed",
          rect: topLeftBounds
        }, void 0];
      }
      return [void 0, {
        color: h.color,
        style: (_b = h.style) != null ? _b : "dashed",
        rect: topLeftBounds
      }];
    }
    const bottomRightBounds = computeBounds(r.x + r.width - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
    if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {
      const freezeSectionRightBounds = computeBounds(freezeColumns - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      const unfreezeSectionleftBounds = computeBounds(freezeColumns, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      return [{
        color: h.color,
        style: (_c = h.style) != null ? _c : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,
          height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y
        }
      }, {
        color: h.color,
        style: (_d = h.style) != null ? _d : "dashed",
        rect: {
          x: unfreezeSectionleftBounds.x,
          y: unfreezeSectionleftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y
        }
      }];
    } else {
      return [void 0, {
        color: h.color,
        style: (_e = h.style) != null ? _e : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y
        }
      }];
    }
  });
  const stickyWidth = getStickyWidth(mappedColumns);
  const drawCb = () => {
    ctx.beginPath();
    ctx.save();
    let dashed = false;
    const setDashed = dash => {
      if (dashed === dash) return;
      ctx.setLineDash(dash ? [5, 3] : []);
      dashed = dash;
    };
    ctx.lineWidth = 1;
    for (const dr of drawRects) {
      const [s] = dr;
      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }
    let clipped = false;
    for (const dr of drawRects) {
      const [, s] = dr;
      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        if (!clipped && s.rect.x < stickyWidth) {
          ctx.rect(stickyWidth, 0, width, height);
          ctx.clip();
          clipped = true;
        }
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }
    ctx.restore();
  };
  drawCb();
  return drawCb;
}
function drawFocusRing(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) {
  var _a;
  if (selectedCell.current === void 0 || !effectiveCols.some(c => {
    var _a2;
    return c.sourceIndex === ((_a2 = selectedCell.current) == null ? void 0 : _a2.cell[0]);
  })) return void 0;
  const [targetCol, targetRow] = selectedCell.current.cell;
  const cell = getCellContent(selectedCell.current.cell);
  const targetColSpan = (_a = cell.span) != null ? _a : [targetCol, targetCol];
  const isStickyRow = trailingRowType === "sticky" && targetRow === rows - 1;
  const stickRowHeight = trailingRowType === "sticky" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;
  let drawCb = void 0;
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {
    if (col.sticky && targetCol > col.sourceIndex) return;
    if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {
      return;
    }
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {
      if (row !== targetRow) return;
      let cellX = drawX;
      let cellWidth = col.width;
      if (cell.span !== void 0) {
        const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);
        const area = col.sticky ? areas[0] : areas[1];
        if (area !== void 0) {
          cellX = area.x;
          cellWidth = area.width;
        }
      }
      drawCb = () => {
        var _a2, _b, _c, _d;
        if (clipX > cellX && !col.sticky) {
          ctx.beginPath();
          ctx.rect(clipX, 0, width - clipX, height);
          ctx.clip();
        }
        ctx.beginPath();
        ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);
        ctx.strokeStyle = (_b = (_a2 = col.themeOverride) == null ? void 0 : _a2.accentColor) != null ? _b : theme.accentColor;
        ctx.lineWidth = 1;
        ctx.stroke();
        if (fillHandle) {
          ctx.beginPath();
          ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);
          ctx.fillStyle = (_d = (_c = col.themeOverride) == null ? void 0 : _c.accentColor) != null ? _d : theme.accentColor;
          ctx.fill();
        }
      };
      return true;
    });
    return true;
  });
  if (drawCb === void 0) return void 0;
  const result = () => {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);
    ctx.clip();
    drawCb == null ? void 0 : drawCb();
    ctx.restore();
  };
  result();
  return result;
}
function getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType) {
  let result = 0;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (_drawY, row, _rh, isSticky) => {
      if (!isSticky) {
        result = Math.max(row, result);
      }
    });
    return true;
  });
  return result;
}
function computeCanBlit(current, last) {
  if (last === void 0) return false;
  if (current.width !== last.width || current.height !== last.height || current.theme !== last.theme || current.headerHeight !== last.headerHeight || current.rowHeight !== last.rowHeight || current.rows !== last.rows || current.getRowThemeOverride !== last.getRowThemeOverride || current.isFocused !== last.isFocused || current.isResizing !== last.isResizing || current.verticalBorder !== last.verticalBorder || current.getCellContent !== last.getCellContent || current.highlightRegions !== last.highlightRegions || current.selection !== last.selection || current.dragAndDropState !== last.dragAndDropState || current.prelightCells !== last.prelightCells || current.touchMode !== last.touchMode || current.scrolling !== last.scrolling) {
    return false;
  }
  if (current.mappedColumns !== last.mappedColumns) {
    if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {
      return false;
    }
    let resized;
    for (let i = 0; i < current.mappedColumns.length; i++) {
      const curCol = current.mappedColumns[i];
      const lastCol = last.mappedColumns[i];
      if (deepEqual(curCol, lastCol)) continue;
      if (resized !== void 0) return false;
      if (curCol.width === lastCol.width) return false;
      const {
        width,
        ...curRest
      } = curCol;
      const {
        width: lastWidth,
        ...lastRest
      } = lastCol;
      if (!deepEqual(curRest, lastRest)) return false;
      resized = i;
    }
    if (resized === void 0) {
      return true;
    }
    return resized;
  }
  return true;
}
function drawGrid(arg, lastArg) {
  var _a, _b;
  const {
    canvas,
    headerCanvas,
    width,
    height,
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mappedColumns,
    enableGroups,
    freezeColumns,
    dragAndDropState,
    theme,
    drawFocus,
    headerHeight,
    groupHeaderHeight,
    disabledRows,
    rowHeight,
    verticalBorder,
    isResizing,
    selection,
    fillHandle,
    lastRowSticky: trailingRowType,
    rows,
    getCellContent,
    getGroupDetails,
    getRowThemeOverride,
    isFocused,
    drawCustomCell,
    drawHeaderCallback,
    prelightCells,
    highlightRegions,
    imageLoader,
    lastBlitData,
    hoverValues,
    hyperWrapping,
    hoverInfo,
    spriteManager,
    scrolling,
    touchMode,
    enqueue,
    getCellRenderer,
    renderStrategy,
    bufferA,
    bufferB
  } = arg;
  let {
    damage
  } = arg;
  if (width === 0 || height === 0) return;
  const doubleBuffer = renderStrategy === "double-buffer";
  const dpr = scrolling ? 1 : Math.ceil((_a = window.devicePixelRatio) != null ? _a : 1);
  const canBlit = renderStrategy !== "direct" && computeCanBlit(arg, lastArg);
  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
  }
  const overlayCanvas = headerCanvas;
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const overlayHeight = totalHeaderHeight + 1;
  if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {
    overlayCanvas.width = width * dpr;
    overlayCanvas.height = overlayHeight * dpr;
    overlayCanvas.style.width = width + "px";
    overlayCanvas.style.height = overlayHeight + "px";
  }
  if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {
    bufferA.width = width * dpr;
    bufferA.height = height * dpr;
  }
  if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {
    bufferB.width = width * dpr;
    bufferB.height = height * dpr;
  }
  const last = lastBlitData.current;
  if (canBlit === true && cellXOffset === (last == null ? void 0 : last.cellXOffset) && cellYOffset === (last == null ? void 0 : last.cellYOffset) && translateX === (last == null ? void 0 : last.translateX) && translateY === (last == null ? void 0 : last.translateY)) return;
  let mainCtx = null;
  if (doubleBuffer) {
    mainCtx = canvas.getContext("2d", {
      alpha: false
    });
  }
  const overlayCtx = overlayCanvas.getContext("2d", {
    alpha: false
  });
  let targetBuffer;
  if (!doubleBuffer) {
    targetBuffer = canvas;
  } else if (damage !== void 0) {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferB : bufferA;
  } else {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferA : bufferB;
  }
  const targetCtx = targetBuffer.getContext("2d", {
    alpha: false
  });
  const blitSource = doubleBuffer ? targetBuffer === bufferA ? bufferB : bufferA : canvas;
  if (overlayCtx === null || targetCtx === null) return;
  const getRowHeight = typeof rowHeight === "number" ? () => rowHeight : rowHeight;
  overlayCtx.save();
  overlayCtx.beginPath();
  targetCtx.save();
  targetCtx.beginPath();
  overlayCtx.textBaseline = "middle";
  targetCtx.textBaseline = "middle";
  if (dpr !== 1) {
    overlayCtx.scale(dpr, dpr);
    targetCtx.scale(dpr, dpr);
  }
  const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
  let drawRegions = [];
  const mustDrawFocusOnHeader = drawFocus && ((_b = selection.current) == null ? void 0 : _b.cell[1]) === cellYOffset && translateY === 0;
  const drawHeaderTexture = () => {
    var _a2, _b2;
    drawGridHeaders(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);
    drawGridLines(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, void 0, void 0, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme, true);
    overlayCtx.beginPath();
    overlayCtx.moveTo(0, overlayHeight - 0.5);
    overlayCtx.lineTo(width, overlayHeight - 0.5);
    overlayCtx.strokeStyle = blend((_b2 = (_a2 = theme.headerBottomBorderColor) != null ? _a2 : theme.horizontalBorderColor) != null ? _b2 : theme.borderColor, theme.bgHeader);
    overlayCtx.stroke();
    if (mustDrawFocusOnHeader) {
      drawFocusRing(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
    }
  };
  if (damage !== void 0) {
    let doHeaders = false;
    damage = damage.filter(x => {
      doHeaders = doHeaders || x[1] < 0;
      return x[1] < 0 || intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) || intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) || trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1);
    });
    if (damage.length > 0) {
      clipDamage(targetCtx, effectiveCols, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, true);
      targetCtx.fillStyle = theme.bgCell;
      targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);
      drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
      if (fillHandle && drawFocus && selection.current !== void 0 && damage.some(x => {
        var _a2, _b2;
        return x[0] === ((_a2 = selection.current) == null ? void 0 : _a2.cell[0]) && x[1] === ((_b2 = selection.current) == null ? void 0 : _b2.cell[1]);
      })) {
        drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
      }
    }
    if (doHeaders) {
      clipDamage(overlayCtx, effectiveCols, width, totalHeaderHeight, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, false);
      drawHeaderTexture();
    }
    targetCtx.restore();
    overlayCtx.restore();
    if (mainCtx !== null) {
      mainCtx.fillStyle = theme.bgCell;
      mainCtx.fillRect(0, 0, width, height);
      mainCtx.drawImage(targetCtx.canvas, 0, 0);
    }
    return;
  }
  if (canBlit !== true || cellXOffset !== (last == null ? void 0 : last.cellXOffset) || translateX !== (last == null ? void 0 : last.translateX) || mustDrawFocusOnHeader !== (last == null ? void 0 : last.mustDrawFocusOnHeader)) {
    drawHeaderTexture();
  }
  if (canBlit === true) {
    assert(blitSource !== void 0 && last !== void 0);
    const {
      regions
    } = blitLastFrame(targetCtx, blitSource, last, cellXOffset, cellYOffset, translateX, translateY, trailingRowType === "sticky", width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);
    drawRegions = regions;
  } else if (canBlit !== false) {
    assert(last !== void 0);
    const resizedCol = canBlit;
    drawRegions = blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);
  }
  overdrawStickyBoundaries(targetCtx, effectiveCols, width, height, trailingRowType === "sticky", rows, verticalBorder, getRowHeight, theme);
  const focusRedraw = drawFocus ? drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) : void 0;
  const highlightRedraw = drawHighlightRings(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, trailingRowType === "sticky", rows, highlightRegions);
  targetCtx.fillStyle = theme.bgCell;
  if (drawRegions.length > 0) {
    targetCtx.beginPath();
    for (const r of drawRegions) {
      targetCtx.rect(r.x, r.y, r.width, r.height);
    }
    targetCtx.clip();
    targetCtx.fill();
    targetCtx.beginPath();
  } else {
    targetCtx.fillRect(0, 0, width, height);
  }
  const spans = drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
  drawBlanks(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, trailingRowType, drawRegions, damage, theme);
  drawGridLines(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme);
  focusRedraw == null ? void 0 : focusRedraw();
  highlightRedraw == null ? void 0 : highlightRedraw();
  if (mainCtx !== null) {
    mainCtx.fillStyle = theme.bgCell;
    mainCtx.fillRect(0, 0, width, height);
    mainCtx.drawImage(targetCtx.canvas, 0, 0);
  }
  const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType);
  imageLoader == null ? void 0 : imageLoader.setWindow({
    x: cellXOffset,
    y: cellYOffset,
    width: effectiveCols.length,
    height: lastRowDrawn - cellYOffset
  }, freezeColumns);
  lastBlitData.current = {
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mustDrawFocusOnHeader,
    lastBuffer: doubleBuffer ? targetBuffer === bufferA ? "a" : "b" : void 0
  };
  targetCtx.restore();
  overlayCtx.restore();
}
function walkRowsInCol(startRow, drawY, height, rows, getRowHeight, trailingRowType, cb) {
  let y = drawY;
  let row = startRow;
  let doSticky = trailingRowType === "sticky";
  while (y < height || doSticky) {
    const doingSticky = doSticky && y >= height;
    if (doingSticky) {
      doSticky = false;
      row = rows - 1;
    }
    const rh = getRowHeight(row);
    if (doingSticky) {
      y = height - rh;
    }
    const isMovedStickyRow = doSticky && row === rows - 1;
    if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== "none" && row === rows - 1) === true) {
      break;
    }
    if (doingSticky) {
      break;
    }
    y += rh;
    row++;
  }
}
function walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;
  const drawY = totalHeaderHeight + translateY;
  for (const c of effectiveCols) {
    const drawX = c.sticky ? clipX : x + translateX;
    if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {
      break;
    }
    x += c.width;
    clipX += c.sticky ? c.width : 0;
  }
}
function walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {
  var _a;
  let x = 0;
  let clipX = 0;
  for (let index = 0; index < effectiveCols.length; index++) {
    const startCol = effectiveCols[index];
    let end = index + 1;
    let boxWidth = startCol.width;
    if (startCol.sticky) {
      clipX += boxWidth;
    }
    while (end < effectiveCols.length && isGroupEqual(effectiveCols[end].group, startCol.group) && effectiveCols[end].sticky === effectiveCols[index].sticky) {
      const endCol = effectiveCols[end];
      boxWidth += endCol.width;
      end++;
      index++;
      if (endCol.sticky) {
        clipX += endCol.width;
      }
    }
    const t = startCol.sticky ? 0 : translateX;
    const localX = x + t;
    const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);
    const w = Math.min(boxWidth - delta, width - (localX + delta));
    cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], (_a = startCol.group) != null ? _a : "", localX + delta, 0, w, groupHeaderHeight);
    x += boxWidth;
  }
}

// src/data-grid/animation-manager.ts

var hoverTime = 80;
function easeOutCubic(x) {
  const x1 = x - 1;
  return x1 * x1 * x1 + 1;
}
var AnimationManager = class {
  constructor(callback) {
    this.callback = callback;
    this.currentHoveredItem = void 0;
    this.leavingItems = [];
    this.areSameItems = (left, right) => {
      return (left == null ? void 0 : left[0]) === (right == null ? void 0 : right[0]) && (left == null ? void 0 : left[1]) === (right == null ? void 0 : right[1]);
    };
    this.addToLeavingItems = item => {
      const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));
      if (isAlreadyLeaving) {
        return;
      }
      this.leavingItems.push(item);
    };
    this.removeFromLeavingItems = item => {
      var _a;
      const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));
      this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);
      return (_a = leavingItem == null ? void 0 : leavingItem.hoverAmount) != null ? _a : 0;
    };
    this.cleanUpLeavingElements = () => {
      this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);
    };
    this.shouldStep = () => {
      const hasLeavingItems = this.leavingItems.length > 0;
      const currentHoveredIsAnimating = this.currentHoveredItem !== void 0 && this.currentHoveredItem.hoverAmount < 1;
      return hasLeavingItems || currentHoveredIsAnimating;
    };
    this.getAnimatingItems = () => {
      if (this.currentHoveredItem !== void 0) {
        return [...this.leavingItems, this.currentHoveredItem];
      }
      return this.leavingItems.map(x => ({
        ...x,
        hoverAmount: easeOutCubic(x.hoverAmount)
      }));
    };
    this.step = timestamp => {
      if (this.lastAnimationTime === void 0) {
        this.lastAnimationTime = timestamp;
      } else {
        const step = timestamp - this.lastAnimationTime;
        const delta = step / hoverTime;
        for (const item of this.leavingItems) {
          item.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(item.hoverAmount - delta, 0, 1);
        }
        if (this.currentHoveredItem !== void 0) {
          this.currentHoveredItem.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(this.currentHoveredItem.hoverAmount + delta, 0, 1);
        }
        const animating = this.getAnimatingItems();
        this.callback(animating);
        this.cleanUpLeavingElements();
      }
      if (this.shouldStep()) {
        this.lastAnimationTime = timestamp;
        window.requestAnimationFrame(this.step);
      } else {
        this.lastAnimationTime = void 0;
      }
    };
    this.setHovered = item => {
      var _a;
      if (this.areSameItems((_a = this.currentHoveredItem) == null ? void 0 : _a.item, item)) {
        return;
      }
      if (this.currentHoveredItem !== void 0) {
        this.addToLeavingItems(this.currentHoveredItem);
      }
      if (item !== void 0) {
        const hoverAmount = this.removeFromLeavingItems(item);
        this.currentHoveredItem = {
          item,
          hoverAmount
        };
      } else {
        this.currentHoveredItem = void 0;
      }
      if (this.lastAnimationTime === void 0) {
        window.requestAnimationFrame(this.step);
      }
    };
  }
};

// src/common/browser-detect.ts
var Lazy = class {
  constructor(fn) {
    this.fn = fn;
  }
  get value() {
    var _a;
    return (_a = this.val) != null ? _a : this.val = this.fn();
  }
};
function lazy(fn) {
  return new Lazy(fn);
}
var browserIsFirefox = lazy(() => window.navigator.userAgent.includes("Firefox"));
var browserIsSafari = lazy(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome"));
var browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));

// src/data-grid/use-animation-queue.ts

function hasItem(arr, item) {
  for (const element of arr) {
    if (element[0] === item[0] && element[1] === item[1]) return true;
  }
  return false;
}
function useAnimationQueue(draw) {
  const queue = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const seq = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const drawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  drawRef.current = draw;
  const loop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const requeue = () => window.requestAnimationFrame(fn);
    const fn = () => {
      const toDraw = queue.current;
      queue.current = [];
      drawRef.current(toDraw);
      if (queue.current.length > 0) {
        seq.current++;
      } else {
        seq.current = 0;
      }
    };
    window.requestAnimationFrame(seq.current > 600 ? requeue : fn);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(item => {
    if (hasItem(queue.current, item)) return;
    if (queue.current.length === 0) {
      loop();
    }
    queue.current.push(item);
  }, [loop]);
}

// src/data-grid/data-grid.tsx
var getRowData = (cell, getCellRenderer) => {
  var _a;
  if (cell.kind === GridCellKind.Custom) return cell.copyData;
  const r = getCellRenderer == null ? void 0 : getCellRenderer(cell);
  return (_a = r == null ? void 0 : r.getAccessibilityString(cell)) != null ? _a : "";
};
var DataGrid = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const {
    width,
    height,
    accessibilityHeight,
    columns,
    cellXOffset: cellXOffsetReal,
    cellYOffset,
    headerHeight,
    fillHandle = false,
    groupHeaderHeight,
    rowHeight,
    rows,
    getCellContent,
    getRowThemeOverride,
    onHeaderMenuClick,
    enableGroups,
    isFilling,
    onCanvasFocused,
    onCanvasBlur,
    isFocused,
    selection,
    freezeColumns,
    onContextMenu,
    trailingRowType,
    fixedShadowX = true,
    fixedShadowY = true,
    drawFocusRing: drawFocusRing2 = true,
    onMouseDown,
    onMouseUp,
    onMouseMoveRaw,
    onMouseMove,
    onItemHovered,
    dragAndDropState,
    firstColAccessible,
    onKeyDown,
    onKeyUp,
    highlightRegions,
    canvasRef,
    onDragStart,
    onDragEnd,
    eventTargetRef,
    isResizing,
    isDragging,
    isDraggable = false,
    allowResize,
    disabledRows,
    getGroupDetails,
    theme,
    prelightCells,
    headerIcons,
    verticalBorder,
    drawHeader: drawHeaderCallback,
    drawCustomCell,
    onCellFocused,
    onDragOverCell,
    onDrop,
    onDragLeave,
    imageWindowLoader,
    smoothScrollX = false,
    smoothScrollY = false,
    experimental,
    getCellRenderer
  } = p;
  const translateX = (_a = p.translateX) != null ? _a : 0;
  const translateY = (_b = p.translateY) != null ? _b : 0;
  const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const imageWindowLoaderInternal = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new image_window_loader_default(), []);
  const imageLoader = imageWindowLoader != null ? imageWindowLoader : imageWindowLoaderInternal;
  const damageRegion = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [scrolling, setScrolling] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const hoverValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const lastBlitData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [hoveredItemInfo, setHoveredItemInfo] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [hoveredOnEdge, setHoveredOnEdge] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [lastWasTouch, setLastWasTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const lastWasTouchRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lastWasTouch);
  lastWasTouchRef.current = lastWasTouch;
  const spriteManager = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new SpriteManager(headerIcons, () => {
    lastArgsRef.current = void 0;
    lastDrawRef.current();
  }), [headerIcons]);
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const scrollingStopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const disableFirefoxRescaling = (experimental == null ? void 0 : experimental.enableFirefoxRescaling) !== true;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (!browserIsFirefox.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;
    if (scrollingStopRef.current !== -1) {
      setScrolling(true);
    }
    window.clearTimeout(scrollingStopRef.current);
    scrollingStopRef.current = window.setTimeout(() => {
      setScrolling(false);
      scrollingStopRef.current = -1;
    }, 200);
  }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);
  const mappedColumns = useMappedColumns(columns, freezeColumns);
  const getBoundsForItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, row) => {
    const rect = canvas.getBoundingClientRect();
    if (col >= mappedColumns.length || row >= rows) {
      return void 0;
    }
    const scale = rect.width / width;
    const result = computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType === "sticky", mappedColumns, rowHeight);
    if (scale !== 1) {
      result.x *= scale;
      result.y *= scale;
      result.width *= scale;
      result.height *= scale;
    }
    result.x += rect.x;
    result.y += rect.y;
    return result;
  }, [width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType, mappedColumns, rowHeight]);
  const getMouseArgsForPosition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, posX, posY, ev) => {
    var _a2, _b2;
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / width;
    const x = (posX - rect.left) / scale;
    const y = (posY - rect.top) / scale;
    const edgeDetectionBuffer = 5;
    const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, void 0, translateX);
    let button = 0;
    if (ev instanceof MouseEvent) {
      button = ev.button;
    }
    const col = getColumnIndexForX(x, effectiveCols, translateX);
    const row = getRowIndexForY(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType === "sticky");
    const shiftKey = (ev == null ? void 0 : ev.shiftKey) === true;
    const ctrlKey = (ev == null ? void 0 : ev.ctrlKey) === true;
    const metaKey = (ev == null ? void 0 : ev.metaKey) === true;
    const isTouch = ev !== void 0 && !(ev instanceof MouseEvent);
    const edgeSize = 20;
    const scrollEdge = [Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0, Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0];
    let result;
    if (col === -1 || y < 0 || x < 0 || row === void 0 || x > width || y > height) {
      const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
      const vertical = y > height ? 1 : y < 0 ? -1 : 0;
      let isEdge = false;
      if (col === -1 && row === -1) {
        const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);
        assert(b !== void 0);
        isEdge = posX < b.x + b.width + edgeDetectionBuffer;
      }
      result = {
        kind: outOfBoundsKind,
        location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row != null ? row : rows - 1],
        direction: [horizontal, vertical],
        shiftKey,
        ctrlKey,
        metaKey,
        isEdge,
        isTouch,
        button,
        scrollEdge
      };
    } else if (row <= -1) {
      let bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      let isEdge = bounds !== void 0 && bounds.x + bounds.width - posX <= edgeDetectionBuffer;
      const previousCol = col - 1;
      if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {
        isEdge = true;
        bounds = getBoundsForItem(canvas, previousCol, row);
        assert(bounds !== void 0);
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          location: [previousCol, row],
          bounds,
          group: (_a2 = mappedColumns[previousCol].group) != null ? _a2 : "",
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      } else {
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          group: (_b2 = mappedColumns[col].group) != null ? _b2 : "",
          location: [col, row],
          bounds,
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      }
    } else {
      const bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      const isEdge = bounds !== void 0 && bounds.x + bounds.width - posX < edgeDetectionBuffer;
      const isFillHandle = fillHandle && bounds !== void 0 && bounds.x + bounds.width - posX < 6 && bounds.y + bounds.height - posY < 6;
      result = {
        kind: "cell",
        location: [col, row],
        bounds,
        isEdge,
        shiftKey,
        ctrlKey,
        isFillHandle,
        metaKey,
        isTouch,
        localEventX: posX - bounds.x,
        localEventY: posY - bounds.y,
        button,
        scrollEdge
      };
    }
    return result;
  }, [mappedColumns, cellXOffset, width, translateX, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType, getBoundsForItem, fillHandle]);
  function isSameItem(item, other) {
    if (item === other) return true;
    return (item == null ? void 0 : item.kind) === (other == null ? void 0 : other.kind) && (item == null ? void 0 : item.location[0]) === (other == null ? void 0 : other.location[0]) && (item == null ? void 0 : item.location[1]) === (other == null ? void 0 : other.location[1]);
  }
  const [hoveredItem] = hoveredItemInfo != null ? hoveredItemInfo : [];
  const enqueueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_item => {});
  const hoverInfoRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(hoveredItemInfo);
  hoverInfoRef.current = hoveredItemInfo;
  const [bufferA, bufferB] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const a = document.createElement("canvas");
    const b = document.createElement("canvas");
    a.style["display"] = "none";
    a.style["opacity"] = "0";
    a.style["position"] = "fixed";
    b.style["display"] = "none";
    b.style["opacity"] = "0";
    b.style["position"] = "fixed";
    return [a, b];
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    document.documentElement.append(bufferA);
    document.documentElement.append(bufferB);
    return () => {
      bufferA.remove();
      bufferB.remove();
    };
  }, [bufferA, bufferB]);
  const lastArgsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const draw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2;
    const canvas = ref.current;
    const overlay = overlayRef.current;
    if (canvas === null || overlay === null) return;
    const last = lastArgsRef.current;
    const current = {
      canvas,
      bufferA,
      bufferB,
      headerCanvas: overlay,
      width,
      height,
      cellXOffset,
      cellYOffset,
      translateX: Math.round(translateX),
      translateY: Math.round(translateY),
      mappedColumns,
      enableGroups,
      freezeColumns,
      dragAndDropState,
      theme,
      headerHeight,
      groupHeaderHeight,
      disabledRows: disabledRows != null ? disabledRows : CompactSelection.empty(),
      rowHeight,
      verticalBorder,
      isResizing,
      isFocused,
      selection,
      fillHandle,
      lastRowSticky: trailingRowType,
      rows,
      drawFocus: drawFocusRing2,
      getCellContent,
      getGroupDetails: getGroupDetails != null ? getGroupDetails : name => ({
        name
      }),
      getRowThemeOverride,
      drawCustomCell,
      drawHeaderCallback,
      prelightCells,
      highlightRegions,
      imageLoader,
      lastBlitData,
      damage: damageRegion.current,
      hoverValues: hoverValues.current,
      hoverInfo: hoverInfoRef.current,
      spriteManager,
      scrolling,
      hyperWrapping: (_a2 = experimental == null ? void 0 : experimental.hyperWrapping) != null ? _a2 : false,
      touchMode: lastWasTouch,
      enqueue: enqueueRef.current,
      renderStrategy: (_b2 = experimental == null ? void 0 : experimental.renderStrategy) != null ? _b2 : browserIsSafari.value ? "double-buffer" : "single-buffer",
      getCellRenderer
    };
    if (current.damage === void 0) {
      lastArgsRef.current = current;
      drawGrid(current, last);
    } else {
      drawGrid(current, void 0);
    }
  }, [bufferA, bufferB, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, isResizing, isFocused, selection, fillHandle, trailingRowType, rows, drawFocusRing2, getCellContent, getGroupDetails, getRowThemeOverride, drawCustomCell, drawHeaderCallback, prelightCells, highlightRegions, imageLoader, spriteManager, scrolling, experimental == null ? void 0 : experimental.hyperWrapping, experimental == null ? void 0 : experimental.renderStrategy, lastWasTouch, getCellRenderer]);
  const lastDrawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    draw();
    lastDrawRef.current = draw;
  }, [draw]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const fn = async () => {
      var _a2;
      if (((_a2 = document == null ? void 0 : document.fonts) == null ? void 0 : _a2.ready) === void 0) return;
      await document.fonts.ready;
      lastArgsRef.current = void 0;
      lastDrawRef.current();
    };
    void fn();
  }, []);
  const damageInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(locations => {
    damageRegion.current = locations;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const enqueue = useAnimationQueue(damageInternal);
  enqueueRef.current = enqueue;
  const damage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cells => {
    damageInternal(cells.map(x => x.cell));
  }, [damageInternal]);
  imageLoader.setCallback(damageInternal);
  const [overFill, setOverFill] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [hCol, hRow] = hoveredItem != null ? hoveredItem : [];
  const headerHovered = hCol !== void 0 && hRow === -1;
  const groupHeaderHovered = hCol !== void 0 && hRow === -2;
  let clickableInnerCellHovered = false;
  let editableBoolHovered = false;
  let cursorOverride;
  if (hCol !== void 0 && hRow !== void 0 && hRow > -1) {
    const cell = getCellContent([hCol, hRow]);
    clickableInnerCellHovered = cell.kind === InnerGridCellKind.NewRow || cell.kind === InnerGridCellKind.Marker && cell.markerKind !== "number";
    editableBoolHovered = cell.kind === GridCellKind.Boolean && booleanCellIsEditable(cell);
    cursorOverride = cell.cursor;
  }
  const canDrag = hoveredOnEdge != null ? hoveredOnEdge : false;
  const cursor = isDragging ? "grabbing" : canDrag || isResizing ? "col-resize" : overFill || isFilling ? "crosshair" : cursorOverride !== void 0 ? cursorOverride : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered ? "pointer" : "default";
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    contain: "strict",
    display: "block",
    cursor
  }), [cursor]);
  const lastSetCursor = react__WEBPACK_IMPORTED_MODULE_0__.useRef("default");
  const target = eventTargetRef == null ? void 0 : eventTargetRef.current;
  if (target !== null && target !== void 0 && lastSetCursor.current !== style.cursor) {
    target.style.cursor = lastSetCursor.current = style.cursor;
  }
  const groupHeaderActionForEvent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((group, bounds, localEventX, localEventY) => {
    if (getGroupDetails === void 0) return void 0;
    const groupDesc = getGroupDetails(group);
    if (groupDesc.actions !== void 0) {
      const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);
      for (const [i, box] of boxes.entries()) {
        if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {
          return groupDesc.actions[i];
        }
      }
    }
    return void 0;
  }, [getGroupDetails]);
  const isOverHeaderMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, clientX, clientY) => {
    const header = columns[col];
    if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge != null ? hoveredOnEdge : false)) {
      const headerBounds = getBoundsForItem(canvas, col, -1);
      assert(headerBounds !== void 0);
      const menuBounds = getHeaderMenuBounds(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);
      if (clientX > menuBounds.x && clientX < menuBounds.x + menuBounds.width && clientY > menuBounds.y && clientY < menuBounds.y + menuBounds.height) {
        return headerBounds;
      }
    }
    return void 0;
  }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);
  const downTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const downPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    if (canvas === null || ev.target !== canvas && ev.target !== eventTarget) return;
    let clientX;
    let clientY;
    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }
    if (ev.target === eventTarget && eventTarget !== null) {
      const bounds = eventTarget.getBoundingClientRect();
      if (clientX > bounds.left + eventTarget.clientWidth) return;
      if (clientY > bounds.top + eventTarget.clientHeight) return;
    }
    const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    downPosition.current = args.location;
    if (args.isTouch) {
      downTime.current = Date.now();
    }
    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }
    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== void 0) {
      return;
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);
      if (action !== void 0) {
        return;
      }
    }
    onMouseDown == null ? void 0 : onMouseDown(args);
    if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {
      ev.preventDefault();
    }
  }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);
  useEventListener("touchstart", onMouseDownImpl, window, false);
  useEventListener("mousedown", onMouseDownImpl, window, false);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2, _b2;
    const canvas = ref.current;
    if (onMouseUp === void 0 || canvas === null) return;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    const isOutside = ev.target !== canvas && ev.target !== eventTarget;
    let clientX;
    let clientY;
    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
    }
    let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {
      args = {
        ...args,
        isLongTouch: true
      };
    }
    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }
    if (!isOutside && ev.cancelable) {
      ev.preventDefault();
    }
    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {
      const [col] = args.location;
      const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);
      if (headerBounds !== void 0) {
        if (args.button === 0 && ((_a2 = downPosition.current) == null ? void 0 : _a2[0]) === col && ((_b2 = downPosition.current) == null ? void 0 : _b2[1]) === -1) {
          onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, headerBounds);
        } else {
          onMouseUp(args, true);
        }
        return;
      }
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);
      if (action !== void 0) {
        if (args.button === 0) {
          action.onClick(args);
        }
        return;
      }
    }
    onMouseUp(args, isOutside);
  }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);
  useEventListener("mouseup", onMouseUpImpl, window, false);
  useEventListener("touchend", onMouseUpImpl, window, false);
  const onContextMenuImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null || onContextMenu === void 0) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    onContextMenu(args, () => {
      if (ev.cancelable) ev.preventDefault();
    });
  }, [getMouseArgsForPosition, onContextMenu]);
  useEventListener("contextmenu", onContextMenuImpl, (_c = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _c : null, false);
  const onAnimationFrame = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(values => {
    damageRegion.current = values.map(x => x.item);
    hoverValues.current = values;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const animManagerValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);
  const animationManager = react__WEBPACK_IMPORTED_MODULE_0__.useRef(animManagerValue);
  animationManager.current = animManagerValue;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const am = animationManager.current;
    if (hoveredItem === void 0 || hoveredItem[1] < 0) {
      am.setHovered(hoveredItem);
      return;
    }
    const cell = getCellContent(hoveredItem);
    const r = getCellRenderer(cell);
    am.setHovered(r === void 0 && cell.kind === GridCellKind.Custom || (r == null ? void 0 : r.needsHover) === true ? hoveredItem : void 0);
  }, [getCellContent, getCellRenderer, hoveredItem]);
  const hoveredRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2;
    const canvas = ref.current;
    if (canvas === null) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    if (!isSameItem(args, hoveredRef.current)) {
      onItemHovered == null ? void 0 : onItemHovered(args);
      setHoveredItemInfo(args.kind === outOfBoundsKind ? void 0 : [args.location, [args.localEventX, args.localEventY]]);
      hoveredRef.current = args;
    } else if (args.kind === "cell" || args.kind === headerKind || args.kind === groupHeaderKind) {
      const newInfo = [args.location, [args.localEventX, args.localEventY]];
      setHoveredItemInfo(newInfo);
      hoverInfoRef.current = newInfo;
      if (args.kind === "cell") {
        const toCheck = getCellContent(args.location);
        if (toCheck.kind === GridCellKind.Custom || ((_a2 = getCellRenderer(toCheck)) == null ? void 0 : _a2.needsHoverPosition) === true) {
          damageInternal([args.location]);
        }
      } else if (args.kind === groupHeaderKind) {
        damageInternal([args.location]);
      }
    }
    setHoveredOnEdge(args.kind === headerKind && args.isEdge && allowResize === true);
    if (fillHandle && selection.current !== void 0) {
      const [col, row] = selection.current.cell;
      const sb = getBoundsForItem(canvas, col, row);
      const x = ev.clientX;
      const y = ev.clientY;
      assert(sb !== void 0);
      setOverFill(x >= sb.x + sb.width - 6 && x <= sb.x + sb.width && y >= sb.y + sb.height - 6 && y <= sb.y + sb.height);
    } else {
      setOverFill(false);
    }
    onMouseMoveRaw == null ? void 0 : onMouseMoveRaw(ev);
    onMouseMove(args);
  }, [getMouseArgsForPosition, allowResize, fillHandle, selection, onMouseMoveRaw, onMouseMove, onItemHovered, getCellContent, getCellRenderer, damageInternal, getBoundsForItem]);
  useEventListener("mousemove", onMouseMoveImpl, window, true);
  const onKeyDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;
    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }
    onKeyDown == null ? void 0 : onKeyDown({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyDown, selection, getBoundsForItem]);
  const onKeyUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;
    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }
    onKeyUp == null ? void 0 : onKeyUp({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyUp, selection, getBoundsForItem]);
  const refImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    ref.current = instance;
    if (canvasRef !== void 0) {
      canvasRef.current = instance;
    }
  }, [canvasRef]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null || isDraggable === false || isResizing) {
      event.preventDefault();
      return;
    }
    let dragMime;
    let dragData;
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    if (isDraggable !== true && args.kind !== isDraggable) {
      event.preventDefault();
      return;
    }
    const setData = (mime, payload) => {
      dragMime = mime;
      dragData = payload;
    };
    let dragImage;
    let dragImageX;
    let dragImageY;
    const setDragImage = (image, x, y) => {
      dragImage = image;
      dragImageX = x;
      dragImageY = y;
    };
    let prevented = false;
    onDragStart == null ? void 0 : onDragStart({
      ...args,
      setData,
      setDragImage,
      preventDefault: () => prevented = true,
      defaultPrevented: () => prevented
    });
    if (!prevented && dragMime !== void 0 && dragData !== void 0 && event.dataTransfer !== null) {
      event.dataTransfer.setData(dragMime, dragData);
      event.dataTransfer.effectAllowed = "copyLink";
      if (dragImage !== void 0 && dragImageX !== void 0 && dragImageY !== void 0) {
        event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
      } else {
        const [col, row] = args.location;
        if (row !== void 0) {
          const offscreen = document.createElement("canvas");
          const boundsForDragTarget = getBoundsForItem(canvas, col, row);
          assert(boundsForDragTarget !== void 0);
          offscreen.width = boundsForDragTarget.width;
          offscreen.height = boundsForDragTarget.height;
          const ctx = offscreen.getContext("2d");
          if (ctx !== null) {
            ctx.textBaseline = "middle";
            if (row === -1) {
              ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgHeader;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawHeader(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);
            } else {
              ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgCell;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawCell(ctx, row, getCellContent([col, row]), 0, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, drawCustomCell, imageLoader, spriteManager, 1, void 0, false, 0, void 0, void 0, getCellRenderer);
            }
          }
          offscreen.style.left = "-100%";
          offscreen.style.position = "absolute";
          document.body.append(offscreen);
          event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);
          window.setTimeout(() => {
            offscreen.remove();
          }, 0);
        }
      }
    } else {
      event.preventDefault();
    }
  }, [isDraggable, isResizing, getMouseArgsForPosition, onDragStart, getBoundsForItem, theme, mappedColumns, spriteManager, drawHeaderCallback, getCellContent, drawCustomCell, imageLoader, getCellRenderer]);
  useEventListener("dragstart", onDragStartImpl, (_d = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _d : null, false, false);
  const activeDropTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onDragOverImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2;
    const canvas = ref.current;
    if (onDrop !== void 0) {
      event.preventDefault();
    }
    if (canvas === null || onDragOverCell === void 0) {
      return;
    }
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    const [activeCol, activeRow] = (_a2 = activeDropTarget.current) != null ? _a2 : [];
    if (activeCol !== col || activeRow !== row) {
      activeDropTarget.current = [col, row];
      onDragOverCell([col, row], event.dataTransfer);
    }
  }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);
  useEventListener("dragover", onDragOverImpl, (_e = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _e : null, false, false);
  const onDragEndImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    activeDropTarget.current = void 0;
    onDragEnd == null ? void 0 : onDragEnd();
  }, [onDragEnd]);
  useEventListener("dragend", onDragEndImpl, (_f = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _f : null, false, false);
  const onDropImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null || onDrop === void 0) {
      return;
    }
    event.preventDefault();
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    onDrop([col, row], event.dataTransfer);
  }, [firstColAccessible, getMouseArgsForPosition, onDrop]);
  useEventListener("drop", onDropImpl, (_g = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _g : null, false, false);
  const onDragLeaveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onDragLeave == null ? void 0 : onDragLeave();
  }, [onDragLeave]);
  useEventListener("dragleave", onDragLeaveImpl, (_h = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _h : null, false, false);
  const selectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selection);
  selectionRef.current = selection;
  const focusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focusElement = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(el => {
    var _a2;
    if (ref.current === null || !ref.current.contains(document.activeElement)) return;
    if (el === null && selectionRef.current.current !== void 0) {
      (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
        preventScroll: true
      });
    } else if (el !== null) {
      el.focus({
        preventScroll: true
      });
    }
    focusRef.current = el;
  }, [canvasRef]);
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    focus: () => {
      var _a2;
      const el = focusRef.current;
      if (el === null || !document.contains(el)) {
        (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
          preventScroll: true
        });
      } else {
        el.focus({
          preventScroll: true
        });
      }
    },
    getBounds: (col, row) => {
      if (canvasRef === void 0 || canvasRef.current === null) {
        return void 0;
      }
      return getBoundsForItem(canvasRef.current, col, row != null ? row : -1);
    },
    damage
  }), [canvasRef, damage, getBoundsForItem]);
  const lastFocusedSubdomNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const accessibilityTree = useDebouncedMemo(() => {
    var _a2, _b2, _c2, _d2;
    if (width < 50) return null;
    let effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
    const colOffset = firstColAccessible ? 0 : -1;
    if (!firstColAccessible && ((_a2 = effectiveCols[0]) == null ? void 0 : _a2.sourceIndex) === 0) {
      effectiveCols = effectiveCols.slice(1);
    }
    const [fCol, fRow] = (_c2 = (_b2 = selection.current) == null ? void 0 : _b2.cell) != null ? _c2 : [];
    const range2 = (_d2 = selection.current) == null ? void 0 : _d2.range;
    const visibleCols = effectiveCols.map(c => c.sourceIndex);
    const visibleRows = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));
    if (fCol !== void 0 && fRow !== void 0 && !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {
      focusElement(null);
    }
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
      key: "access-tree",
      role: "grid",
      "aria-rowcount": rows + 1,
      "aria-multiselectable": "true",
      "aria-colcount": mappedColumns.length + colOffset
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", {
      role: "rowgroup"
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-rowindex": 1
    }, effectiveCols.map(c => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
      role: "columnheader",
      "aria-selected": selection.columns.hasIndex(c.sourceIndex),
      "aria-colindex": c.sourceIndex + 1 + colOffset,
      tabIndex: -1,
      onFocus: e => {
        if (e.target === focusRef.current) return;
        return onCellFocused == null ? void 0 : onCellFocused([c.sourceIndex, -1]);
      },
      key: c.sourceIndex
    }, c.title)))), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", {
      role: "rowgroup"
    }, visibleRows.map(row => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-selected": selection.rows.hasIndex(row),
      key: row,
      "aria-rowindex": row + 2
    }, effectiveCols.map(c => {
      const col = c.sourceIndex;
      const key = `${col},${row}`;
      const focused = fCol === col && fRow === row;
      const selected = range2 !== void 0 && col >= range2.x && col < range2.x + range2.width && row >= range2.y && row < range2.y + range2.height;
      const id = `glide-cell-${col}-${row}`;
      const cellContent = getCellContent([col, row]);
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        key,
        role: "gridcell",
        "aria-colindex": col + 1 + colOffset,
        "aria-selected": selected,
        "aria-readonly": isInnerOnlyCell(cellContent) || !isReadWriteCell(cellContent),
        id,
        "data-testid": id,
        onClick: () => {
          const canvas = canvasRef == null ? void 0 : canvasRef.current;
          if (canvas === null || canvas === void 0) return;
          return onKeyDown == null ? void 0 : onKeyDown({
            bounds: getBoundsForItem(canvas, col, row),
            cancel: () => void 0,
            preventDefault: () => void 0,
            stopPropagation: () => void 0,
            ctrlKey: false,
            key: "Enter",
            keyCode: 13,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
        },
        onFocusCapture: e => {
          var _a3, _b3;
          if (e.target === focusRef.current || ((_a3 = lastFocusedSubdomNode.current) == null ? void 0 : _a3[0]) === col && ((_b3 = lastFocusedSubdomNode.current) == null ? void 0 : _b3[1]) === row) return;
          lastFocusedSubdomNode.current = [col, row];
          return onCellFocused == null ? void 0 : onCellFocused([col, row]);
        },
        ref: focused ? focusElement : void 0,
        tabIndex: -1
      }, getRowData(cellContent, getCellRenderer));
    })))));
  }, [width, mappedColumns, cellXOffset, dragAndDropState, translateX, rows, cellYOffset, accessibilityHeight, selection, focusElement, getCellContent, canvasRef, onKeyDown, getBoundsForItem, onCellFocused], 200);
  const stickyX = fixedShadowX ? getStickyWidth(mappedColumns, dragAndDropState) : 0;
  const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-translateX / 100, 0, 1);
  const absoluteOffsetY = -cellYOffset * 32 + translateY;
  const opacityY = !fixedShadowY ? 0 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-absoluteOffsetY / 100, 0, 1);
  const stickyShadow = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!opacityX && !opacityY) {
      return null;
    }
    const styleX = {
      position: "absolute",
      top: 0,
      left: stickyX,
      width: width - stickyX,
      height,
      opacity: opacityX,
      pointerEvents: "none",
      transition: !smoothScrollX ? "opacity 0.2s" : void 0,
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    };
    const styleY = {
      position: "absolute",
      top: totalHeaderHeight,
      left: 0,
      width,
      height,
      opacity: opacityY,
      pointerEvents: "none",
      transition: !smoothScrollY ? "opacity 0.2s" : void 0,
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, opacityX > 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-x",
      style: styleX
    }), opacityY > 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-y",
      style: styleY
    }));
  }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);
  const overlayStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    "data-testid": "data-grid-canvas",
    tabIndex: 0,
    onKeyDown: onKeyDownImpl,
    onKeyUp: onKeyUpImpl,
    onFocus: onCanvasFocused,
    onBlur: onCanvasBlur,
    ref: refImpl,
    style
  }, accessibilityTree), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    ref: overlayRef,
    style: overlayStyle
  }), stickyShadow);
};
var data_grid_default = react__WEBPACK_IMPORTED_MODULE_0__.memo(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataGrid));

// src/data-grid-dnd/data-grid-dnd.tsx
function offsetColumnSize(column, width, min, max) {
  var _a;
  return lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(Math.round(width - ((_a = column.growOffset) != null ? _a : 0)), Math.ceil(min), Math.floor(max));
}
var DataGridDnd = p => {
  var _a;
  const [resizeColStartX, setResizeColStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [resizeCol, setResizeCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragCol, setDragCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropCol, setDropCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragColActive, setDragColActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartX, setDragStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRow, setDragRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropRow, setDropRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRowActive, setDragRowActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartY, setDragStartY] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const {
    onHeaderMenuClick,
    getCellContent,
    onColumnMoved,
    onColumnResize,
    onColumnResizeStart,
    onColumnResizeEnd,
    gridRef,
    maxColumnWidth,
    minColumnWidth,
    onRowMoved,
    lockColumns,
    onMouseDown,
    onMouseUp,
    onItemHovered,
    onDragStart
  } = p;
  const canResize = ((_a = onColumnResize != null ? onColumnResize : onColumnResizeEnd) != null ? _a : onColumnResizeStart) !== void 0;
  const {
    columns,
    selection
  } = p;
  const selectedColumns = selection.columns;
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const [col, row] = args.location;
    if (dragCol !== void 0 && dropCol !== col && col >= lockColumns) {
      setDragColActive(true);
      setDropCol(col);
    } else if (dragRow !== void 0 && row !== void 0) {
      setDragRowActive(true);
      setDropRow(Math.max(0, row));
    } else {
      onItemHovered == null ? void 0 : onItemHovered(args);
    }
  }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns]);
  const canDragCol = onColumnMoved !== void 0;
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b;
    if (args.button === 0) {
      const [col, row] = args.location;
      if (args.kind === "out-of-bounds" && args.isEdge && canResize) {
        const bounds = (_a2 = gridRef == null ? void 0 : gridRef.current) == null ? void 0 : _a2.getBounds(columns.length - 1, -1);
        if (bounds !== void 0) {
          setResizeColStartX(bounds.x);
          setResizeCol(columns.length - 1);
        }
      } else if (args.kind === "header" && col >= lockColumns) {
        if (args.isEdge && canResize) {
          setResizeColStartX(args.bounds.x);
          setResizeCol(col);
          onColumnResizeStart == null ? void 0 : onColumnResizeStart(columns[col], args.bounds.width, col, args.bounds.width + ((_b = columns[col].growOffset) != null ? _b : 0));
        } else if (args.kind === "header" && canDragCol) {
          setDragStartX(args.bounds.x);
          setDragCol(col);
        }
      } else if (args.kind === "cell" && lockColumns > 0 && col === 0 && row !== void 0 && onRowMoved !== void 0) {
        setDragStartY(args.bounds.y);
        setDragRow(row);
      }
    }
    onMouseDown == null ? void 0 : onMouseDown(args);
  }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart]);
  const onHeaderMenuClickMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    if (dragColActive || dragRowActive) return;
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, screenPosition);
  }, [dragColActive, dragRowActive, onHeaderMenuClick]);
  const lastResizeWidthRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const clearAll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    lastResizeWidthRef.current = -1;
    setDragRow(void 0);
    setDropRow(void 0);
    setDragStartY(void 0);
    setDragRowActive(false);
    setDragCol(void 0);
    setDropCol(void 0);
    setDragStartX(void 0);
    setDragColActive(false);
    setResizeCol(void 0);
    setResizeColStartX(void 0);
  }, []);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b, _c;
    if (args.button === 0) {
      if (resizeCol !== void 0) {
        if ((selectedColumns == null ? void 0 : selectedColumns.hasIndex(resizeCol)) === true) {
          for (const c of selectedColumns) {
            if (c === resizeCol) continue;
            const col = columns[c];
            const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResize == null ? void 0 : onColumnResize(col, newSize, c, newSize + ((_a2 = col.growOffset) != null ? _a2 : 0));
          }
        }
        const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
        onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(columns[resizeCol], ns, resizeCol, ns + ((_b = columns[resizeCol].growOffset) != null ? _b : 0));
        for (const c of selectedColumns) {
          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(col, s, c, s + ((_c = col.growOffset) != null ? _c : 0));
        }
      }
      clearAll();
      if (dragCol !== void 0 && dropCol !== void 0) {
        onColumnMoved == null ? void 0 : onColumnMoved(dragCol, dropCol);
      }
      if (dragRow !== void 0 && dropRow !== void 0) {
        onRowMoved == null ? void 0 : onRowMoved(dragRow, dropRow);
      }
    }
    onMouseUp == null ? void 0 : onMouseUp(args, isOutside);
  }, [onMouseUp, resizeCol, dragCol, dropCol, dragRow, dropRow, selectedColumns, onColumnResizeEnd, columns, minColumnWidth, maxColumnWidth, onColumnResize, onColumnMoved, onRowMoved, clearAll]);
  const dragOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (dragCol === void 0 || dropCol === void 0) return void 0;
    if (dragCol === dropCol) return void 0;
    return {
      src: dragCol,
      dest: dropCol
    };
  }, [dragCol, dropCol]);
  const onMouseMove = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2, _b;
    if (dragCol !== void 0 && dragStartX !== void 0) {
      const diff = Math.abs(event.clientX - dragStartX);
      if (diff > 20) {
        setDragColActive(true);
      }
    } else if (dragRow !== void 0 && dragStartY !== void 0) {
      const diff = Math.abs(event.clientY - dragStartY);
      if (diff > 20) {
        setDragRowActive(true);
      }
    } else if (resizeCol !== void 0 && resizeColStartX !== void 0) {
      const column = columns[resizeCol];
      const newWidth = event.clientX - resizeColStartX;
      const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);
      onColumnResize == null ? void 0 : onColumnResize(column, ns, resizeCol, ns + ((_a2 = column.growOffset) != null ? _a2 : 0));
      lastResizeWidthRef.current = newWidth;
      if ((selectedColumns == null ? void 0 : selectedColumns.first()) === resizeCol) {
        for (const c of selectedColumns) {
          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResize == null ? void 0 : onColumnResize(col, s, c, s + ((_b = col.growOffset) != null ? _b : 0));
        }
      }
    }
  }, [dragCol, dragStartX, dragRow, dragStartY, resizeCol, resizeColStartX, columns, minColumnWidth, maxColumnWidth, onColumnResize, selectedColumns]);
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    if (dragRow === void 0 || dropRow === void 0) return getCellContent(cell);
    let [col, row] = cell;
    if (row === dropRow) {
      row = dragRow;
    } else {
      if (row > dropRow) row -= 1;
      if (row >= dragRow) row += 1;
    }
    return getCellContent([col, row]);
  }, [dragRow, dropRow, getCellContent]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    onDragStart == null ? void 0 : onDragStart(args);
    if (!args.defaultPrevented()) {
      clearAll();
    }
  }, [clearAll, onDragStart]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_default, {
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    enableGroups: p.enableGroups,
    eventTargetRef: p.eventTargetRef,
    experimental: p.experimental,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    headerIcons: p.headerIcons,
    height: p.height,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isDraggable: p.isDraggable,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDrop: p.onDrop,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    width: p.width,
    getCellContent: getMangledCellContent,
    isResizing: resizeCol !== void 0,
    onHeaderMenuClick: onHeaderMenuClickMangled,
    isDragging: dragColActive,
    onItemHovered: onItemHoveredImpl,
    onDragStart: onDragStartImpl,
    onMouseDown: onMouseDownImpl,
    allowResize: canResize,
    onMouseUp: onMouseUpImpl,
    dragAndDropState: dragOffset,
    onMouseMoveRaw: onMouseMove,
    ref: gridRef
  });
};
var data_grid_dnd_default = DataGridDnd;

// src/scrolling-data-grid/infinite-scroller.tsx


// src/common/resize-detector.ts

function useResizeDetector(initialSize) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    width: initialSize == null ? void 0 : initialSize[0],
    height: initialSize == null ? void 0 : initialSize[1]
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    const resizeCallback = entries => {
      for (const entry of entries) {
        const {
          width,
          height
        } = entry && entry.contentRect || {};
        setSize(cv => cv.width === width && cv.height === height ? cv : {
          width,
          height
        });
      }
    };
    const resizeObserver = new window.ResizeObserver(resizeCallback);
    if (ref.current) {
      resizeObserver.observe(ref.current, void 0);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return {
    ref,
    ...size
  };
}

// src/scrolling-data-grid/infinite-scroller.tsx
var _exp8 = () => p => p.isSafari ? "scroll" : "auto";
var ScrollRegionStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "ScrollRegionStyle",
  class: "s1jz82f8",
  vars: {
    "s1jz82f8-0": [_exp8()]
  }
});
function eatEvent(e) {
  e.stopPropagation();
}
function useTouchUpDelayed(delay) {
  const [hasTouches, setHasTouches] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const cbTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  useEventListener("touchstart", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    window.clearTimeout(cbTimer.current);
    setHasTouches(true);
  }, []), window, true, false);
  useEventListener("touchend", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.touches.length === 0) {
      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);
    }
  }, [delay]), window, true, false);
  return hasTouches;
}
var InfiniteScroller = p => {
  var _a, _b, _c, _d;
  const {
    children,
    clientHeight,
    scrollHeight,
    scrollWidth,
    update,
    draggable,
    className,
    preventDiagonalScrolling = false,
    paddingBottom = 0,
    paddingRight = 0,
    rightElement,
    rightElementProps,
    scrollRef,
    scrollToEnd,
    initialSize,
    minimap
  } = p;
  const padders = [];
  const rightElementSticky = (_a = rightElementProps == null ? void 0 : rightElementProps.sticky) != null ? _a : false;
  const rightElementFill = (_b = rightElementProps == null ? void 0 : rightElementProps.fill) != null ? _b : false;
  const offsetY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const lastScrollY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const scroller = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const dpr = window.devicePixelRatio;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const el = scroller.current;
    if (el === null || scrollToEnd !== true) return;
    el.scrollLeft = el.scrollWidth - el.clientWidth;
  }, [scrollToEnd]);
  const lastScrollPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: void 0
  });
  const rightWrapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const hasTouches = useTouchUpDelayed(200);
  const [isIdle, setIsIdle] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  const idleTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === void 0) return;
    const el = scroller.current;
    if (el === null) return;
    const [lx, ly] = lastScrollPosition.current.lockDirection;
    if (lx !== void 0) {
      el.scrollLeft = lx;
    } else if (ly !== void 0) {
      el.scrollTop = ly;
    }
    lastScrollPosition.current.lockDirection = void 0;
  }, [hasTouches, isIdle]);
  const onScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2, _d2;
    const el = scroller.current;
    if (el === null) return;
    let scrollTop = el.scrollTop;
    let scrollLeft = el.scrollLeft;
    const lastScrollTop = lastScrollPosition.current.scrollTop;
    const lastScrollLeft = lastScrollPosition.current.scrollLeft;
    const dx = scrollLeft - lastScrollLeft;
    const dy = scrollTop - lastScrollTop;
    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === void 0) {
      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, void 0] : [void 0, lastScrollTop];
    }
    const lock = lastScrollPosition.current.lockDirection;
    scrollLeft = (_a2 = lock == null ? void 0 : lock[0]) != null ? _a2 : scrollLeft;
    scrollTop = (_b2 = lock == null ? void 0 : lock[1]) != null ? _b2 : scrollTop;
    lastScrollPosition.current.scrollLeft = scrollLeft;
    lastScrollPosition.current.scrollTop = scrollTop;
    const newY = scrollTop;
    const delta = lastScrollY.current - newY;
    const scrollableHeight = el.scrollHeight - el.clientHeight;
    lastScrollY.current = newY;
    if (scrollableHeight > 0 && (Math.abs(delta) > 2e3 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {
      const prog = newY / scrollableHeight;
      const recomputed = (scrollHeight - el.clientHeight) * prog;
      offsetY.current = recomputed - newY;
    }
    if (lock !== void 0) {
      window.clearTimeout(idleTimer.current);
      setIsIdle(false);
      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);
    }
    update({
      x: scrollLeft,
      y: newY + offsetY.current,
      width: el.clientWidth - paddingRight,
      height: el.clientHeight - paddingBottom,
      paddingRight: (_d2 = (_c2 = rightWrapRef.current) == null ? void 0 : _c2.clientWidth) != null ? _d2 : 0
    });
  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);
  const onScrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onScroll);
  onScrollRef.current = onScroll;
  const lastProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const didFirstScroll = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (didFirstScroll.current) onScroll();else didFirstScroll.current = true;
  }, [onScroll, paddingBottom, paddingRight]);
  const setRefs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    scroller.current = instance;
    if (scrollRef !== void 0) {
      scrollRef.current = instance;
    }
  }, [scrollRef]);
  let key = 0;
  let h = 0;
  padders.push( /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: key++,
    style: {
      width: scrollWidth,
      height: 0
    }
  }));
  while (h < scrollHeight) {
    const toAdd = Math.min(5e6, scrollHeight - h);
    padders.push( /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: key++,
      style: {
        width: 0,
        height: toAdd
      }
    }));
    h += toAdd;
  }
  const {
    ref,
    width,
    height
  } = useResizeDetector(initialSize);
  if (((_c = lastProps.current) == null ? void 0 : _c.height) !== height || ((_d = lastProps.current) == null ? void 0 : _d.width) !== width) {
    window.setTimeout(() => onScrollRef.current(), 0);
    lastProps.current = {
      width,
      height
    };
  }
  if ((width != null ? width : 0) === 0 || (height != null ? height : 0) === 0) return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  });
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollRegionStyle, {
    isSafari: browserIsSafari.value
  }, minimap, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-underlay"
  }, children), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: setRefs,
    style: lastProps.current,
    draggable,
    onDragStart: e => {
      if (!draggable) {
        e.stopPropagation();
        e.preventDefault();
      }
    },
    className: "dvn-scroller " + (className != null ? className : ""),
    onScroll
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-scroll-inner" + (rightElement === void 0 ? " hidden" : "")
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-stack"
  }, padders), rightElement !== void 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !rightElementFill && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-spacer"
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: rightWrapRef,
    onMouseDown: eatEvent,
    onMouseUp: eatEvent,
    onMouseMove: eatEvent,
    style: {
      height,
      maxHeight: clientHeight - Math.ceil(dpr % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: paddingRight,
      flexGrow: rightElementFill ? 1 : void 0,
      right: rightElementSticky ? paddingRight != null ? paddingRight : 0 : void 0,
      pointerEvents: "auto"
    }
  }, rightElement))))));
};

// src/scrolling-data-grid/scrolling-data-grid.tsx

var MinimapStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "MinimapStyle",
  class: "m15w2ly5"
});
var GridScroller = p => {
  var _a, _b, _c;
  const {
    columns,
    rows,
    rowHeight,
    headerHeight,
    groupHeaderHeight,
    enableGroups,
    freezeColumns,
    experimental,
    clientSize,
    className,
    onVisibleRegionChanged,
    scrollToEnd,
    scrollRef,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    overscrollX,
    overscrollY,
    showMinimap = false,
    initialSize,
    smoothScrollX = false,
    smoothScrollY = false,
    isDraggable
  } = p;
  const {
    paddingRight,
    paddingBottom
  } = experimental != null ? experimental : {};
  const [clientWidth, clientHeight] = clientSize;
  const last = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastX = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastY = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSize = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const width = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let r = Math.max(0, overscrollX != null ? overscrollX : 0);
    for (const c of columns) {
      r += c.width;
    }
    return r;
  }, [columns, overscrollX]);
  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  if (typeof rowHeight === "number") {
    height += rows * rowHeight;
  } else {
    for (let r = 0; r < rows; r++) {
      height += rowHeight(r);
    }
  }
  if (overscrollY !== void 0) {
    height += overscrollY;
  }
  const lastArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const processArgs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2;
    if (lastArgs.current === void 0) return;
    const args = {
      ...lastArgs.current
    };
    let x = 0;
    let tx = args.x < 0 ? -args.x : 0;
    let cellRight = 0;
    let cellX = 0;
    args.x = args.x < 0 ? 0 : args.x;
    let stickyColWidth = 0;
    for (let i = 0; i < freezeColumns; i++) {
      stickyColWidth += columns[i].width;
    }
    for (const c of columns) {
      const cx = x - stickyColWidth;
      if (args.x >= cx + c.width) {
        x += c.width;
        cellX++;
        cellRight++;
      } else if (args.x > cx) {
        x += c.width;
        if (smoothScrollX) {
          tx += cx - args.x;
        } else {
          cellX++;
        }
        cellRight++;
      } else if (args.x + args.width > cx) {
        x += c.width;
        cellRight++;
      } else {
        break;
      }
    }
    let ty = 0;
    let cellY = 0;
    let cellBottom = 0;
    if (typeof rowHeight === "number") {
      if (smoothScrollY) {
        cellY = Math.floor(args.y / rowHeight);
        ty = cellY * rowHeight - args.y;
      } else {
        cellY = Math.ceil(args.y / rowHeight);
      }
      cellBottom = Math.ceil(args.height / rowHeight) + cellY;
      if (ty < 0) cellBottom++;
    } else {
      let y = 0;
      for (let row = 0; row < rows; row++) {
        const rh = rowHeight(row);
        const cy = y + (smoothScrollY ? 0 : rh / 2);
        if (args.y >= y + rh) {
          y += rh;
          cellY++;
          cellBottom++;
        } else if (args.y > cy) {
          y += rh;
          if (smoothScrollY) {
            ty += cy - args.y;
          } else {
            cellY++;
          }
          cellBottom++;
        } else if (args.y + args.height > rh / 2 + y) {
          y += rh;
          cellBottom++;
        } else {
          break;
        }
      }
    }
    const rect = {
      x: cellX,
      y: cellY,
      width: cellRight - cellX,
      height: cellBottom - cellY
    };
    const oldRect = last.current;
    if (oldRect === void 0 || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== ((_a2 = lastSize.current) == null ? void 0 : _a2[0]) || args.height !== ((_b2 = lastSize.current) == null ? void 0 : _b2[1])) {
      onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged({
        x: cellX,
        y: cellY,
        width: cellRight - cellX,
        height: cellBottom - cellY
      }, args.width, args.height, (_c2 = args.paddingRight) != null ? _c2 : 0, tx, ty);
      last.current = rect;
      lastX.current = tx;
      lastY.current = ty;
      lastSize.current = [args.width, args.height];
    }
  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);
  const onScrollUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    lastArgs.current = args;
    processArgs();
  }, [processArgs]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    processArgs();
  }, [processArgs]);
  const scroller = (_a = scrollRef == null ? void 0 : scrollRef.current) != null ? _a : void 0;
  const aspect = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(width / height, 2 / 3, 1.5);
  const maxSize = 200;
  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);
  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;
  const hRatio = w / width;
  const vRatio = h / height;
  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);
  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);
  const left = ((_b = scroller == null ? void 0 : scroller.scrollLeft) != null ? _b : 0) / (width - clientWidth) * (w - vWidth);
  const top = ((_c = scroller == null ? void 0 : scroller.scrollTop) != null ? _c : 0) / (height - clientHeight) * (h - vHeight);
  const minimap = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!showMinimap || vWidth === 0 || vHeight === 0) return void 0;
    const handleMouse = e => {
      if (scroller === void 0) return;
      const bounds = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - bounds.x - vWidth / 2;
      const y = e.clientY - bounds.y - vHeight / 2;
      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));
      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));
      scroller.scrollTo({
        left: newScrollLeft,
        top: newScrollTop,
        behavior: e.type === "mousemove" ? "auto" : "smooth"
      });
    };
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MinimapStyle, {
      style: {
        width: w,
        height: h
      },
      "data-testid": "minimap-container",
      onMouseMove: e => {
        if (e.buttons !== 1) return;
        handleMouse(e);
      },
      onClick: handleMouse
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "header"
    }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "locationMarker",
      onDragStart: e => e.preventDefault(),
      style: {
        left,
        top,
        width: vWidth,
        height: vHeight,
        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)
      }
    }));
  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(InfiniteScroller, {
    scrollRef,
    minimap,
    className,
    preventDiagonalScrolling,
    draggable: isDraggable === true || typeof isDraggable === "string",
    scrollWidth: width + (paddingRight != null ? paddingRight : 0),
    scrollHeight: height + (paddingBottom != null ? paddingBottom : 0),
    clientHeight,
    rightElement,
    paddingBottom,
    paddingRight,
    rightElementProps,
    update: onScrollUpdate,
    initialSize,
    scrollToEnd
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_dnd_default, {
    eventTargetRef: scrollRef,
    width: clientWidth,
    height: clientHeight,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY
  }));
};
var scrolling_data_grid_default = GridScroller;

// src/data-grid-search/data-grid-search-style.tsx
var _exp9 = () => p => p.showSearch ? 0 : 400;
var SearchWrapper = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "SearchWrapper",
  class: "sxep88s",
  vars: {
    "sxep88s-0": [_exp9(), "px"]
  }
});

// src/data-grid-search/data-grid-search.tsx
var upArrow = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 244l144-144 144 144M256 120v292"
}));
var downArrow = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 268l144 144 144-144M256 392V100"
}));
var closeX = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "32",
  d: "M368 368L144 144M368 144L144 368"
}));
var targetSearchTimeMS = 10;
var DataGridSearch = p => {
  const {
    canvasRef,
    cellYOffset,
    rows,
    columns,
    searchInputRef,
    getCellsForSelection,
    onSearchResultsChanged,
    showSearch = false,
    onSearchClose
  } = p;
  const [searchID] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => "search-box-" + Math.round(Math.random() * 1e3));
  const [searchString, setSearchString] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  const [searchStatus, setSearchStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchStatusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(searchStatus);
  searchStatusRef.current = searchStatus;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  const searchHandle = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [searchResults, setSearchResults] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const cancelSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (searchHandle.current !== void 0) {
      window.cancelAnimationFrame(searchHandle.current);
      searchHandle.current = void 0;
      abortControllerRef.current.abort();
    }
  }, []);
  const cellYOffsetRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cellYOffset);
  cellYOffsetRef.current = cellYOffset;
  const beginSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(str => {
    const regex = new RegExp(str.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let startY = cellYOffsetRef.current;
    let searchStride = Math.min(10, rows);
    let rowsSearched = 0;
    setSearchStatus(void 0);
    setSearchResults([]);
    const runningResult = [];
    const tick = async () => {
      var _a, _b;
      if (getCellsForSelection === void 0) return;
      const tStart = performance.now();
      const rowsLeft = rows - rowsSearched;
      let data = getCellsForSelection({
        x: 0,
        y: startY,
        width: columns.length,
        height: Math.min(searchStride, rowsLeft, rows - startY)
      }, abortControllerRef.current.signal);
      if (typeof data === "function") {
        data = await data();
      }
      let added = false;
      for (const [row, d] of data.entries()) {
        for (const [col, cell] of d.entries()) {
          let testString;
          switch (cell.kind) {
            case GridCellKind.Text:
            case GridCellKind.Number:
              testString = cell.displayData;
              break;
            case GridCellKind.Uri:
            case GridCellKind.Markdown:
              testString = cell.data;
              break;
            case GridCellKind.Boolean:
              testString = typeof cell.data === "boolean" ? cell.data.toString() : void 0;
              break;
            case GridCellKind.Image:
            case GridCellKind.Bubble:
              testString = cell.data.join("\u{1F433}");
              break;
            case GridCellKind.Custom:
              testString = cell.copyData;
              break;
          }
          if (testString !== void 0 && regex.test(testString)) {
            runningResult.push([col, row + startY]);
            added = true;
          }
        }
      }
      const tEnd = performance.now();
      if (added) {
        setSearchResults([...runningResult]);
      }
      rowsSearched += data.length;
      assert(rowsSearched <= rows);
      const selectedIndex = (_b = (_a = searchStatusRef.current) == null ? void 0 : _a.selectedIndex) != null ? _b : -1;
      setSearchStatus({
        results: runningResult.length,
        rowsSearched,
        selectedIndex
      });
      onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(runningResult, selectedIndex);
      if (startY + searchStride >= rows) {
        startY = 0;
      } else {
        startY += searchStride;
      }
      const tElapsed = tEnd - tStart;
      const rounded = Math.max(tElapsed, 1);
      const scalar = targetSearchTimeMS / rounded;
      searchStride = Math.ceil(searchStride * scalar);
      if (rowsSearched < rows && runningResult.length < 1e3) {
        searchHandle.current = window.requestAnimationFrame(tick);
      }
    };
    cancelSearch();
    searchHandle.current = window.requestAnimationFrame(tick);
  }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);
  const onClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a;
    onSearchClose == null ? void 0 : onSearchClose();
    setSearchStatus(void 0);
    setSearchResults([]);
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged([], -1);
    cancelSearch();
    (_a = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a.focus();
  }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);
  const onSearchChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    setSearchString(event.target.value);
    if (event.target.value === "") {
      setSearchStatus(void 0);
      setSearchResults([]);
      cancelSearch();
    } else {
      beginSearch(event.target.value);
    }
  }, [beginSearch, cancelSearch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (showSearch && searchInputRef.current !== null) {
      setSearchString("");
      searchInputRef.current.focus({
        preventScroll: true
      });
    }
  }, [showSearch, searchInputRef]);
  const onNext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;
    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
    setSearchStatus({
      ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [searchStatus, onSearchResultsChanged, searchResults]);
  const onPrev = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;
    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
    if (newIndex < 0) newIndex += searchStatus.results;
    setSearchStatus({
      ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [onSearchResultsChanged, searchResults, searchStatus]);
  const onSearchKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.nativeEvent.code === "KeyF" || event.key === "Escape") {
      onClose();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.key === "Enter") {
      if (event.shiftKey) {
        onPrev();
      } else {
        onNext();
      }
    }
  }, [onClose, onNext, onPrev]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      cancelSearch();
    };
  }, [cancelSearch]);
  const searchbox = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b, _c;
    let resultString;
    if (searchStatus !== void 0) {
      resultString = searchStatus.results >= 1e3 ? `over 1000` : `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;
      if (searchStatus.selectedIndex >= 0) {
        resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;
      }
    }
    const cancelEvent = ev => {
      ev.stopPropagation();
    };
    const rowsSearchedProgress = Math.floor(((_a = searchStatus == null ? void 0 : searchStatus.rowsSearched) != null ? _a : 0) / rows * 100);
    const progressStyle = {
      width: `${rowsSearchedProgress}%`
    };
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchWrapper, {
      showSearch,
      onMouseDown: cancelEvent,
      onMouseMove: cancelEvent,
      onMouseUp: cancelEvent,
      onClick: cancelEvent
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-bar-inner"
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      id: searchID,
      "aria-hidden": !showSearch,
      "data-testid": "search-input",
      ref: searchInputRef,
      onChange: onSearchChange,
      value: searchString,
      tabIndex: showSearch ? void 0 : -1,
      onKeyDownCapture: onSearchKeyDown
    }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Previous Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onPrev,
      disabled: ((_b = searchStatus == null ? void 0 : searchStatus.results) != null ? _b : 0) === 0
    }, upArrow), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Next Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onNext,
      disabled: ((_c = searchStatus == null ? void 0 : searchStatus.results) != null ? _c : 0) === 0
    }, downArrow), onSearchClose !== void 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Close Search",
      "aria-hidden": !showSearch,
      "data-testid": "search-close-button",
      tabIndex: showSearch ? void 0 : -1,
      onClick: onClose
    }, closeX)), searchStatus !== void 0 ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      "data-testid": "search-result-area"
    }, resultString)), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-progress",
      style: progressStyle
    })) : /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      htmlFor: searchID
    }, "Type to search")));
  }, [onClose, onNext, onPrev, onSearchChange, onSearchClose, onSearchKeyDown, rows, searchStatus, searchString, showSearch, searchID, searchInputRef]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(scrolling_data_grid_default, {
    prelightCells: searchResults,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    className: p.className,
    clientSize: p.clientSize,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    initialSize: p.initialSize,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    onVisibleRegionChanged: p.onVisibleRegionChanged,
    overscrollX: p.overscrollX,
    overscrollY: p.overscrollY,
    preventDiagonalScrolling: p.preventDiagonalScrolling,
    rightElement: p.rightElement,
    rightElementProps: p.rightElementProps,
    rowHeight: p.rowHeight,
    rows: p.rows,
    scrollRef: p.scrollRef,
    selection: p.selection,
    showMinimap: p.showMinimap,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    scrollToEnd: p.scrollToEnd
  }), searchbox);
};
var data_grid_search_default = DataGridSearch;

// src/data-editor/group-rename.tsx

var _exp10 = () => p => Math.max(16, p.targetHeight - 10);
var RenameInput = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("input")({
  name: "RenameInput",
  class: "r1kzy40b",
  vars: {
    "r1kzy40b-0": [_exp10(), "px"]
  }
});
var GroupRename = p => {
  const {
    bounds,
    group,
    onClose,
    canvasBounds,
    onFinish
  } = p;
  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(group);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: {
      position: "absolute",
      left: bounds.x - canvasBounds.left + 1,
      top: bounds.y - canvasBounds.top,
      width: bounds.width - 2,
      height: bounds.height
    },
    className: "c1sqdbw3",
    onClickOutside: onClose
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenameInput, {
    targetHeight: bounds.height,
    "data-testid": "group-rename-input",
    value,
    onBlur: onClose,
    onFocus: e => e.target.setSelectionRange(0, value.length),
    onChange: e => setValue(e.target.value),
    onKeyDown: e => {
      if (e.key === "Enter") {
        onFinish(value);
      } else if (e.key === "Escape") {
        onClose();
      }
    },
    autoFocus: true
  }));
};

// src/data-editor/use-column-sizer.ts

var defaultSize = 150;
function measureCell(ctx, cell, theme, getCellRenderer) {
  var _a, _b;
  if (cell.kind === GridCellKind.Custom) return defaultSize;
  const r = getCellRenderer(cell);
  return (_b = (_a = r == null ? void 0 : r.measure) == null ? void 0 : _a.call(r, ctx, cell, theme)) != null ? _b : defaultSize;
}
function measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {
  let sizes = [];
  if (selectedData !== void 0) {
    sizes.push(...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer)));
  }
  if (sizes.length > 5 && removeOutliers) {
    const average = sizes.reduce((a, b) => a + b) / sizes.length;
    sizes = sizes.filter(a => a < average * 2);
  }
  sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === void 0 ? 0 : 28));
  const biggest = Math.max(...sizes);
  const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));
  return {
    ...c,
    width: final
  };
}
function useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  const getCellsForSelectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellsForSelection);
  const themeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(theme);
  rowsRef.current = rows;
  getCellsForSelectionRef.current = getCellsForSelection;
  themeRef.current = theme;
  const [ctx] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    if (typeof window === void 0) return null;
    const offscreen = document.createElement("canvas");
    offscreen.style["display"] = "none";
    offscreen.style["opacity"] = "0";
    offscreen.style["position"] = "fixed";
    document.documentElement.append(offscreen);
    return offscreen.getContext("2d", {
      alpha: false
    });
  });
  const memoMap = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  const lastColumns = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [selectedData, setSelectionData] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const getCells = getCellsForSelectionRef.current;
    if (getCells === void 0 || columns.every(isSizedGridColumn)) return;
    let computeRows = Math.max(1, 10 - Math.floor(columns.length / 1e4));
    let tailRows = 0;
    if (computeRows < rowsRef.current && computeRows > 1) {
      computeRows--;
      tailRows = 1;
    }
    const computeArea = {
      x: 0,
      y: 0,
      width: columns.length,
      height: Math.min(rowsRef.current, computeRows)
    };
    const tailComputeArea = {
      x: 0,
      y: rowsRef.current - 1,
      width: columns.length,
      height: 1
    };
    const fn = async () => {
      const getResult = getCells(computeArea, abortController.signal);
      const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : void 0;
      let toSet;
      if (typeof getResult === "object") {
        toSet = getResult;
      } else {
        toSet = await resolveCellsThunk(getResult);
      }
      if (tailGetResult !== void 0) {
        if (typeof tailGetResult === "object") {
          toSet = [...toSet, ...tailGetResult];
        } else {
          toSet = [...toSet, ...(await resolveCellsThunk(tailGetResult))];
        }
      }
      lastColumns.current = columns;
      setSelectionData(toSet);
    };
    void fn();
  }, [abortController.signal, columns]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a;
    const getRaw = () => {
      if (columns.every(isSizedGridColumn)) {
        return columns;
      }
      if (ctx === null) {
        return columns.map(c => {
          if (isSizedGridColumn(c)) return c;
          return {
            ...c,
            width: defaultSize
          };
        });
      }
      ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;
      return columns.map((c, colIndex) => {
        if (isSizedGridColumn(c)) return c;
        if (memoMap.current[c.id] !== void 0) {
          return {
            ...c,
            width: memoMap.current[c.id]
          };
        }
        if (selectedData === void 0 || lastColumns.current !== columns || c.id === void 0) {
          return {
            ...c,
            width: defaultSize
          };
        }
        const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);
        memoMap.current[c.id] = r.width;
        return r;
      });
    };
    let result = getRaw();
    let totalWidth = 0;
    let totalGrow = 0;
    const distribute = [];
    for (const [i, c] of result.entries()) {
      totalWidth += c.width;
      if (c.grow !== void 0 && c.grow > 0) {
        totalGrow += c.grow;
        distribute.push(i);
      }
    }
    if (totalWidth < clientWidth && distribute.length > 0) {
      const writeable = [...result];
      const extra = clientWidth - totalWidth;
      let remaining = extra;
      for (let di = 0; di < distribute.length; di++) {
        const i = distribute[di];
        const weighted = ((_a = result[i].grow) != null ? _a : 0) / totalGrow;
        const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));
        writeable[i] = {
          ...result[i],
          growOffset: toAdd,
          width: result[i].width + toAdd
        };
        remaining -= toAdd;
      }
      result = writeable;
    }
    return result;
  }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);
}

// src/common/is-hotkey.ts
function checkKey(key, args) {
  if (key === void 0) return false;
  if (key.length > 1 && key.startsWith("_")) {
    const keycode = Number.parseInt(key.slice(1));
    if (keycode !== args.keyCode) return false;
  } else {
    if (key !== args.key) return false;
  }
  return true;
}
function isHotkey(hotkey, args) {
  if (hotkey.length === 0) return false;
  let wantCtrl = false;
  let wantShift = false;
  let wantAlt = false;
  let wantMeta = false;
  const split = hotkey.split("+");
  const key = split.pop();
  if (!checkKey(key, args)) return false;
  for (const accel of split) {
    switch (accel) {
      case "ctrl":
        wantCtrl = true;
        break;
      case "shift":
        wantShift = true;
        break;
      case "alt":
        wantAlt = true;
        break;
      case "meta":
        wantMeta = true;
        break;
      case "primary":
        if (browserIsOSX.value) {
          wantMeta = true;
        } else {
          wantCtrl = true;
        }
        break;
    }
  }
  return args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta;
}

// src/data-grid/use-selection-behavior.ts

function useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {
  const setCurrent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((value, expand, append, trigger) => {
    var _a, _b;
    if ((rangeSelect === "cell" || rangeSelect === "multi-cell") && value !== void 0) {
      value = {
        ...value,
        range: {
          x: value.cell[0],
          y: value.cell[1],
          width: 1,
          height: 1
        }
      };
    }
    const rangeMixable = rangeBehavior === "mixed" && (append || trigger === "drag");
    const allowColumnCoSelect = columnBehavior === "mixed" && rangeMixable;
    const allowRowCoSelect = rowBehavior === "mixed" && rangeMixable;
    let newVal = {
      current: value === void 0 ? void 0 : {
        ...value,
        rangeStack: trigger === "drag" ? (_b = (_a = gridSelection.current) == null ? void 0 : _a.rangeStack) != null ? _b : [] : []
      },
      columns: allowColumnCoSelect ? gridSelection.columns : CompactSelection.empty(),
      rows: allowRowCoSelect ? gridSelection.rows : CompactSelection.empty()
    };
    const addLastRange = append && (rangeSelect === "multi-rect" || rangeSelect === "multi-cell");
    if (addLastRange && newVal.current !== void 0 && gridSelection.current !== void 0) {
      newVal = {
        ...newVal,
        current: {
          ...newVal.current,
          rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range]
        }
      };
    }
    setGridSelection(newVal, expand);
  }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);
  const setSelectedRows = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newRows, append, allowMixed) => {
    newRows = newRows != null ? newRows : gridSelection.rows;
    if (append !== void 0) {
      newRows = newRows.add(append);
    }
    let newVal;
    if (rowBehavior === "exclusive" && newRows.length > 0) {
      newVal = {
        current: void 0,
        columns: CompactSelection.empty(),
        rows: newRows
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const columnMixed = allowMixed && columnBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        columns: columnMixed ? gridSelection.columns : CompactSelection.empty(),
        rows: newRows
      };
    }
    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  const setSelectedColumns = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCols, append, allowMixed) => {
    newCols = newCols != null ? newCols : gridSelection.columns;
    if (append !== void 0) {
      newCols = newCols.add(append);
    }
    let newVal;
    if (columnBehavior === "exclusive" && newCols.length > 0) {
      newVal = {
        current: void 0,
        rows: CompactSelection.empty(),
        columns: newCols
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const rowMixed = allowMixed && rowBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        rows: rowMixed ? gridSelection.rows : CompactSelection.empty(),
        columns: newCols
      };
    }
    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  return [setCurrent, setSelectedRows, setSelectedColumns];
}

// src/data-editor/use-cells-for-selection.ts

function useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController) {
  const getCellsForSelectionDirectWhenValid = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    var _a;
    if (getCellsForSelectionIn === true) {
      const result = [];
      for (let y = rect.y; y < rect.y + rect.height; y++) {
        const row = [];
        for (let x = rect.x; x < rect.x + rect.width; x++) {
          if (x < 0) {
            row.push({
              kind: GridCellKind.Loading,
              allowOverlay: false
            });
          } else {
            row.push(getCellContent([x, y]));
          }
        }
        result.push(row);
      }
      return result;
    }
    return (_a = getCellsForSelectionIn == null ? void 0 : getCellsForSelectionIn(rect, abortController.signal)) != null ? _a : [];
  }, [abortController.signal, getCellContent, getCellsForSelectionIn]);
  const getCellsForSelectionDirect = getCellsForSelectionIn !== void 0 ? getCellsForSelectionDirectWhenValid : void 0;
  const getCellsForSelectionMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    if (getCellsForSelectionDirect === void 0) return [];
    const newRect = {
      ...rect,
      x: rect.x - rowMarkerOffset
    };
    if (newRect.x < 0) {
      newRect.x = 0;
      newRect.width--;
      const r = getCellsForSelectionDirect(newRect, abortController.signal);
      if (typeof r === "function") {
        return async () => (await r()).map(row => [{
          kind: GridCellKind.Loading,
          allowOverlay: false
        }, ...row]);
      }
      return r.map(row => [{
        kind: GridCellKind.Loading,
        allowOverlay: false
      }, ...row]);
    }
    return getCellsForSelectionDirect(newRect, abortController.signal);
  }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);
  const getCellsForSelection = getCellsForSelectionIn !== void 0 ? getCellsForSelectionMangled : void 0;
  return [getCellsForSelection, getCellsForSelectionDirect];
}

// src/data-editor/data-editor-fns.ts
function expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {
  var _a, _b;
  const origVal = newVal;
  if (spanRangeBehavior === "allowPartial" || newVal.current === void 0) return newVal;
  if (getCellsForSelection !== void 0) {
    let isFilled = false;
    do {
      if ((newVal == null ? void 0 : newVal.current) === void 0) break;
      const r = (_a = newVal.current) == null ? void 0 : _a.range;
      const cells = [];
      if (r.width > 2) {
        const leftCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);
        if (typeof leftCells === "function") {
          return origVal;
        }
        cells.push(...leftCells);
        const rightCells = getCellsForSelection({
          x: r.x + r.width - 1,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);
        if (typeof rightCells === "function") {
          return origVal;
        }
        cells.push(...rightCells);
      } else {
        const rCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: r.width,
          height: r.height
        }, abortController.signal);
        if (typeof rCells === "function") {
          return origVal;
        }
        cells.push(...rCells);
      }
      let left = r.x - rowMarkerOffset;
      let right = r.x + r.width - 1 - rowMarkerOffset;
      for (const row of cells) {
        for (const cell of row) {
          if (cell.span === void 0) continue;
          left = Math.min(cell.span[0], left);
          right = Math.max(cell.span[1], right);
        }
      }
      if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {
        isFilled = true;
      } else {
        newVal = {
          current: {
            cell: (_b = newVal.current.cell) != null ? _b : [0, 0],
            range: {
              x: left + rowMarkerOffset,
              y: r.y,
              width: right - left + 1,
              height: r.height
            },
            rangeStack: newVal.current.rangeStack
          },
          columns: newVal.columns,
          rows: newVal.rows
        };
      }
    } while (!isFilled);
  }
  return newVal;
}
function descape(s) {
  if (s.startsWith('"') && s.endsWith('"')) {
    s = s.slice(1, -1).replace(/""/g, '"');
  }
  return s;
}
function unquote(str) {
  var State;
  (function (State2) {
    State2[State2["None"] = 0] = "None";
    State2[State2["inString"] = 1] = "inString";
    State2[State2["inStringPostQuote"] = 2] = "inStringPostQuote";
  })(State || (State = {}));
  const result = [];
  let current = [];
  let start = 0;
  let state = 0;
  str = str.replace(/\r\n/g, "\n");
  let index = 0;
  for (const char of str) {
    switch (state) {
      case 0:
        if (char === "	" || char === "\n") {
          current.push(str.slice(start, index));
          start = index + 1;
          if (char === "\n") {
            result.push(current);
            current = [];
          }
        } else if (char === `"`) {
          state = 1;
        }
        break;
      case 1:
        if (char === `"`) {
          state = 2;
        }
        break;
      case 2:
        if (char === '"') {
          state = 1;
        } else if (char === "	" || char === "\n") {
          current.push(descape(str.slice(start, index)));
          start = index + 1;
          if (char === "\n") {
            result.push(current);
            current = [];
          }
          state = 0;
        } else {
          state = 0;
        }
        break;
    }
    index++;
  }
  if (start < str.length) {
    current.push(descape(str.slice(start, str.length)));
  }
  result.push(current);
  return result;
}
function decodeHTML(tableEl) {
  var _a, _b;
  const walkEl = [tableEl];
  const result = [];
  let current;
  while (walkEl.length > 0) {
    const el = walkEl.pop();
    if (el === void 0) break;
    if (el instanceof HTMLTableElement || el.nodeName === "TBODY") {
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableRowElement) {
      if (current !== void 0) {
        result.push(current);
      }
      current = [];
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableCellElement) {
      current == null ? void 0 : current.push((_b = (_a = el.innerText) != null ? _a : el.textContent) != null ? _b : "");
    }
  }
  if (current !== void 0) {
    result.push(current);
  }
  return result;
}
function escape(str) {
  if (/[\t\n"]/.test(str)) {
    str = `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}
var formatBoolean = val => {
  switch (val) {
    case true:
      return "TRUE";
    case false:
      return "FALSE";
    case BooleanIndeterminate:
      return "INDETERMINATE";
    case BooleanEmpty:
      return "";
    default:
      assertNever(val);
  }
};
function copyToClipboard(cells, columnIndexes, e) {
  var _a, _b, _c, _d;
  const formatCell = (cell, index, raw) => {
    var _a2, _b2;
    const colIndex = columnIndexes[index];
    if (cell.span !== void 0 && cell.span[0] !== colIndex) return "";
    switch (cell.kind) {
      case GridCellKind.Text:
      case GridCellKind.Number:
        return escape(raw ? (_b2 = (_a2 = cell.data) == null ? void 0 : _a2.toString()) != null ? _b2 : "" : cell.displayData);
      case GridCellKind.Markdown:
      case GridCellKind.RowID:
      case GridCellKind.Uri:
        return escape(cell.data);
      case GridCellKind.Image:
      case GridCellKind.Bubble:
        return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);
      case GridCellKind.Boolean:
        return formatBoolean(cell.data);
      case GridCellKind.Loading:
        return raw ? "" : "#LOADING";
      case GridCellKind.Protected:
        return raw ? "" : "************";
      case GridCellKind.Drilldown:
        return cell.data.map(i => i.text).reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);
      case GridCellKind.Custom:
        return escape(cell.copyData);
      default:
        assertNever(cell);
    }
  };
  const str = cells.map(row => row.map((a, b) => formatCell(a, b, false)).join("	")).join("\n");
  if (((_a = window.navigator.clipboard) == null ? void 0 : _a.write) !== void 0 || e !== void 0) {
    const rootEl = document.createElement("tbody");
    for (const row of cells) {
      const rowEl = document.createElement("tr");
      for (const [i, cell] of row.entries()) {
        const cellEl = document.createElement("td");
        if (cell.kind === GridCellKind.Uri) {
          const link = document.createElement("a");
          link.href = cell.data;
          link.innerText = cell.data;
          cellEl.append(link);
        } else {
          cellEl.innerText = formatCell(cell, i, true);
        }
        rowEl.append(cellEl);
      }
      rootEl.append(rowEl);
    }
    if (((_b = window.navigator.clipboard) == null ? void 0 : _b.write) !== void 0) {
      void window.navigator.clipboard.write([new ClipboardItem({
        "text/plain": new Blob([str], {
          type: "text/plain"
        }),
        "text/html": new Blob([`<table>${rootEl.outerHTML}</table>`], {
          type: "text/html"
        })
      })]);
    } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
      try {
        e.clipboardData.setData("text/plain", str);
        e.clipboardData.setData("text/html", `<table>${rootEl.outerHTML}</table>`);
      } catch (e2) {
        void ((_c = window.navigator.clipboard) == null ? void 0 : _c.writeText(str));
      }
    }
  } else {
    void ((_d = window.navigator.clipboard) == null ? void 0 : _d.writeText(str));
  }
  e == null ? void 0 : e.preventDefault();
}

// src/data-editor-container/data-grid-container.tsx

function toCss(x) {
  if (typeof x === "string") return x;
  return `${x}px`;
}
var _exp11 = () => p => p.innerWidth;
var _exp22 = () => p => p.innerHeight;
var Wrapper = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "Wrapper",
  class: "wzg2m5k",
  vars: {
    "wzg2m5k-0": [_exp11()],
    "wzg2m5k-1": [_exp22()]
  }
});
var DataEditorContainer = p => {
  const {
    inWidth,
    inHeight,
    children,
    ...rest
  } = p;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, {
    innerHeight: toCss(inHeight),
    innerWidth: toCss(inWidth),
    ...rest
  }, children);
};

// src/data-grid/cells/boolean-cell.tsx
function toggleBoolean(data) {
  return data !== true;
}
var booleanCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "false";
  },
  kind: GridCellKind.Boolean,
  needsHover: true,
  useLabel: false,
  needsHoverPosition: true,
  measure: () => 50,
  draw: a => drawBoolean(a, a.cell.data, booleanCellIsEditable(a.cell)),
  onDelete: c => ({
    ...c,
    data: false
  }),
  onClick: e => {
    const {
      cell,
      posX: x,
      posY: y,
      bounds
    } = e;
    if (booleanCellIsEditable(cell) && Math.abs(x - bounds.width / 2) <= bounds.height / 3.4 && Math.abs(y - bounds.height / 2) <= bounds.height / 3.4) {
      return {
        ...cell,
        data: toggleBoolean(cell.data)
      };
    }
    return void 0;
  },
  onPaste: (toPaste, cell) => {
    let newVal = BooleanEmpty;
    if (toPaste.toLowerCase() === "true") {
      newVal = true;
    } else if (toPaste.toLowerCase() === "false") {
      newVal = false;
    } else if (toPaste.toLowerCase() === "indeterminate") {
      newVal = BooleanIndeterminate;
    }
    return newVal === cell.data ? void 0 : {
      ...cell,
      data: newVal
    };
  }
};

// src/data-editor/use-autoscroll.ts

var maxPxPerMs = 2;
var msToFullSpeed = 1300;
function useAutoscroll(scrollDirection, scrollRef) {
  const speedScalar = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const [xDir, yDir] = scrollDirection != null ? scrollDirection : [0, 0];
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (xDir === 0 && yDir === 0) {
      speedScalar.current = 0;
      return;
    }
    let lastTime = 0;
    const scrollFn = curTime => {
      var _a;
      if (lastTime === 0) {
        lastTime = curTime;
      } else {
        const step = curTime - lastTime;
        speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);
        const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;
        (_a = scrollRef.current) == null ? void 0 : _a.scrollBy(xDir * motion, yDir * motion);
        lastTime = curTime;
      }
      t = window.requestAnimationFrame(scrollFn);
    };
    let t = window.requestAnimationFrame(scrollFn);
    return () => window.cancelAnimationFrame(t);
  }, [scrollRef, xDir, yDir]);
}

// src/data-grid/cells/bubble-cell.tsx


// src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx


// src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx
var BubblesOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "BubblesOverlayEditorStyle",
  class: "b1bqsp5z"
});

// src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx
var BubblesOverlayEditor = p => {
  const {
    bubbles
  } = p;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(BubblesOverlayEditorStyle, null, bubbles.map((b, i) => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "boe-bubble"
  }, b)), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};
var bubbles_overlay_editor_default = BubblesOverlayEditor;

// src/data-grid/cells/bubble-cell.tsx
var bubbleCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Bubble,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawBubbles(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(bubbles_overlay_editor_default, {
      bubbles: value.data
    });
  },
  onPaste: () => void 0
};

// src/data-grid/cells/drilldown-cell.tsx


// src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx

var DrilldownOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "DrilldownOverlayEditorStyle",
  class: "df2kt4a"
});
var DrilldownOverlayEditor = p => {
  const {
    drilldowns
  } = p;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "doe-bubble"
  }, d.img !== void 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
    src: d.img
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, d.text))));
};
var drilldown_overlay_editor_default = DrilldownOverlayEditor;

// src/data-grid/cells/drilldown-cell.tsx
var drilldownCellRenderer = {
  getAccessibilityString: c => c.data.map(d => d.text).join(", "),
  kind: GridCellKind.Drilldown,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== void 0 ? 18 : 0), 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawDrilldownCell(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(drilldown_overlay_editor_default, {
      drilldowns: value.data
    });
  },
  onPaste: () => void 0
};

// src/data-grid/cells/image-cell.tsx


// src/data-grid-overlay-editor/private/image-overlay-editor.tsx


// src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx
var ImageOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "ImageOverlayEditorStyle",
  class: "i1eozt10"
});

// src/data-grid-overlay-editor/private/image-overlay-editor.tsx

var ImageOverlayEditor = p => {
  const {
    urls,
    canWrite,
    onEditClick,
    renderImage
  } = p;
  const filtered = urls.filter(u => u !== "");
  if (filtered.length === 0) {
    return null;
  }
  const allowMove = filtered.length > 1;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageOverlayEditorStyle, {
    "data-testid": "GDG-default-image-overlay-editor"
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__.Carousel, {
    showArrows: allowMove,
    showThumbs: false,
    swipeable: allowMove,
    emulateTouch: allowMove,
    infiniteLoop: allowMove
  }, filtered.map(url => {
    var _a;
    const innerContent = (_a = renderImage == null ? void 0 : renderImage(url)) != null ? _a : /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      draggable: false,
      src: url
    });
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "centering-container",
      key: url
    }, innerContent);
  })), canWrite && onEditClick && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "edit-icon",
    onClick: onEditClick
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)));
};

// src/data-grid/cells/image-cell.tsx
var imageCellRenderer = {
  getAccessibilityString: c => c.data.join(", "),
  kind: GridCellKind.Image,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  draw: a => {
    var _a;
    return drawImage(a, (_a = a.cell.displayData) != null ? _a : a.cell.data, a.cell.rounding);
  },
  measure: (_ctx, cell) => cell.data.length * 50,
  onDelete: c => ({
    ...c,
    data: []
  }),
  provideEditor: () => p => {
    const {
      value,
      onFinishedEditing,
      imageEditorOverride
    } = p;
    const ImageEditor = imageEditorOverride != null ? imageEditorOverride : ImageOverlayEditor;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageEditor, {
      urls: value.data,
      canWrite: value.allowAdd,
      onCancel: onFinishedEditing,
      onChange: newImage => {
        onFinishedEditing({
          ...value,
          data: [newImage]
        });
      }
    });
  },
  onPaste: (toPaste, cell) => {
    toPaste = toPaste.trim();
    const fragments = toPaste.split(",");
    const uris = fragments.map(f => {
      try {
        new URL(f);
        return f;
      } catch (e) {
        return void 0;
      }
    }).filter(x => x !== void 0);
    if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return void 0;
    return {
      ...cell,
      data: uris
    };
  }
};

// src/data-grid/cells/loading-cell.tsx
var loadingCellRenderer = {
  getAccessibilityString: () => "",
  kind: GridCellKind.Loading,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: () => 120,
  draw: () => void 0,
  onPaste: () => void 0
};

// src/data-grid/cells/markdown-cell.tsx


// src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx


// src/markdown-div/markdown-div.tsx



// src/markdown-div/private/markdown-container.tsx
var MarkdownContainer = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "MarkdownContainer",
  class: "mlbeo71"
});

// src/markdown-div/markdown-div.tsx
var MarkdownDiv = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.targetElement = null;
    this.containerRefHook = element => {
      this.targetElement = element;
      this.renderMarkdownIntoDiv();
    };
  }
  renderMarkdownIntoDiv() {
    const {
      targetElement,
      props
    } = this;
    if (targetElement === null) return;
    const {
      contents,
      createNode
    } = props;
    const innerHTML = (0,marked__WEBPACK_IMPORTED_MODULE_13__.marked)(contents);
    const childRange = document.createRange();
    childRange.selectNodeContents(targetElement);
    childRange.deleteContents();
    let newChild = createNode == null ? void 0 : createNode(innerHTML);
    if (newChild === void 0) {
      const childDoc = document.createElement("template");
      childDoc.innerHTML = innerHTML;
      newChild = childDoc.content;
    }
    targetElement.append(newChild);
    const tags = targetElement.getElementsByTagName("a");
    for (const tag of tags) {
      tag.target = "_blank";
      tag.rel = "noreferrer noopener";
    }
  }
  render() {
    this.renderMarkdownIntoDiv();
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownContainer, {
      ref: this.containerRefHook
    });
  }
};

// src/growing-entry/growing-entry.tsx


// src/growing-entry/growing-entry-style.tsx
var InputBox = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("textarea")({
  name: "InputBox",
  class: "ijuk0po"
});
var ShadowBox = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "ShadowBox",
  class: "saq3p5l"
});
var GrowingEntryStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "GrowingEntryStyle",
  class: "gf8vzix"
});

// src/growing-entry/growing-entry.tsx
var GrowingEntry = props => {
  const {
    placeholder,
    value,
    onKeyDown,
    highlight,
    altNewline,
    validatedSelection,
    ...rest
  } = props;
  const {
    onChange,
    className
  } = rest;
  const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const useText = value != null ? value : "";
  assert(onChange !== void 0, "GrowingEntry must be a controlled input area");
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const ta = inputRef.current;
    if (ta === null) return;
    if (ta.disabled) return;
    const length = useText.toString().length;
    ta.focus();
    ta.setSelectionRange(highlight ? 0 : length, length);
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    var _a;
    if (validatedSelection !== void 0) {
      const range2 = typeof validatedSelection === "number" ? [validatedSelection, null] : validatedSelection;
      (_a = inputRef.current) == null ? void 0 : _a.setSelectionRange(range2[0], range2[1]);
    }
  }, [validatedSelection]);
  const onKeyDownInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.key === "Enter" && e.shiftKey && altNewline === true) {
      return;
    }
    onKeyDown == null ? void 0 : onKeyDown(e);
  }, [altNewline, onKeyDown]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntryStyle, {
    className: "gdg-growing-entry"
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ShadowBox, {
    className
  }, useText + "\n"), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(InputBox, {
    ...rest,
    className: (className != null ? className : "") + " gdg-input",
    ref: inputRef,
    onKeyDown: onKeyDownInner,
    value: useText,
    placeholder,
    dir: "auto"
  }));
};

// src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx
var _exp12 = () => p => p.targetWidth;
var MarkdownOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "MarkdownOverlayEditorStyle",
  class: "mdwzdl1",
  vars: {
    "mdwzdl1-0": [_exp12(), "px"]
  }
});

// src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx
var MarkdownOverlayEditor = p => {
  const {
    value,
    onChange,
    forceEditMode,
    createNode,
    targetRect,
    onFinish,
    validatedSelection
  } = p;
  const markdown = value.data;
  const readonly = value.readonly === true;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(markdown === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(e => !e);
  }, []);
  const addLeftPad = markdown ? "ml-6" : "";
  if (editMode) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
      targetWidth: targetRect.width - 20
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      autoFocus: true,
      highlight: false,
      validatedSelection,
      value: markdown,
      onKeyDown: e => {
        if (e.key === "Enter") e.stopPropagation();
      },
      onChange
    }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: `edit-icon checkmark-hover ${addLeftPad}`,
      onClick: () => onFinish(value)
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Checkmark, null)));
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
    targetWidth: targetRect.width
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownDiv, {
    contents: markdown,
    createNode
  }), !readonly && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "spacer"
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: `edit-icon edit-hover ${addLeftPad}`,
    onClick: onEditClick
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null))), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "md-edit-textarea gdg-input",
    autoFocus: true
  }));
};

// src/data-grid/cells/markdown-cell.tsx
var markdownCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Markdown,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  measure: (ctx, cell, t) => {
    const firstLine = cell.data.split("\n")[0];
    return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;
  },
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  onDelete: c => ({
    ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      target,
      onFinishedEditing,
      markdownDivCreateNode,
      forceEditMode,
      validatedSelection
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditor, {
      onFinish: onFinishedEditing,
      targetRect: target,
      value,
      validatedSelection,
      onChange: e => onChange({
        ...value,
        data: e.target.value
      }),
      forceEditMode,
      createNode: markdownDivCreateNode
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : {
    ...cell,
    data: toPaste
  }
};

// src/data-grid/cells/marker-cell.tsx
var markerCellRenderer = {
  getAccessibilityString: c => c.row.toString(),
  kind: InnerGridCellKind.Marker,
  needsHover: true,
  needsHoverPosition: false,
  drawPrep: prepMarkerRowCell,
  measure: () => 44,
  draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),
  onClick: e => {
    const {
      bounds,
      cell,
      posX: x,
      posY: y
    } = e;
    const {
      width,
      height
    } = bounds;
    const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;
    const centerY = height / 2;
    if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {
      return {
        ...cell,
        checked: !cell.checked
      };
    }
    return void 0;
  },
  onPaste: () => void 0
};

// src/data-grid/cells/new-row-cell.tsx
var newRowCellRenderer = {
  getAccessibilityString: () => "",
  kind: InnerGridCellKind.NewRow,
  needsHover: true,
  needsHoverPosition: false,
  measure: () => 200,
  draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),
  onPaste: () => void 0
};

// src/data-grid/cells/number-cell.tsx

var NumberOverlayEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => await __webpack_require__.e(/*! import() */ "vendors-node_modules_glideapps_glide-data-grid_dist_js_number-overlay-editor-OFPFAI5Q_js").then(__webpack_require__.bind(__webpack_require__, /*! ./number-overlay-editor-OFPFAI5Q.js */ "../../node_modules/@glideapps/glide-data-grid/dist/js/number-overlay-editor-OFPFAI5Q.js")));
var numberCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Number,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.displayData, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,
  onDelete: c => ({
    ...c,
    data: void 0
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
      fallback: null
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(NumberOverlayEditor, {
      highlight: isHighlighted,
      disabled: value.readonly === true,
      value: value.data,
      validatedSelection,
      onChange: x => {
        var _a;
        return onChange({
          ...value,
          data: Number.isNaN((_a = x.floatValue) != null ? _a : 0) ? 0 : x.floatValue
        });
      }
    }));
  },
  onPaste: (toPaste, cell) => {
    const newNumber = Number.parseFloat(toPaste);
    if (Number.isNaN(newNumber) || cell.data === newNumber) return void 0;
    return {
      ...cell,
      data: newNumber
    };
  }
};

// src/data-grid/cells/protected-cell.tsx
var protectedCellRenderer = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: GridCellKind.Protected,
  needsHover: false,
  needsHoverPosition: false,
  draw: drawProtectedCell,
  onPaste: () => void 0
};

// src/data-grid/cells/row-id-cell.tsx

var rowIDCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.RowID,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: (a, b) => prepTextCell(a, b, a.theme.textLight),
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly !== false,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({
        ...value,
        data: e.target.value
      })
    });
  },
  onPaste: () => void 0
};

// src/data-grid/cells/text-cell.tsx

var textCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Text,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  useLabel: true,
  draw: a => (drawTextCell(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),
  measure: (ctx, cell, t) => {
    const lines = cell.displayData.split("\n").slice(0, cell.allowWrapping === true ? void 0 : 1);
    return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));
  },
  onDelete: c => ({
    ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly === true,
      altNewline: true,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({
        ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : {
    ...cell,
    data: toPaste
  }
};

// src/data-grid/cells/uri-cell.tsx


// src/data-grid-overlay-editor/private/uri-overlay-editor.tsx


// src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx
var UriOverlayEditorStyle = /* @__PURE__ */(0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__.styled_default)("div")({
  name: "UriOverlayEditorStyle",
  class: "uf0sjo8"
});

// src/data-grid-overlay-editor/private/uri-overlay-editor.tsx
var UriOverlayEditor = p => {
  const {
    uri,
    onChange,
    forceEditMode,
    readonly,
    validatedSelection
  } = p;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(uri === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(true);
  }, []);
  if (editMode) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      validatedSelection,
      highlight: true,
      autoFocus: true,
      value: uri,
      onChange
    });
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(UriOverlayEditorStyle, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "link-area",
    href: uri,
    target: "_blank",
    rel: "noopener noreferrer"
  }, uri), !readonly && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "edit-icon",
    onClick: onEditClick
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};
var uri_overlay_editor_default = UriOverlayEditor;

// src/data-grid/cells/uri-cell.tsx
var uriCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;
    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Uri,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  onDelete: c => ({
    ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      forceEditMode,
      validatedSelection
    } = p;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(uri_overlay_editor_default, {
      forceEditMode,
      uri: value.data,
      validatedSelection,
      readonly: value.readonly === true,
      onChange: e => onChange({
        ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : {
    ...cell,
    data: toPaste
  }
};

// src/data-grid/cells/index.ts
var CellRenderers = {
  [InnerGridCellKind.Marker]: markerCellRenderer,
  [InnerGridCellKind.NewRow]: newRowCellRenderer,
  [GridCellKind.Boolean]: booleanCellRenderer,
  [GridCellKind.Bubble]: bubbleCellRenderer,
  [GridCellKind.Drilldown]: drilldownCellRenderer,
  [GridCellKind.Image]: imageCellRenderer,
  [GridCellKind.Loading]: loadingCellRenderer,
  [GridCellKind.Markdown]: markdownCellRenderer,
  [GridCellKind.Number]: numberCellRenderer,
  [GridCellKind.Protected]: protectedCellRenderer,
  [GridCellKind.RowID]: rowIDCellRenderer,
  [GridCellKind.Text]: textCellRenderer,
  [GridCellKind.Uri]: uriCellRenderer
};

// src/data-editor/data-editor.tsx
var idCounter = 0;
function getSpanStops(cells) {
  return lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(cells).filter(c => c.span !== void 0).map(c => {
    var _a, _b, _c, _d;
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(((_b = (_a = c.span) == null ? void 0 : _a[0]) != null ? _b : 0) + 1, ((_d = (_c = c.span) == null ? void 0 : _c[1]) != null ? _d : 0) + 1);
  })));
}
function shiftSelection(input, offset) {
  if (input === void 0 || offset === 0 || input.columns.length === 0 && input.current === void 0) return input;
  return {
    current: input.current === void 0 ? void 0 : {
      cell: [input.current.cell[0] + offset, input.current.cell[1]],
      range: {
        ...input.current.range,
        x: input.current.range.x + offset
      },
      rangeStack: input.current.rangeStack.map(r => ({
        ...r,
        x: r.x + offset
      }))
    },
    rows: input.rows,
    columns: input.columns.offset(offset)
  };
}
var keybindingDefaults = {
  selectAll: true,
  selectRow: true,
  selectColumn: true,
  downFill: false,
  rightFill: false,
  pageUp: false,
  pageDown: false,
  clear: true,
  copy: true,
  paste: true,
  search: false,
  first: true,
  last: true
};
var loadingCell2 = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};
var emptyGridSelection = {
  columns: CompactSelection.empty(),
  rows: CompactSelection.empty(),
  current: void 0
};
var DataEditorImpl = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e;
  const [gridSelectionInner, setGridSelectionInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(emptyGridSelection);
  const [overlay, setOverlay] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchInputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [mouseState, setMouseState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const scrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const lastSent = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const {
    rowMarkers = "none",
    rowMarkerWidth: rowMarkerWidthRaw,
    imageEditorOverride,
    getRowThemeOverride,
    markdownDivCreateNode,
    width,
    height,
    columns: columnsIn,
    rows,
    getCellContent,
    onCellClicked,
    onCellActivated,
    onFinishedEditing,
    coercePasteValue,
    drawHeader: drawHeaderIn,
    onHeaderClicked,
    spanRangeBehavior = "default",
    onGroupHeaderClicked,
    onCellContextMenu,
    className,
    onHeaderContextMenu,
    getCellsForSelection: getCellsForSelectionIn,
    onGroupHeaderContextMenu,
    onGroupHeaderRenamed,
    onCellEdited,
    onCellsEdited,
    onKeyDown: onKeyDownIn,
    onKeyUp: onKeyUpIn,
    keybindings: keybindingsIn,
    onRowAppended,
    onColumnMoved,
    validateCell: validateCellIn,
    highlightRegions: highlightRegionsIn,
    drawCell: drawCell2,
    rangeSelect = "rect",
    columnSelect = "multi",
    rowSelect = "multi",
    rangeSelectionBlending = "exclusive",
    columnSelectionBlending = "exclusive",
    rowSelectionBlending = "exclusive",
    onDelete: onDeleteIn,
    onDragStart,
    onMouseMove,
    onPaste,
    copyHeaders = false,
    freezeColumns = 0,
    rowSelectionMode = "auto",
    rowMarkerStartIndex = 1,
    rowMarkerTheme,
    onHeaderMenuClick,
    getGroupDetails,
    onSearchClose: onSearchCloseIn,
    onItemHovered,
    onSelectionCleared,
    showSearch: showSearchIn,
    onVisibleRegionChanged,
    gridSelection: gridSelectionOuter,
    onGridSelectionChange,
    minColumnWidth: minColumnWidthIn = 50,
    maxColumnWidth: maxColumnWidthIn = 500,
    maxColumnAutoWidth: maxColumnAutoWidthIn,
    provideEditor,
    trailingRowOptions,
    scrollOffsetX,
    scrollOffsetY,
    verticalBorder,
    onDragOverCell,
    onDrop,
    onColumnResize: onColumnResizeIn,
    onColumnResizeEnd: onColumnResizeEndIn,
    onColumnResizeStart: onColumnResizeStartIn,
    customRenderers: additionalRenderers,
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX: overscrollXIn,
    overscrollY: overscrollYIn,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    scrollToEnd,
    scaleToRem = false,
    rowHeight: rowHeightIn = 34,
    headerHeight: headerHeightIn = 36,
    groupHeaderHeight: groupHeaderHeightIn = headerHeightIn,
    theme: themeIn
  } = p;
  const minColumnWidth = Math.max(minColumnWidthIn, 20);
  const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);
  const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn != null ? maxColumnAutoWidthIn : maxColumnWidth, minColumnWidth);
  const docStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (typeof window === "undefined") return {
      fontSize: "16px"
    };
    return window.getComputedStyle(document.documentElement);
  }, []);
  const fontSizeStr = docStyle.fontSize;
  const remSize = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => Number.parseFloat(fontSizeStr), [fontSizeStr]);
  const [rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2, _b2, _c2;
    if (!scaleToRem || remSize === 16) return [rowHeightIn, headerHeightIn, groupHeaderHeightIn, themeIn, overscrollXIn, overscrollYIn];
    const scaler = remSize / 16;
    const rh = rowHeightIn;
    const bt = getDataEditorTheme();
    return [typeof rh === "number" ? rh * scaler : n => Math.ceil(rh(n) * scaler), Math.ceil(headerHeightIn * scaler), Math.ceil(groupHeaderHeightIn * scaler), {
      ...themeIn,
      headerIconSize: ((_a2 = themeIn == null ? void 0 : themeIn.headerIconSize) != null ? _a2 : bt.headerIconSize) * scaler,
      cellHorizontalPadding: ((_b2 = themeIn == null ? void 0 : themeIn.cellHorizontalPadding) != null ? _b2 : bt.cellHorizontalPadding) * scaler,
      cellVerticalPadding: ((_c2 = themeIn == null ? void 0 : themeIn.cellVerticalPadding) != null ? _c2 : bt.cellVerticalPadding) * scaler
    }, Math.ceil((overscrollXIn != null ? overscrollXIn : 0) * scaler), Math.ceil((overscrollYIn != null ? overscrollYIn : 0) * scaler)];
  }, [groupHeaderHeightIn, headerHeightIn, overscrollXIn, overscrollYIn, remSize, rowHeightIn, scaleToRem, themeIn]);
  const keybindings = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return keybindingsIn === void 0 ? keybindingDefaults : {
      ...keybindingDefaults,
      ...keybindingsIn
    };
  }, [keybindingsIn]);
  const rowMarkerWidth = rowMarkerWidthRaw != null ? rowMarkerWidthRaw : rows > 1e4 ? 48 : rows > 1e3 ? 44 : rows > 100 ? 36 : 32;
  const hasRowMarkers = rowMarkers !== "none";
  const rowMarkerOffset = hasRowMarkers ? 1 : 0;
  const showTrailingBlankRow = onRowAppended !== void 0;
  const lastRowSticky = (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true;
  const [showSearchInner, setShowSearchInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const showSearch = showSearchIn != null ? showSearchIn : showSearchInner;
  const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (onSearchCloseIn !== void 0) {
      onSearchCloseIn();
    } else {
      setShowSearchInner(false);
    }
  }, [onSearchCloseIn]);
  const gridSelectionOuterMangled = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return gridSelectionOuter === void 0 ? void 0 : shiftSelection(gridSelectionOuter, rowMarkerOffset);
  }, [gridSelectionOuter, rowMarkerOffset]);
  const gridSelection = gridSelectionOuterMangled != null ? gridSelectionOuterMangled : gridSelectionInner;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      abortControllerRef == null ? void 0 : abortControllerRef.current.abort();
    };
  }, []);
  const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current);
  const validateCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue, prevValue) => {
    if (validateCellIn === void 0) return true;
    const item = [cell[0] - rowMarkerOffset, cell[1]];
    return validateCellIn == null ? void 0 : validateCellIn(item, newValue, prevValue);
  }, [rowMarkerOffset, validateCellIn]);
  const expectedExternalGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useRef(gridSelectionOuter);
  const setGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, expand) => {
    if (expand) {
      newVal = expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);
    }
    if (onGridSelectionChange !== void 0) {
      expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);
      onGridSelectionChange(expectedExternalGridSelection.current);
    } else {
      setGridSelectionInner(newVal);
    }
  }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);
  const onColumnResize = whenDefined(onColumnResizeIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeIn == null ? void 0 : onColumnResizeIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeEnd = whenDefined(onColumnResizeEndIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeEndIn == null ? void 0 : onColumnResizeEndIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeStart = whenDefined(onColumnResizeStartIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeStartIn == null ? void 0 : onColumnResizeStartIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));
  const drawHeader2 = whenDefined(drawHeaderIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2;
    return (_a2 = drawHeaderIn == null ? void 0 : drawHeaderIn({
      ...args,
      columnIndex: args.columnIndex - rowMarkerOffset
    })) != null ? _a2 : false;
  }, [drawHeaderIn, rowMarkerOffset]));
  const onDelete = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(sel => {
    if (onDeleteIn !== void 0) {
      const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));
      if (typeof result === "boolean") {
        return result;
      }
      return shiftSelection(result, rowMarkerOffset);
    }
    return true;
  }, [onDeleteIn, rowMarkerOffset]);
  const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);
  const mergedTheme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      ...getDataEditorTheme(),
      ...theme
    };
  }, [theme]);
  const [clientSize, setClientSize] = react__WEBPACK_IMPORTED_MODULE_0__.useState([10, 10, 0]);
  const getCellRenderer = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    if (cell.kind !== GridCellKind.Custom) {
      return CellRenderers[cell.kind];
    }
    return additionalRenderers == null ? void 0 : additionalRenderers.find(x => x.isMatch(cell));
  }, [additionalRenderers]);
  const columns = useColumnSizer(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);
  const enableGroups = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return columns.some(c => c.group !== void 0);
  }, [columns]);
  const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  const numSelectedRows = gridSelection.rows.length;
  const rowMarkerHeader = rowMarkers === "none" ? "" : numSelectedRows === 0 ? headerCellUnheckedMarker : numSelectedRows === rows ? headerCellCheckedMarker : headerCellIndeterminateMarker;
  const mangledCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (rowMarkers === "none") return columns;
    return [{
      title: rowMarkerHeader,
      width: rowMarkerWidth,
      icon: void 0,
      hasMenu: false,
      style: "normal",
      themeOverride: rowMarkerTheme
    }, ...columns];
  }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader, rowMarkerTheme]);
  const [visibleRegionY, visibleRegionTy] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [scrollOffsetY !== void 0 && typeof rowHeight === "number" ? Math.floor(scrollOffsetY / rowHeight) : 0, scrollOffsetY !== void 0 && typeof rowHeight === "number" ? -(scrollOffsetY % rowHeight) : 0];
  }, [scrollOffsetY, rowHeight]);
  const visibleRegionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  });
  const visibleRegionInput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2, _b2;
    return {
      x: visibleRegionRef.current.x,
      y: visibleRegionY,
      width: (_a2 = visibleRegionRef.current.width) != null ? _a2 : 1,
      height: (_b2 = visibleRegionRef.current.height) != null ? _b2 : 1,
      ty: visibleRegionTy
    };
  }, [visibleRegionTy, visibleRegionY]);
  const hasJustScrolled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const [visibleRegion, setVisibleRegion, empty2] = useStateWithReactiveInput(visibleRegionInput);
  visibleRegionRef.current = visibleRegion;
  const vScrollReady = ((_a = visibleRegion.height) != null ? _a : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetY !== void 0 && scrollRef.current !== null && vScrollReady) {
      if (scrollRef.current.scrollTop === scrollOffsetY) return;
      scrollRef.current.scrollTop = scrollOffsetY;
      if (scrollRef.current.scrollTop !== scrollOffsetY) {
        empty2();
      }
      hasJustScrolled.current = true;
    }
  }, [scrollOffsetY, vScrollReady, empty2]);
  const hScrollReady = ((_b = visibleRegion.width) != null ? _b : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetX !== void 0 && scrollRef.current !== null && hScrollReady) {
      if (scrollRef.current.scrollLeft === scrollOffsetX) return;
      scrollRef.current.scrollLeft = scrollOffsetX;
      if (scrollRef.current.scrollLeft !== scrollOffsetX) {
        empty2();
      }
      hasJustScrolled.current = true;
    }
  }, [scrollOffsetX, hScrollReady, empty2]);
  const cellXOffset = visibleRegion.x + rowMarkerOffset;
  const cellYOffset = visibleRegion.y;
  const gridRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(immediate => {
    var _a2;
    if (immediate === true) {
      (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    } else {
      window.requestAnimationFrame(() => {
        var _a3;
        (_a3 = gridRef.current) == null ? void 0 : _a3.focus();
      });
    }
  }, []);
  const mangledRows = showTrailingBlankRow ? rows + 1 : rows;
  const mangledOnCellsEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(items => {
    const mangledItems = rowMarkerOffset === 0 ? items : items.map(x => ({
      ...x,
      location: [x.location[0] - rowMarkerOffset, x.location[1]]
    }));
    const r = onCellsEdited == null ? void 0 : onCellsEdited(mangledItems);
    if (r !== true) {
      for (const i of mangledItems) onCellEdited == null ? void 0 : onCellEdited(i.location, i.value);
    }
    return r;
  }, [onCellEdited, onCellsEdited, rowMarkerOffset]);
  const highlightRegions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (highlightRegionsIn === void 0) return void 0;
    if (rowMarkerOffset === 0) return highlightRegionsIn;
    return highlightRegionsIn.map(r => {
      const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;
      if (maxWidth <= 0) return void 0;
      return {
        color: r.color,
        range: {
          ...r.range,
          x: r.range.x + rowMarkerOffset,
          width: Math.min(maxWidth, r.range.width)
        },
        style: r.style
      };
    }).filter(x => x !== void 0);
  }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);
  const mangledColsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(mangledCols);
  mangledColsRef.current = mangledCols;
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j;
    const isTrailing = showTrailingBlankRow && row === mangledRows - 1;
    const isRowMarkerCol = col === 0 && hasRowMarkers;
    if (isRowMarkerCol) {
      if (isTrailing) {
        return loadingCell2;
      }
      return {
        kind: InnerGridCellKind.Marker,
        allowOverlay: false,
        checked: (gridSelection == null ? void 0 : gridSelection.rows.hasIndex(row)) === true,
        markerKind: rowMarkers === "clickable-number" ? "number" : rowMarkers,
        row: rowMarkerStartIndex + row,
        drawHandle: onRowMoved !== void 0
      };
    } else if (isTrailing) {
      const isFirst = col === rowMarkerOffset;
      const maybeFirstColumnHint = isFirst ? (_a2 = trailingRowOptions == null ? void 0 : trailingRowOptions.hint) != null ? _a2 : "" : "";
      const c = mangledColsRef.current[col];
      if (((_b2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _b2.disabled) === true) {
        return loadingCell2;
      } else {
        const hint = (_d2 = (_c2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _c2.hint) != null ? _d2 : maybeFirstColumnHint;
        const icon = (_f = (_e2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _e2.addIcon) != null ? _f : trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon;
        return {
          kind: InnerGridCellKind.NewRow,
          hint,
          allowOverlay: false,
          icon
        };
      }
    } else {
      const outerCol = col - rowMarkerOffset;
      if ((experimental == null ? void 0 : experimental.strict) === true) {
        const vr = visibleRegionRef.current;
        const isOutsideMainArea = vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;
        const isSelected = outerCol === ((_h = (_g = vr.extras) == null ? void 0 : _g.selected) == null ? void 0 : _h[0]) && row === ((_i = vr.extras) == null ? void 0 : _i.selected[1]);
        const isOutsideFreezeArea = ((_j = vr.extras) == null ? void 0 : _j.freezeRegion) === void 0 || vr.extras.freezeRegion.x > outerCol || outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width || vr.extras.freezeRegion.y > row || row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;
        if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {
          return {
            kind: GridCellKind.Loading,
            allowOverlay: false
          };
        }
      }
      let result = getCellContent([outerCol, row]);
      if (rowMarkerOffset !== 0 && result.span !== void 0) {
        result = {
          ...result,
          span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset]
        };
      }
      return result;
    }
  }, [showTrailingBlankRow, mangledRows, hasRowMarkers, gridSelection == null ? void 0 : gridSelection.rows, onRowMoved, rowMarkers, rowMarkerOffset, trailingRowOptions == null ? void 0 : trailingRowOptions.hint, trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon, experimental == null ? void 0 : experimental.strict, getCellContent, rowMarkerStartIndex]);
  const mangledGetGroupDetails = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(group => {
    var _a2, _b2;
    let result = (_a2 = getGroupDetails == null ? void 0 : getGroupDetails(group)) != null ? _a2 : {
      name: group
    };
    if (onGroupHeaderRenamed !== void 0 && group !== "") {
      result = {
        icon: result.icon,
        name: result.name,
        overrideTheme: result.overrideTheme,
        actions: [...((_b2 = result.actions) != null ? _b2 : []), {
          title: "Rename",
          icon: "renameIcon",
          onClick: e => setRenameGroup({
            group: result.name,
            bounds: e.bounds
          })
        }]
      };
    }
    return result;
  }, [getGroupDetails, onGroupHeaderRenamed]);
  const setOverlaySimple = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(val => {
    var _a2;
    const [col, row] = val.cell;
    const column = mangledCols[col];
    const groupTheme = (column == null ? void 0 : column.group) !== void 0 ? (_a2 = mangledGetGroupDetails(column.group)) == null ? void 0 : _a2.overrideTheme : void 0;
    const colTheme = column == null ? void 0 : column.themeOverride;
    const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
    setOverlay({
      ...val,
      theme: {
        ...mergedTheme,
        ...groupTheme,
        ...colTheme,
        ...rowTheme,
        ...val.content.themeOverride
      }
    });
  }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);
  const reselect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((bounds, fromKeyboard, initialValue) => {
    var _a2;
    if (gridSelection.current === void 0) return;
    const [col, row] = gridSelection.current.cell;
    const c = getMangledCellContent([col, row]);
    if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {
      let content = c;
      if (initialValue !== void 0) {
        switch (content.kind) {
          case GridCellKind.Number:
            {
              const d = maybe(() => initialValue === "-" ? -0 : Number.parseFloat(initialValue), 0);
              content = {
                ...content,
                data: Number.isNaN(d) ? 0 : d
              };
              break;
            }
          case GridCellKind.Text:
          case GridCellKind.Markdown:
          case GridCellKind.Uri:
            content = {
              ...content,
              data: initialValue
            };
            break;
        }
      }
      setOverlaySimple({
        target: bounds,
        content,
        initialValue,
        cell: [col, row],
        highlight: initialValue === void 0,
        forceEditMode: initialValue !== void 0
      });
    } else if (c.kind === GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {
      mangledOnCellsEdited([{
        location: gridSelection.current.cell,
        value: {
          ...c,
          data: toggleBoolean(c.data)
        }
      }]);
      (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
        cell: gridSelection.current.cell
      }]);
    }
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);
  const focusOnRowFromTrailingBlankRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row) => {
    var _a2;
    const bounds = (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col, row);
    if (bounds === void 0 || scrollRef.current === null) {
      return;
    }
    const content = getMangledCellContent([col, row]);
    if (!content.allowOverlay) {
      return;
    }
    setOverlaySimple({
      target: bounds,
      content,
      initialValue: void 0,
      highlight: true,
      cell: [col, row],
      forceEditMode: true
    });
  }, [getMangledCellContent, setOverlaySimple]);
  const scrollTo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (col, row) {
    let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "both";
    let paddingX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let paddingY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : void 0;
    var _a2;
    if (scrollRef.current !== null) {
      const grid = gridRef.current;
      const canvas = canvasRef.current;
      const trueCol = typeof col !== "number" ? col.unit === "cell" ? col.amount : void 0 : col;
      const trueRow = typeof row !== "number" ? row.unit === "cell" ? row.amount : void 0 : row;
      const desiredX = typeof col !== "number" && col.unit === "px" ? col.amount : void 0;
      const desiredY = typeof row !== "number" && row.unit === "px" ? row.amount : void 0;
      if (grid !== null && canvas !== null) {
        let targetRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        let scrollX = 0;
        let scrollY = 0;
        if (trueCol !== void 0 || trueRow !== void 0) {
          targetRect = (_a2 = grid.getBounds((trueCol != null ? trueCol : 0) + rowMarkerOffset, trueRow != null ? trueRow : 0)) != null ? _a2 : targetRect;
          if (targetRect.width === 0 || targetRect.height === 0) return;
        }
        const scrollBounds = canvas.getBoundingClientRect();
        if (desiredX !== void 0) {
          targetRect = {
            ...targetRect,
            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,
            width: 1
          };
        }
        if (desiredY !== void 0) {
          targetRect = {
            ...targetRect,
            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,
            height: 1
          };
        }
        if (targetRect !== void 0) {
          const bounds = {
            x: targetRect.x - paddingX,
            y: targetRect.y - paddingY,
            width: targetRect.width + 2 * paddingX,
            height: targetRect.height + 2 * paddingY
          };
          let frozenWidth = 0;
          for (let i = 0; i < freezeColumns; i++) {
            frozenWidth += columns[i].width;
          }
          let trailingRowHeight = 0;
          if (lastRowSticky) {
            trailingRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows);
          }
          let sLeft = frozenWidth + scrollBounds.left + rowMarkerOffset * rowMarkerWidth;
          let sRight = scrollBounds.right;
          let sTop = scrollBounds.top + totalHeaderHeight;
          let sBottom = scrollBounds.bottom - trailingRowHeight;
          const minx = targetRect.width + paddingX * 2;
          switch (options == null ? void 0 : options.hAlign) {
            case "start":
              sRight = sLeft + minx;
              break;
            case "end":
              sLeft = sRight - minx;
              break;
            case "center":
              sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;
              sRight = sLeft + minx;
              break;
          }
          const miny = targetRect.height + paddingY * 2;
          switch (options == null ? void 0 : options.vAlign) {
            case "start":
              sBottom = sTop + miny;
              break;
            case "end":
              sTop = sBottom - miny;
              break;
            case "center":
              sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;
              sBottom = sTop + miny;
              break;
          }
          if (sLeft > bounds.x) {
            scrollX = bounds.x - sLeft;
          } else if (sRight < bounds.x + bounds.width) {
            scrollX = bounds.x + bounds.width - sRight;
          }
          if (sTop > bounds.y) {
            scrollY = bounds.y - sTop;
          } else if (sBottom < bounds.y + bounds.height) {
            scrollY = bounds.y + bounds.height - sBottom;
          }
          if (dir === "vertical" || col < freezeColumns) {
            scrollX = 0;
          } else if (dir === "horizontal") {
            scrollY = 0;
          }
          if (scrollX !== 0 || scrollY !== 0) {
            scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);
          }
        }
      }
    }
  }, [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]);
  const focusCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusOnRowFromTrailingBlankRow);
  const getCellContentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellContent);
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  focusCallback.current = focusOnRowFromTrailingBlankRow;
  getCellContentRef.current = getCellContent;
  rowsRef.current = rows;
  const appendRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async col => {
    var _a2;
    const c = mangledCols[col];
    if (((_a2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _a2.disabled) === true) {
      return;
    }
    const appendResult = onRowAppended == null ? void 0 : onRowAppended();
    let r = void 0;
    let bottom = true;
    if (appendResult !== void 0) {
      r = await appendResult;
      if (r === "top") bottom = false;
      if (typeof r === "number") bottom = false;
    }
    let backoff = 0;
    const doFocus = () => {
      if (rowsRef.current <= rows) {
        if (backoff < 500) {
          window.setTimeout(doFocus, backoff);
        }
        backoff = 50 + backoff * 2;
        return;
      }
      const row = typeof r === "number" ? r : bottom ? rows : 0;
      scrollTo(col - rowMarkerOffset, row);
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, false, false, "edit");
      const cell = getCellContentRef.current([col - rowMarkerOffset, row]);
      if (cell.allowOverlay && isReadWriteCell(cell) && cell.readonly !== true) {
        window.setTimeout(() => {
          focusCallback.current(col, row);
        }, 0);
      }
    };
    doFocus();
  }, [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const getCustomNewRowTargetColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2, _b2, _c2;
    const customTargetColumn = (_c2 = (_b2 = (_a2 = columns[col]) == null ? void 0 : _a2.trailingRowOptions) == null ? void 0 : _b2.targetColumn) != null ? _c2 : trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn;
    if (typeof customTargetColumn === "number") {
      const customTargetOffset = hasRowMarkers ? 1 : 0;
      return customTargetColumn + customTargetOffset;
    }
    if (typeof customTargetColumn === "object") {
      const maybeIndex = columnsIn.indexOf(customTargetColumn);
      if (maybeIndex >= 0) {
        const customTargetOffset = hasRowMarkers ? 1 : 0;
        return maybeIndex + customTargetOffset;
      }
    }
    return void 0;
  }, [columns, columnsIn, hasRowMarkers, trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn]);
  const lastSelectedRowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSelectedColRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const themeForCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, pos) => {
    var _a2;
    const [col, row] = pos;
    return {
      ...mergedTheme,
      ...((_a2 = mangledCols[col]) == null ? void 0 : _a2.themeOverride),
      ...(getRowThemeOverride == null ? void 0 : getRowThemeOverride(row)),
      ...cell.themeOverride
    };
  }, [getRowThemeOverride, mangledCols, mergedTheme]);
  const handleSelect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2, _c2, _d2;
    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const isMultiRow = isMultiKey && rowSelect === "multi";
    const isMultiCol = isMultiKey && columnSelect === "multi";
    const [col, row] = args.location;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const [cellCol, cellRow] = (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [];
    if (args.kind === "cell") {
      lastSelectedColRef.current = void 0;
      lastMouseSelectLocation.current = [col, row];
      if (col === 0 && hasRowMarkers) {
        if (showTrailingBlankRow === true && row === rows || rowMarkers === "number" || rowSelect === "none") return;
        const markerCell = getMangledCellContent(args.location);
        if (markerCell.kind !== InnerGridCellKind.Marker) {
          return;
        }
        if (onRowMoved !== void 0) {
          const renderer = getCellRenderer(markerCell);
          assert((renderer == null ? void 0 : renderer.kind) === InnerGridCellKind.Marker);
          const postClick = (_c2 = renderer == null ? void 0 : renderer.onClick) == null ? void 0 : _c2.call(renderer, {
            ...args,
            cell: markerCell,
            posX: args.localEventX,
            posY: args.localEventY,
            bounds: args.bounds,
            theme: themeForCell(markerCell, args.location),
            preventDefault: () => void 0
          });
          if (postClick === void 0 || postClick.checked === markerCell.checked) return;
        }
        setOverlay(void 0);
        focus();
        const isSelected = selectedRows.hasIndex(row);
        const lastHighlighted = lastSelectedRowRef.current;
        if (rowSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastHighlighted !== void 0 && selectedRows.hasIndex(lastHighlighted)) {
          const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];
          if (isMultiRow || rowSelectionMode === "multi") {
            setSelectedRows(void 0, newSlice, true);
          } else {
            setSelectedRows(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiRow);
          }
        } else if (isMultiRow || args.isTouch || rowSelectionMode === "multi") {
          if (isSelected) {
            setSelectedRows(selectedRows.remove(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
            lastSelectedRowRef.current = row;
          }
        } else if (isSelected && selectedRows.length === 1) {
          setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
        } else {
          setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, isMultiKey);
          lastSelectedRowRef.current = row;
        }
      } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {
        const customTargetColumn = getCustomNewRowTargetColumn(col);
        void appendRow(customTargetColumn != null ? customTargetColumn : col);
      } else {
        if (cellCol !== col || cellRow !== row) {
          const cell = getMangledCellContent(args.location);
          const renderer = getCellRenderer(cell);
          if ((renderer == null ? void 0 : renderer.onSelect) !== void 0) {
            let prevented = false;
            renderer.onSelect({
              ...args,
              cell,
              posX: args.localEventX,
              posY: args.localEventY,
              bounds: args.bounds,
              preventDefault: () => prevented = true,
              theme: themeForCell(cell, args.location)
            });
            if (prevented) {
              return;
            }
          }
          const isLastStickyRow = lastRowSticky && row === rows;
          const startedFromLastSticky = lastRowSticky && gridSelection !== void 0 && ((_d2 = gridSelection.current) == null ? void 0 : _d2.cell[1]) === rows;
          if ((args.shiftKey || args.isLongTouch === true) && cellCol !== void 0 && cellRow !== void 0 && gridSelection.current !== void 0 && !startedFromLastSticky) {
            if (isLastStickyRow) {
              return;
            }
            const left = Math.min(col, cellCol);
            const right = Math.max(col, cellCol);
            const top = Math.min(row, cellRow);
            const bottom = Math.max(row, cellRow);
            setCurrent({
              ...gridSelection.current,
              range: {
                x: left,
                y: top,
                width: right - left + 1,
                height: bottom - top + 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            focus();
          } else {
            setCurrent({
              cell: [col, row],
              range: {
                x: col,
                y: row,
                width: 1,
                height: 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            setOverlay(void 0);
            focus();
          }
        }
      }
    } else if (args.kind === "header") {
      lastMouseSelectLocation.current = [col, row];
      setOverlay(void 0);
      if (hasRowMarkers && col === 0) {
        lastSelectedRowRef.current = void 0;
        lastSelectedColRef.current = void 0;
        if (rowSelect === "multi") {
          if (selectedRows.length !== rows) {
            setSelectedRows(CompactSelection.fromSingleSelection([0, rows]), void 0, isMultiKey);
          } else {
            setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
          }
          focus();
        }
      } else {
        const lastCol = lastSelectedColRef.current;
        if (columnSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastCol !== void 0 && selectedColumns.hasIndex(lastCol)) {
          const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];
          if (isMultiCol) {
            setSelectedColumns(void 0, newSlice, isMultiKey);
          } else {
            setSelectedColumns(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiKey);
          }
        } else if (isMultiCol) {
          if (selectedColumns.hasIndex(col)) {
            setSelectedColumns(selectedColumns.remove(col), void 0, isMultiKey);
          } else {
            setSelectedColumns(void 0, col, isMultiKey);
          }
          lastSelectedColRef.current = col;
        } else if (columnSelect !== "none") {
          setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, isMultiKey);
          lastSelectedColRef.current = col;
        }
        lastSelectedRowRef.current = void 0;
        focus();
      }
    } else if (args.kind === groupHeaderKind) {
      lastMouseSelectLocation.current = [col, row];
    } else if (args.kind === outOfBoundsKind) {
      setGridSelection(emptyGridSelection, false);
      setOverlay(void 0);
      focus();
      onSelectionCleared == null ? void 0 : onSelectionCleared();
      lastSelectedRowRef.current = void 0;
      lastSelectedColRef.current = void 0;
    }
  }, [appendRow, columnSelect, focus, getCellRenderer, getCustomNewRowTargetColumn, getMangledCellContent, gridSelection, hasRowMarkers, lastRowSticky, onSelectionCleared, onRowMoved, rowMarkerOffset, rowMarkers, rowSelect, rowSelectionMode, rows, setCurrent, setGridSelection, setSelectedColumns, setSelectedRows, showTrailingBlankRow, themeForCell]);
  const lastMouseSelectLocation = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const touchDownArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visibleRegion);
  const mouseDownData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2;
    isPrevented.current = false;
    touchDownArgs.current = visibleRegionRef.current;
    if (args.button !== 0) {
      mouseDownData.current = void 0;
      return;
    }
    const time = performance.now();
    const wasDoubleClick = time - ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.time) != null ? _b2 : -1e3) < 250;
    mouseDownData.current = {
      wasDoubleClick,
      time,
      location: args.location
    };
    const fh = args.kind === "cell" && args.isFillHandle;
    if (!fh && args.kind !== "cell" && args.isEdge) return;
    setMouseState({
      previousSelection: gridSelection,
      fillHandle: fh
    });
    lastMouseSelectLocation.current = void 0;
    if (!args.isTouch) {
      handleSelect(args);
    }
  }, [gridSelection, handleSelect]);
  const [renameGroup, setRenameGroup] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const handleGroupHeaderSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.kind !== groupHeaderKind || columnSelect !== "multi") {
      return;
    }
    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const [col] = args.location;
    const selectedColumns = gridSelection.columns;
    if (col < rowMarkerOffset) return;
    const needle = mangledCols[col];
    let start = col;
    let end = col;
    for (let i = col - 1; i >= rowMarkerOffset; i--) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      start--;
    }
    for (let i = col + 1; i < mangledCols.length; i++) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      end++;
    }
    focus();
    if (isMultiKey) {
      if (selectedColumns.hasAll([start, end + 1])) {
        let newVal = selectedColumns;
        for (let index = start; index <= end; index++) {
          newVal = newVal.remove(index);
        }
        setSelectedColumns(newVal, void 0, isMultiKey);
      } else {
        setSelectedColumns(void 0, [start, end + 1], isMultiKey);
      }
    } else {
      setSelectedColumns(CompactSelection.fromSingleSelection([start, end + 1]), void 0, isMultiKey);
    }
  }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);
  const fillDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(reverse => {
    var _a2;
    if (gridSelection.current === void 0) return;
    const v = [];
    const r = gridSelection.current.range;
    for (let x = 0; x < r.width; x++) {
      const fillCol = x + r.x;
      const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);
      if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;
      for (let y = 1; y < r.height; y++) {
        const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;
        const target = [fillCol, fillRow];
        v.push({
          location: target,
          value: {
            ...fillVal
          }
        });
      }
    }
    mangledOnCellsEdited(v);
    (_a2 = gridRef.current) == null ? void 0 : _a2.damage(v.map(c => ({
      cell: c.location
    })));
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited]);
  const isPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const normalSizeColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async col => {
    var _a2;
    if (((_a2 = mouseDownData.current) == null ? void 0 : _a2.wasDoubleClick) === true && getCellsForSelection !== void 0 && onColumnResize !== void 0) {
      const start = visibleRegionRef.current.y;
      const end = visibleRegionRef.current.height;
      let cells = getCellsForSelection({
        x: col,
        y: start,
        width: 1,
        height: Math.min(end, rows - start)
      }, abortControllerRef.current.signal);
      if (typeof cells !== "object") {
        cells = await cells();
      }
      const inputCol = columns[col - rowMarkerOffset];
      const offscreen = document.createElement("canvas");
      const ctx = offscreen.getContext("2d", {
        alpha: false
      });
      if (ctx !== null) {
        ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;
        const newCol = measureColumn(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);
        onColumnResize == null ? void 0 : onColumnResize(inputCol, newCol.width, col, newCol.width);
      }
    }
  }, [columns, getCellsForSelection, maxColumnWidth, mergedTheme, minColumnWidth, onColumnResize, rowMarkerOffset, rows, getCellRenderer]);
  const [scrollDir, setScrollDir] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onMouseUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b2, _c2;
    const mouse = mouseState;
    setMouseState(void 0);
    setScrollDir(void 0);
    if (isOutside) return;
    if ((mouse == null ? void 0 : mouse.fillHandle) === true && gridSelection.current !== void 0) {
      fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);
      return;
    }
    const [col, row] = args.location;
    const [lastMouseDownCol, lastMouseDownRow] = (_a2 = lastMouseSelectLocation.current) != null ? _a2 : [];
    const preventDefault = () => {
      isPrevented.current = true;
    };
    const handleMaybeClick = a => {
      var _a3, _b3, _c3;
      if (a.isTouch || lastMouseDownCol === col && lastMouseDownRow === row) {
        onCellClicked == null ? void 0 : onCellClicked([col - rowMarkerOffset, row], {
          ...a,
          preventDefault
        });
      }
      if (!isPrevented.current) {
        const c = getMangledCellContent(args.location);
        const r = getCellRenderer(c);
        if (r !== void 0 && r.onClick !== void 0) {
          const newVal = r.onClick({
            ...a,
            cell: c,
            posX: a.localEventX,
            posY: a.localEventY,
            bounds: a.bounds,
            theme: themeForCell(c, args.location),
            preventDefault
          });
          if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
            mangledOnCellsEdited([{
              location: a.location,
              value: newVal
            }]);
            (_a3 = gridRef.current) == null ? void 0 : _a3.damage([{
              cell: a.location
            }]);
          }
        }
        if (!isPrevented.current && ((_c3 = (_b3 = mouse == null ? void 0 : mouse.previousSelection) == null ? void 0 : _b3.current) == null ? void 0 : _c3.cell) !== void 0 && gridSelection.current !== void 0) {
          const [selectedCol, selectedRow] = gridSelection.current.cell;
          const [prevCol, prevRow] = mouse.previousSelection.current.cell;
          if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
            onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
            reselect(a.bounds, false);
            return true;
          }
        }
      }
      return false;
    };
    const clickLocation = args.location[0] - rowMarkerOffset;
    if (args.isTouch) {
      const vr = visibleRegionRef.current;
      const touchVr = touchDownArgs.current;
      if (vr.x !== touchVr.x || vr.y !== touchVr.y) {
        return;
      }
      if (args.isLongTouch === true) {
        if (args.kind === "cell" && ((_b2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _b2.cell[0]) === col && ((_c2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c2.cell[1]) === row) {
          onCellContextMenu == null ? void 0 : onCellContextMenu([clickLocation, args.location[1]], {
            ...args,
            preventDefault
          });
          return;
        } else if (args.kind === "header" && gridSelection.columns.hasIndex(col)) {
          onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(clickLocation, {
            ...args,
            preventDefault
          });
          return;
        } else if (args.kind === groupHeaderKind) {
          if (clickLocation < 0) {
            return;
          }
          onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(clickLocation, {
            ...args,
            preventDefault
          });
          return;
        }
      }
      if (args.kind === "cell") {
        if (!handleMaybeClick(args)) {
          handleSelect(args);
        }
      } else if (args.kind === groupHeaderKind) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, {
          ...args,
          preventDefault
        });
      } else {
        if (args.kind === headerKind) {
          onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, {
            ...args,
            preventDefault
          });
        }
        handleSelect(args);
      }
      return;
    }
    if (args.kind === "header") {
      if (clickLocation < 0) {
        return;
      }
      if (args.isEdge) {
        void normalSizeColumn(col);
      } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, {
          ...args,
          preventDefault
        });
      }
    }
    if (args.kind === groupHeaderKind) {
      if (clickLocation < 0) {
        return;
      }
      if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, {
          ...args,
          preventDefault
        });
        if (!isPrevented.current) {
          handleGroupHeaderSelection(args);
        }
      }
    }
    if (args.kind === "cell" && args.button === 0) {
      handleMaybeClick(args);
    }
    lastMouseSelectLocation.current = void 0;
  }, [mouseState, rowMarkerOffset, gridSelection, onCellClicked, fillDown, getMangledCellContent, getCellRenderer, themeForCell, mangledOnCellsEdited, onCellActivated, reselect, onCellContextMenu, onHeaderContextMenu, onGroupHeaderContextMenu, handleSelect, onGroupHeaderClicked, normalSizeColumn, onHeaderClicked, handleGroupHeaderSelection]);
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const a = {
      ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    };
    onMouseMove == null ? void 0 : onMouseMove(a);
    setScrollDir(cv => {
      var _a2, _b2;
      if (args.scrollEdge[0] === (cv == null ? void 0 : cv[0]) && args.scrollEdge[1] === cv[1]) return cv;
      return mouseState === void 0 || ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.location[0]) != null ? _b2 : 0) < rowMarkerOffset ? void 0 : args.scrollEdge;
    });
  }, [mouseState, onMouseMove, rowMarkerOffset]);
  useAutoscroll(scrollDir, scrollRef);
  const onHeaderMenuClickInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
  }, [onHeaderMenuClick, rowMarkerOffset]);
  const currentCell = (_c = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c.cell;
  const onVisibleRegionChangedImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {
    hasJustScrolled.current = false;
    let selected = currentCell;
    if (selected !== void 0) {
      selected = [selected[0] - rowMarkerOffset, selected[1]];
    }
    const newRegion = {
      x: region.x - rowMarkerOffset,
      y: region.y,
      width: region.width,
      height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,
      tx,
      ty,
      extras: {
        selected,
        freezeRegion: freezeColumns === 0 ? void 0 : {
          x: 0,
          y: region.y,
          width: freezeColumns,
          height: region.height
        }
      }
    };
    setClientSize([clientWidth, clientHeight, rightElWidth]);
    setVisibleRegion(newRegion);
    onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);
  }, [currentCell, rowMarkerOffset, showTrailingBlankRow, rows, freezeColumns, setVisibleRegion, onVisibleRegionChanged]);
  const onColumnMovedImpl = whenDefined(onColumnMoved, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {
    onColumnMoved == null ? void 0 : onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);
    if (columnSelect !== "none") {
      setSelectedColumns(CompactSelection.fromSingleSelection(endIndex), void 0, true);
    }
  }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));
  const isActivelyDragging = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.location[0] === 0 && rowMarkerOffset > 0) {
      args.preventDefault();
      return;
    }
    onDragStart == null ? void 0 : onDragStart({
      ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
    if (!args.defaultPrevented()) {
      isActivelyDragging.current = true;
    }
    setMouseState(void 0);
  }, [onDragStart, rowMarkerOffset]);
  const onDragEnd = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    isActivelyDragging.current = false;
  }, []);
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2;
    if (mouseState !== void 0 && ((_a2 = mouseDownData.current) == null ? void 0 : _a2.location[0]) === 0 && args.location[0] === 0 && rowMarkerOffset === 1 && rowSelect === "multi" && mouseState.previousSelection && !mouseState.previousSelection.rows.hasIndex(mouseDownData.current.location[1]) && gridSelection.rows.hasIndex(mouseDownData.current.location[1])) {
      const start = Math.min(mouseDownData.current.location[1], args.location[1]);
      const end = Math.max(mouseDownData.current.location[1], args.location[1]) + 1;
      setSelectedRows(CompactSelection.fromSingleSelection([start, end]), void 0, false);
    }
    if (mouseState !== void 0 && gridSelection.current !== void 0 && !isActivelyDragging.current && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
      const [selectedCol, selectedRow] = gridSelection.current.cell;
      let [col, row] = args.location;
      if (row < 0) {
        row = visibleRegionRef.current.y;
      }
      const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;
      if (startedFromLastStickyRow) return;
      const landedOnLastStickyRow = lastRowSticky && row === rows;
      if (landedOnLastStickyRow) {
        if (args.kind === outOfBoundsKind) row--;else return;
      }
      col = Math.max(col, rowMarkerOffset);
      const deltaX = col - selectedCol;
      const deltaY = row - selectedRow;
      const newRange = {
        x: deltaX >= 0 ? selectedCol : col,
        y: deltaY >= 0 ? selectedRow : row,
        width: Math.abs(deltaX) + 1,
        height: Math.abs(deltaY) + 1
      };
      setCurrent({
        ...gridSelection.current,
        range: newRange
      }, true, false, "drag");
    }
    onItemHovered == null ? void 0 : onItemHovered({
      ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
  }, [mouseState, rowMarkerOffset, rowSelect, gridSelection, rangeSelect, onItemHovered, setSelectedRows, lastRowSticky, rows, setCurrent]);
  const adjustSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(direction2 => {
    if (gridSelection.current === void 0) return;
    const [x, y] = direction2;
    const [col, row] = gridSelection.current.cell;
    const old = gridSelection.current.range;
    let left = old.x;
    let right = old.x + old.width;
    let top = old.y;
    let bottom = old.y + old.height;
    if (y !== 0) {
      switch (y) {
        case 2:
          {
            bottom = rows;
            top = row;
            scrollTo(0, bottom, "vertical");
            break;
          }
        case -2:
          {
            top = 0;
            bottom = row + 1;
            scrollTo(0, top, "vertical");
            break;
          }
        case 1:
          {
            if (top < row) {
              top++;
              scrollTo(0, top, "vertical");
            } else {
              bottom = Math.min(rows, bottom + 1);
              scrollTo(0, bottom, "vertical");
            }
            break;
          }
        case -1:
          {
            if (bottom > row + 1) {
              bottom--;
              scrollTo(0, bottom, "vertical");
            } else {
              top = Math.max(0, top - 1);
              scrollTo(0, top, "vertical");
            }
            break;
          }
        default:
          {
            assertNever(y);
          }
      }
    }
    if (x !== 0) {
      if (x === 2) {
        right = mangledCols.length;
        left = col;
        scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
      } else if (x === -2) {
        left = rowMarkerOffset;
        right = col + 1;
        scrollTo(left - rowMarkerOffset, 0, "horizontal");
      } else {
        let disallowed = [];
        if (getCellsForSelection !== void 0) {
          const cells = getCellsForSelection({
            x: left,
            y: top,
            width: right - left - rowMarkerOffset,
            height: bottom - top
          }, abortControllerRef.current.signal);
          if (typeof cells === "object") {
            disallowed = getSpanStops(cells);
          }
        }
        if (x === 1) {
          let done = false;
          if (left < col) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));
              if (target !== void 0) {
                left = target;
                done = true;
              }
            } else {
              left++;
              done = true;
            }
            if (done) scrollTo(left, 0, "horizontal");
          }
          if (!done) {
            right = Math.min(mangledCols.length, right + 1);
            scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
          }
        } else if (x === -1) {
          let done = false;
          if (right > col + 1) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));
              if (target !== void 0) {
                right = target;
                done = true;
              }
            } else {
              right--;
              done = true;
            }
            if (done) scrollTo(right - rowMarkerOffset, 0, "horizontal");
          }
          if (!done) {
            left = Math.max(rowMarkerOffset, left - 1);
            scrollTo(left - rowMarkerOffset, 0, "horizontal");
          }
        } else {
          assertNever(x);
        }
      }
    }
    setCurrent({
      cell: gridSelection.current.cell,
      range: {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top
      }
    }, true, false, "keyboard-select");
  }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const updateSelectedCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row, fromEditingTrailingRow, freeMove) => {
    const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);
    col = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);
    row = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(row, 0, rowMax);
    if (col === (currentCell == null ? void 0 : currentCell[0]) && row === (currentCell == null ? void 0 : currentCell[1])) return false;
    if (freeMove && gridSelection.current !== void 0) {
      const newStack = [...gridSelection.current.rangeStack];
      if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {
        newStack.push(gridSelection.current.range);
      }
      setGridSelection({
        ...gridSelection,
        current: {
          cell: [col, row],
          range: {
            x: col,
            y: row,
            width: 1,
            height: 1
          },
          rangeStack: newStack
        }
      }, true);
    } else {
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-nav");
    }
    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      lastSent.current = void 0;
    }
    scrollTo(col - rowMarkerOffset, row);
    return true;
  }, [mangledRows, rowMarkerOffset, columns.length, currentCell, gridSelection, scrollTo, setGridSelection, setCurrent]);
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {
    if ((overlay == null ? void 0 : overlay.cell) !== void 0 && newValue !== void 0 && isEditableGridCell(newValue)) {
      mangledOnCellsEdited([{
        location: overlay.cell,
        value: newValue
      }]);
      window.requestAnimationFrame(() => {
        var _a2;
        (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
          cell: overlay.cell
        }]);
      });
    }
    focus(true);
    setOverlay(void 0);
    const [movX, movY] = movement;
    if (gridSelection.current !== void 0 && (movX !== 0 || movY !== 0)) {
      const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== void 0;
      updateSelectedCell(lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);
    }
    onFinishedEditing == null ? void 0 : onFinishedEditing(newValue, movement);
  }, [overlay == null ? void 0 : overlay.cell, focus, gridSelection, onFinishedEditing, mangledOnCellsEdited, mangledRows, updateSelectedCell, mangledCols.length]);
  const overlayID = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return `gdg-overlay-${idCounter++}`;
  }, []);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const fn = async () => {
      var _a2, _b2, _c2, _d2, _e2;
      let cancelled = false;
      if (onKeyDownIn !== void 0) {
        onKeyDownIn({
          ...event,
          cancel: () => {
            cancelled = true;
          }
        });
      }
      if (cancelled) return;
      const cancel = () => {
        event.stopPropagation();
        event.preventDefault();
      };
      const overlayOpen = overlay !== void 0;
      const {
        altKey,
        shiftKey,
        metaKey,
        ctrlKey,
        key,
        bounds
      } = event;
      const isOSX = browserIsOSX.value;
      const isPrimaryKey = isOSX ? metaKey : ctrlKey;
      const isDeleteKey = key === "Delete" || isOSX && key === "Backspace";
      const vr = visibleRegionRef.current;
      const selectedColumns = gridSelection.columns;
      const selectedRows = gridSelection.rows;
      if (key === "Escape") {
        if (overlayOpen) {
          setOverlay(void 0);
        } else if (keybindings.clear) {
          setGridSelection(emptyGridSelection, false);
          onSelectionCleared == null ? void 0 : onSelectionCleared();
        }
        return;
      } else if (isHotkey("primary+a", event) && keybindings.selectAll) {
        if (!overlayOpen) {
          setGridSelection({
            columns: CompactSelection.empty(),
            rows: CompactSelection.empty(),
            current: {
              cell: (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [rowMarkerOffset, 0],
              range: {
                x: rowMarkerOffset,
                y: 0,
                width: columnsIn.length,
                height: rows
              },
              rangeStack: []
            }
          }, false);
        } else {
          const el = document.getElementById(overlayID);
          if (el !== null) {
            const s = window.getSelection();
            const r = document.createRange();
            r.selectNodeContents(el);
            s == null ? void 0 : s.removeAllRanges();
            s == null ? void 0 : s.addRange(r);
          }
        }
        cancel();
        return;
      } else if (isHotkey("primary+f", event) && keybindings.search) {
        cancel();
        (_c2 = searchInputRef == null ? void 0 : searchInputRef.current) == null ? void 0 : _c2.focus({
          preventScroll: true
        });
        setShowSearchInner(true);
      }
      function deleteRange(r) {
        var _a3, _b3, _c3;
        focus();
        const editList = [];
        for (let x = r.x; x < r.x + r.width; x++) {
          for (let y = r.y; y < r.y + r.height; y++) {
            const cellValue = getCellContent([x - rowMarkerOffset, y]);
            if (!cellValue.allowOverlay && cellValue.kind !== GridCellKind.Boolean) continue;
            let newVal = void 0;
            if (cellValue.kind === GridCellKind.Custom) {
              const editor = provideEditor == null ? void 0 : provideEditor(cellValue);
              if (isObjectEditorCallbackResult(editor)) {
                newVal = (_a3 = editor == null ? void 0 : editor.deletedValue) == null ? void 0 : _a3.call(editor, cellValue);
              }
            } else if (isEditableGridCell(cellValue) && cellValue.allowOverlay || cellValue.kind === GridCellKind.Boolean) {
              const toDelete = getCellRenderer(cellValue);
              newVal = (_b3 = toDelete == null ? void 0 : toDelete.onDelete) == null ? void 0 : _b3.call(toDelete, cellValue);
            }
            if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
              editList.push({
                location: [x, y],
                value: newVal
              });
            }
          }
        }
        mangledOnCellsEdited(editList);
        (_c3 = gridRef.current) == null ? void 0 : _c3.damage(editList.map(x => ({
          cell: x.location
        })));
      }
      if (isDeleteKey) {
        const callbackResult = (_d2 = onDelete == null ? void 0 : onDelete(gridSelection)) != null ? _d2 : true;
        cancel();
        if (callbackResult !== false) {
          const toDelete = callbackResult === true ? gridSelection : callbackResult;
          if (toDelete.current !== void 0) {
            deleteRange(toDelete.current.range);
            for (const r of toDelete.current.rangeStack) {
              deleteRange(r);
            }
          }
          for (const r of toDelete.rows) {
            deleteRange({
              x: rowMarkerOffset,
              y: r,
              width: mangledCols.length - rowMarkerOffset,
              height: 1
            });
          }
          for (const col2 of toDelete.columns) {
            deleteRange({
              x: col2,
              y: 0,
              width: 1,
              height: rows
            });
          }
        }
        return;
      }
      if (gridSelection.current === void 0) return;
      let [col, row] = gridSelection.current.cell;
      let freeMove = false;
      if (keybindings.selectColumn && isHotkey("ctrl+ ", event) && columnSelect !== "none") {
        if (selectedColumns.hasIndex(col)) {
          setSelectedColumns(selectedColumns.remove(col), void 0, true);
        } else {
          if (columnSelect === "single") {
            setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, true);
          } else {
            setSelectedColumns(void 0, col, true);
          }
        }
      } else if (keybindings.selectRow && isHotkey("shift+ ", event) && rowSelect !== "none") {
        if (selectedRows.hasIndex(row)) {
          setSelectedRows(selectedRows.remove(row), void 0, true);
        } else {
          if (rowSelect === "single") {
            setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
          }
        }
      } else if ((isHotkey("Enter", event) || isHotkey(" ", event) || isHotkey("shift+Enter", event)) && bounds !== void 0) {
        if (overlayOpen) {
          setOverlay(void 0);
          if (isHotkey("Enter", event)) {
            row++;
          } else if (isHotkey("shift+Enter", event)) {
            row--;
          }
        } else if (row === rows && showTrailingBlankRow) {
          window.setTimeout(() => {
            const customTargetColumn = getCustomNewRowTargetColumn(col);
            void appendRow(customTargetColumn != null ? customTargetColumn : col);
          }, 0);
        } else {
          onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
          reselect(bounds, true);
          cancel();
        }
      } else if (keybindings.downFill && isHotkey("primary+_68", event) && gridSelection.current.range.height > 1) {
        fillDown(false);
        cancel();
      } else if (keybindings.rightFill && isHotkey("primary+_82", event) && gridSelection.current.range.width > 1) {
        const editList = [];
        const r = gridSelection.current.range;
        for (let y = 0; y < r.height; y++) {
          const fillRow = y + r.y;
          const fillVal = getMangledCellContent([r.x, fillRow]);
          if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;
          for (let x = 1; x < r.width; x++) {
            const fillCol = x + r.x;
            const target = [fillCol, fillRow];
            editList.push({
              location: target,
              value: {
                ...fillVal
              }
            });
          }
        }
        mangledOnCellsEdited(editList);
        (_e2 = gridRef.current) == null ? void 0 : _e2.damage(editList.map(c => ({
          cell: c.location
        })));
        cancel();
      } else if (keybindings.pageDown && isHotkey("PageDown", event)) {
        row += Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.pageUp && isHotkey("PageUp", event)) {
        row -= Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.first && isHotkey("primary+Home", event)) {
        setOverlay(void 0);
        row = 0;
        col = 0;
      } else if (keybindings.last && isHotkey("primary+End", event)) {
        setOverlay(void 0);
        row = Number.MAX_SAFE_INTEGER;
        col = Number.MAX_SAFE_INTEGER;
      } else if (keybindings.first && isHotkey("primary+shift+Home", event)) {
        setOverlay(void 0);
        adjustSelection([-2, -2]);
      } else if (keybindings.last && isHotkey("primary+shift+End", event)) {
        setOverlay(void 0);
        adjustSelection([2, 2]);
      } else if (key === "ArrowDown") {
        if (ctrlKey && altKey) {
          return;
        }
        setOverlay(void 0);
        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }
          if (isPrimaryKey && !altKey) {
            row = rows - 1;
          } else {
            row += 1;
          }
        }
      } else if (key === "ArrowUp" || key === "Home") {
        const asPrimary = key === "Home" || isPrimaryKey;
        setOverlay(void 0);
        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, asPrimary && !altKey ? -2 : -1]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }
          row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "ArrowRight" || key === "End") {
        const asPrimary = key === "End" || isPrimaryKey;
        setOverlay(void 0);
        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }
          col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;
        }
      } else if (key === "ArrowLeft") {
        setOverlay(void 0);
        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }
          col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "Tab") {
        setOverlay(void 0);
        if (shiftKey) {
          col--;
        } else {
          col++;
        }
      } else if (!metaKey && !ctrlKey && gridSelection.current !== void 0 && key.length === 1 && /[ -~]/g.test(key) && bounds !== void 0 && isReadWriteCell(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))) {
        if ((!lastRowSticky || row !== rows) && (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {
          return;
        }
        reselect(bounds, true, key);
        cancel();
      }
      const moved = updateSelectedCell(col, row, false, freeMove);
      if (moved) {
        cancel();
      }
    };
    void fn();
  }, [onKeyDownIn, overlay, gridSelection, keybindings.selectAll, keybindings.search, keybindings.selectColumn, keybindings.selectRow, keybindings.downFill, keybindings.rightFill, keybindings.pageDown, keybindings.pageUp, keybindings.first, keybindings.last, keybindings.clear, columnSelect, rowSelect, getCellContent, rowMarkerOffset, updateSelectedCell, setGridSelection, onSelectionCleared, columnsIn.length, rows, overlayID, focus, mangledOnCellsEdited, provideEditor, getCellRenderer, onDelete, mangledCols.length, setSelectedColumns, setSelectedRows, showTrailingBlankRow, getCustomNewRowTargetColumn, appendRow, onCellActivated, reselect, fillDown, getMangledCellContent, adjustSelection, rangeSelect, lastRowSticky]);
  const onContextMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, preventDefault) => {
    const adjustedCol = args.location[0] - rowMarkerOffset;
    if (args.kind === "header") {
      onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(adjustedCol, {
        ...args,
        preventDefault
      });
    }
    if (args.kind === groupHeaderKind) {
      if (adjustedCol < 0) {
        return;
      }
      onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(adjustedCol, {
        ...args,
        preventDefault
      });
    }
    if (args.kind === "cell") {
      const [col, row] = args.location;
      onCellContextMenu == null ? void 0 : onCellContextMenu([adjustedCol, row], {
        ...args,
        preventDefault
      });
      if (!gridSelectionHasItem(gridSelection, args.location)) {
        updateSelectedCell(col, row, false, false);
      }
    }
  }, [gridSelection, onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset, updateSelectedCell]);
  const onPasteInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async e => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g;
    if (!keybindings.paste) return;
    function pasteToCell(inner, target2, toPaste) {
      var _a3, _b3;
      if (!isInnerOnlyCell(inner) && isReadWriteCell(inner) && inner.readonly !== true) {
        const coerced = coercePasteValue == null ? void 0 : coercePasteValue(toPaste, inner);
        if (coerced !== void 0 && isEditableGridCell(coerced)) {
          if (coerced.kind !== inner.kind) {
            console.warn("Coercion should not change cell kind.");
          }
          return {
            location: target2,
            value: coerced
          };
        }
        const r = getCellRenderer(inner);
        if (r === void 0) return void 0;
        if (r.kind === GridCellKind.Custom) {
          assert(inner.kind === GridCellKind.Custom);
          const newVal = (_a3 = r.onPaste) == null ? void 0 : _a3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          return {
            location: target2,
            value: {
              ...inner,
              data: newVal
            }
          };
        } else {
          const newVal = (_b3 = r.onPaste) == null ? void 0 : _b3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          assert(newVal.kind === inner.kind);
          return {
            location: target2,
            value: newVal
          };
        }
      }
      return void 0;
    }
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const focused = ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    let target = (_c2 = gridSelection.current) == null ? void 0 : _c2.cell;
    if (target === void 0 && selectedColumns.length === 1) {
      target = [(_d2 = selectedColumns.first()) != null ? _d2 : 0, 0];
    }
    if (target === void 0 && selectedRows.length === 1) {
      target = [rowMarkerOffset, (_e2 = selectedRows.first()) != null ? _e2 : 0];
    }
    if (focused && target !== void 0) {
      let data;
      let text;
      const textPlain = "text/plain";
      const textHtml = "text/html";
      if (navigator.clipboard.read !== void 0) {
        const clipboardContent = await navigator.clipboard.read();
        for (const item of clipboardContent) {
          if (item.types.includes(textHtml)) {
            const htmlBlob = await item.getType(textHtml);
            const html = await htmlBlob.text();
            const fragment = document.createElement("html");
            fragment.innerHTML = html;
            const el = fragment.querySelector("table");
            if (el !== null) {
              data = decodeHTML(el);
              break;
            }
          }
          if (item.types.includes(textPlain)) {
            text = await (await item.getType(textPlain)).text();
          }
        }
      } else if (navigator.clipboard.readText !== void 0) {
        text = await navigator.clipboard.readText();
      } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
        if (e.clipboardData.types.includes(textHtml)) {
          const html = e.clipboardData.getData(textHtml);
          const fragment = document.createElement("html");
          fragment.innerHTML = html;
          const el = fragment.querySelector("table");
          if (el !== null) {
            data = decodeHTML(el);
          }
        }
        if (data === void 0 && e.clipboardData.types.includes(textPlain)) {
          text = e.clipboardData.getData(textPlain);
        }
      } else {
        return;
      }
      const [gridCol, gridRow] = target;
      const editList = [];
      do {
        if (onPaste === void 0) {
          const cellData = getMangledCellContent(target);
          const newVal = pasteToCell(cellData, target, (_f = text != null ? text : data == null ? void 0 : data.map(r => r.join("	")).join("	")) != null ? _f : "");
          if (newVal !== void 0) {
            editList.push(newVal);
          }
          break;
        }
        if (data === void 0) {
          if (text === void 0) return;
          data = unquote(text);
        }
        if (onPaste === false || typeof onPaste === "function" && (onPaste == null ? void 0 : onPaste([target[0] - rowMarkerOffset, target[1]], data)) !== true) {
          return;
        }
        for (const [row, dataRow] of data.entries()) {
          if (row + gridRow >= rows) break;
          for (const [col, dataItem] of dataRow.entries()) {
            const index = [col + gridCol, row + gridRow];
            const cellData = getMangledCellContent(index);
            const newVal = pasteToCell(cellData, index, dataItem);
            if (newVal !== void 0) {
              editList.push(newVal);
            }
          }
        }
      } while (false);
      mangledOnCellsEdited(editList);
      (_g = gridRef.current) == null ? void 0 : _g.damage(editList.map(c => ({
        cell: c.location
      })));
    }
  }, [coercePasteValue, getCellRenderer, getMangledCellContent, gridSelection, keybindings.paste, mangledOnCellsEdited, onPaste, rowMarkerOffset, rows]);
  useEventListener("paste", onPasteInternal, window, false, true);
  const onCopy = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e, ignoreFocus) => {
    var _a2, _b2;
    if (!keybindings.copy) return;
    const focused = ignoreFocus === true || ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const copyToClipboardWithHeaders = (cells, columnIndexes) => {
      if (!copyHeaders) {
        copyToClipboard(cells, columnIndexes, e);
      } else {
        const headers = columnIndexes.map(index => ({
          kind: GridCellKind.Text,
          data: columnsIn[index].title,
          displayData: columnsIn[index].title,
          allowOverlay: false
        }));
        copyToClipboard([headers, ...cells], columnIndexes, e);
      }
    };
    if (focused && getCellsForSelection !== void 0) {
      if (gridSelection.current !== void 0) {
        let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);
        if (typeof thunk !== "object") {
          thunk = await thunk();
        }
        copyToClipboardWithHeaders(thunk, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset));
      } else if (selectedRows !== void 0 && selectedRows.length > 0) {
        const toCopy = [...selectedRows];
        const cells = toCopy.map(rowIndex => {
          const thunk = getCellsForSelection({
            x: rowMarkerOffset,
            y: rowIndex,
            width: columnsIn.length - rowMarkerOffset,
            height: 1
          }, abortControllerRef.current.signal);
          if (typeof thunk === "object") {
            return thunk[0];
          }
          return thunk().then(v => v[0]);
        });
        if (cells.some(x => x instanceof Promise)) {
          const settled = await Promise.all(cells);
          copyToClipboardWithHeaders(settled, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));
        } else {
          copyToClipboardWithHeaders(cells, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));
        }
      } else if (selectedColumns.length > 0) {
        const results = [];
        const cols = [];
        for (const col of selectedColumns) {
          let thunk = getCellsForSelection({
            x: col,
            y: 0,
            width: 1,
            height: rows
          }, abortControllerRef.current.signal);
          if (typeof thunk !== "object") {
            thunk = await thunk();
          }
          results.push(thunk);
          cols.push(col - rowMarkerOffset);
        }
        if (results.length === 1) {
          copyToClipboardWithHeaders(results[0], cols);
        } else {
          const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));
          copyToClipboardWithHeaders(toCopy, cols);
        }
      }
    }
  }, [columnsIn, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows, copyHeaders]);
  useEventListener("copy", onCopy, window, false, false);
  const onSearchResultsChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((results, navIndex) => {
    if (results.length === 0 || navIndex === -1) return;
    const [col, row] = results[navIndex];
    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      return;
    }
    lastSent.current = [col, row];
    updateSelectedCell(col, row, false, false);
  }, [updateSelectedCell]);
  const [outCol, outRow] = (_e = (_d = gridSelectionOuter == null ? void 0 : gridSelectionOuter.current) == null ? void 0 : _d.cell) != null ? _e : [];
  const scrollToRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(scrollTo);
  scrollToRef.current = scrollTo;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    var _a2, _b2, _c2, _d2;
    if (!hasJustScrolled.current && outCol !== void 0 && outRow !== void 0 && (outCol !== ((_b2 = (_a2 = expectedExternalGridSelection.current) == null ? void 0 : _a2.current) == null ? void 0 : _b2.cell[0]) || outRow !== ((_d2 = (_c2 = expectedExternalGridSelection.current) == null ? void 0 : _c2.current) == null ? void 0 : _d2.cell[1]))) {
      scrollToRef.current(outCol, outRow);
    }
    hasJustScrolled.current = false;
  }, [outCol, outRow]);
  const disabledRows = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (showTrailingBlankRow === true && (trailingRowOptions == null ? void 0 : trailingRowOptions.tint) === true) {
      return CompactSelection.fromSingleSelection(mangledRows - 1);
    }
    return CompactSelection.empty();
  }, [mangledRows, showTrailingBlankRow, trailingRowOptions == null ? void 0 : trailingRowOptions.tint]);
  const mangledVerticalBorder = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2;
    return typeof verticalBorder === "boolean" ? verticalBorder : (_a2 = verticalBorder == null ? void 0 : verticalBorder(col - rowMarkerOffset)) != null ? _a2 : true;
  }, [rowMarkerOffset, verticalBorder]);
  const renameGroupNode = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (renameGroup === void 0 || canvasRef.current === null) return null;
    const {
      bounds,
      group
    } = renameGroup;
    const canvasBounds = canvasRef.current.getBoundingClientRect();
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(GroupRename, {
      bounds,
      group,
      canvasBounds,
      onClose: () => setRenameGroup(void 0),
      onFinish: newVal => {
        setRenameGroup(void 0);
        onGroupHeaderRenamed == null ? void 0 : onGroupHeaderRenamed(group, newVal);
      }
    });
  }, [onGroupHeaderRenamed, renameGroup]);
  const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    appendRow: col => appendRow(col + rowMarkerOffset),
    updateCells: damageList => {
      var _a2;
      if (rowMarkerOffset !== 0) {
        damageList = damageList.map(x => ({
          cell: [x.cell[0] + rowMarkerOffset, x.cell[1]]
        }));
      }
      return (_a2 = gridRef.current) == null ? void 0 : _a2.damage(damageList);
    },
    getBounds: (col, row) => {
      var _a2;
      return (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col + rowMarkerOffset, row);
    },
    focus: () => {
      var _a2;
      return (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    },
    emit: async e => {
      switch (e) {
        case "delete":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: false,
            key: "Delete",
            keyCode: 46,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;
        case "fill-right":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "r",
            keyCode: 82,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;
        case "fill-down":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "d",
            keyCode: 68,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;
        case "copy":
          await onCopy(void 0, true);
          break;
        case "paste":
          await onPasteInternal();
          break;
      }
    },
    scrollTo
  }), [appendRow, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);
  const [selCol, selRow] = currentCell != null ? currentCell : [];
  const onCellFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    if (row === -1) {
      if (columnSelect !== "none") {
        setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, false);
        focus();
      }
      return;
    }
    if (selCol === col && selRow === row) return;
    setCurrent({
      cell,
      range: {
        x: col,
        y: row,
        width: 1,
        height: 1
      }
    }, true, false, "keyboard-nav");
    scrollTo(col, row);
  }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);
  const [isFocused, setIsFocused] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const setIsFocusedDebounced = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(val => {
    setIsFocused(val);
  }, 5));
  const onCanvasFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(true);
    if (gridSelection.current === void 0 && gridSelection.columns.length === 0 && gridSelection.rows.length === 0 && mouseState === void 0) {
      setCurrent({
        cell: [rowMarkerOffset, cellYOffset],
        range: {
          x: rowMarkerOffset,
          y: cellYOffset,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-select");
    }
  }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);
  const onFocusOut = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(false);
  }, []);
  const [idealWidth, idealHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2;
    let h;
    const scrollbarWidth = (_a2 = experimental == null ? void 0 : experimental.scrollbarWidthOverride) != null ? _a2 : getScrollBarWidth();
    const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);
    if (typeof rowHeight === "number") {
      h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;
    } else {
      let avg = 0;
      const toAverage = Math.min(rowsCountWithTrailingRow, 10);
      for (let i = 0; i < toAverage; i++) {
        avg += rowHeight(i);
      }
      avg = Math.floor(avg / toAverage);
      h = totalHeaderHeight + rowsCountWithTrailingRow * avg;
    }
    h += scrollbarWidth;
    const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;
    return [`${Math.min(1e5, w)}px`, `${Math.min(1e5, h)}px`];
  }, [mangledCols, experimental == null ? void 0 : experimental.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: mergedTheme
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataEditorContainer, {
    style: makeCSSStyle(mergedTheme),
    className,
    inWidth: width != null ? width : idealWidth,
    inHeight: height != null ? height : idealHeight
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_search_default, {
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    getRowThemeOverride,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX,
    overscrollY,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    className,
    enableGroups,
    onCanvasFocused,
    onCanvasBlur: onFocusOut,
    canvasRef,
    onContextMenu,
    theme: mergedTheme,
    cellXOffset,
    cellYOffset,
    accessibilityHeight: visibleRegion.height,
    onDragEnd,
    columns: mangledCols,
    drawCustomCell: drawCell2,
    drawHeader: drawHeader2,
    disabledRows,
    freezeColumns: mangledFreezeColumns,
    lockColumns: rowMarkerOffset,
    firstColAccessible: rowMarkerOffset === 0,
    getCellContent: getMangledCellContent,
    minColumnWidth,
    maxColumnWidth,
    searchInputRef,
    showSearch,
    onSearchClose,
    highlightRegions,
    getCellsForSelection,
    getGroupDetails: mangledGetGroupDetails,
    headerHeight,
    isFocused,
    groupHeaderHeight: enableGroups ? groupHeaderHeight : 0,
    trailingRowType: !showTrailingBlankRow ? "none" : (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true ? "sticky" : "appended",
    onColumnResize,
    onColumnResizeEnd,
    onColumnResizeStart,
    onCellFocused,
    onColumnMoved: onColumnMovedImpl,
    onDragStart: onDragStartImpl,
    onHeaderMenuClick: onHeaderMenuClickInner,
    onItemHovered: onItemHoveredImpl,
    isFilling: (mouseState == null ? void 0 : mouseState.fillHandle) === true,
    onMouseMove: onMouseMoveImpl,
    onKeyDown,
    onKeyUp: onKeyUpIn,
    onMouseDown,
    onMouseUp,
    onDragOverCell,
    onDrop,
    onSearchResultsChanged,
    onVisibleRegionChanged: onVisibleRegionChangedImpl,
    clientSize: [clientSize[0], clientSize[1]],
    rowHeight,
    rows: mangledRows,
    scrollRef,
    selection: gridSelection,
    translateX: visibleRegion.tx,
    translateY: visibleRegion.ty,
    verticalBorder: mangledVerticalBorder,
    gridRef,
    getCellRenderer,
    scrollToEnd
  }), renameGroupNode, overlay !== void 0 && /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_overlay_editor_default, {
    ...overlay,
    validateCell,
    id: overlayID,
    getCellRenderer,
    className: (experimental == null ? void 0 : experimental.isSubGrid) === true ? "click-outside-ignore" : void 0,
    provideEditor,
    imageEditorOverride,
    onFinishEditing,
    markdownDivCreateNode
  })));
};
var DataEditor = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataEditorImpl);

// src/data-editor/use-custom-cells.ts

function inflate(input) {
  return {
    ...input,
    kind: GridCellKind.Custom
  };
}
function useCustomCells(cells) {
  return {
    customRenderers: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cells.map(inflate), [cells])
  };
}


/***/ }),

/***/ "../../node_modules/canvas-hypertxt/dist/js/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/canvas-hypertxt/dist/js/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearCache": () => (/* binding */ v),
/* harmony export */   "split": () => (/* binding */ _)
/* harmony export */ });


var d = new Map(),
  b = new Map(),
  z = new Map();
function v() {
  d.clear(), z.clear(), b.clear();
}
function w(l, s, e, c, t) {
  var n, r, o;
  let f = 0,
    a = {};
  for (let i of l) f += (n = e.get(i)) != null ? n : t, a[i] = ((r = a[i]) != null ? r : 0) + 1;
  let g = s - f;
  for (let i of Object.keys(a)) {
    let m = a[i],
      u = (o = e.get(i)) != null ? o : t,
      h = u * m / f,
      M = g * h * c / m,
      C = u + M;
    e.set(i, C);
  }
}
function R(l, s) {
  var n;
  let e = new Map(),
    c = 0;
  for (let r of "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890,.-+=?") {
    let o = l.measureText(r).width;
    e.set(r, o), c += o;
  }
  let t = c / e.size,
    f = 3,
    a = (s / t + f) / (f + 1),
    g = e.keys();
  for (let r of g) e.set(r, ((n = e.get(r)) != null ? n : t) * a);
  return e;
}
function p(l, s, e, c) {
  var g, n;
  let t = b.get(e);
  if (c && t !== void 0 && t.count > 2e4) {
    let r = z.get(e);
    if (r === void 0 && (r = R(l, t.size), z.set(e, r)), t.count > 5e5) {
      let i = 0;
      for (let m of s) i += (g = r.get(m)) != null ? g : t.size;
      return i * 1.01;
    }
    let o = l.measureText(s);
    return w(s, o.width, r, Math.max(.05, 1 - t.count / 2e5), t.size), b.set(e, {
      count: t.count + s.length,
      size: t.size
    }), o.width;
  }
  let f = l.measureText(s),
    a = f.width / s.length;
  if (((n = t == null ? void 0 : t.count) != null ? n : 0) > 2e4) return f.width;
  if (t === void 0) b.set(e, {
    count: s.length,
    size: a
  });else {
    let r = a - t.size,
      o = s.length / (t.count + s.length),
      i = t.size + r * o;
    b.set(e, {
      count: t.count + s.length,
      size: i
    });
  }
  return f.width;
}
function T(l, s, e, c, t, f, a, g) {
  if (s.length <= 1) return s.length;
  if (t < e) return -1;
  let n = Math.floor(e / t * f),
    r = p(l, s.slice(0, Math.max(0, n)), c, a),
    o = g == null ? void 0 : g(s);
  if (r !== e) if (r < e) {
    for (; r < e;) n++, r = p(l, s.slice(0, Math.max(0, n)), c, a);
    n--;
  } else for (; r > e;) {
    let i = o !== void 0 ? 0 : s.lastIndexOf(" ", n - 1);
    i > 0 ? n = i : n--, r = p(l, s.slice(0, Math.max(0, n)), c, a);
  }
  if (s[n] !== " ") {
    let i = 0;
    if (o === void 0) i = s.lastIndexOf(" ", n);else for (let m of o) {
      if (m > n) break;
      i = m;
    }
    i > 0 && (n = i);
  }
  return n;
}
function _(l, s, e, c, t, f) {
  let a = `${s}_${e}_${c}px`,
    g = d.get(a);
  if (g !== void 0) return g;
  if (c <= 0) return [];
  let n = [],
    r = s.split(`
`),
    o = b.get(e),
    i = o === void 0 ? s.length : c / o.size * 1.5,
    m = t && o !== void 0 && o.count > 2e4;
  for (let u of r) {
    let h = p(l, u.slice(0, Math.max(0, i)), e, m),
      M = Math.min(u.length, i);
    if (h <= c) n.push(u);else {
      for (; h > c;) {
        let C = T(l, u, c, e, h, M, m, f),
          k = u.slice(0, Math.max(0, C));
        u = u.slice(k.length), n.push(k), h = p(l, u.slice(0, Math.max(0, i)), e, m), M = Math.min(u.length, i);
      }
      h > 0 && n.push(u);
    }
  }
  return n = n.map((u, h) => h === 0 ? u.trimEnd() : u.trim()), d.set(a, n), d.size > 500 && d.delete(d.keys().next().value), n;
}


/***/ }),

/***/ "../../node_modules/marked/lib/marked.esm.js":
/*!***************************************************!*\
  !*** ../../node_modules/marked/lib/marked.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lexer": () => (/* binding */ Lexer),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Renderer": () => (/* binding */ Renderer),
/* harmony export */   "Slugger": () => (/* binding */ Slugger),
/* harmony export */   "TextRenderer": () => (/* binding */ TextRenderer),
/* harmony export */   "Tokenizer": () => (/* binding */ Tokenizer),
/* harmony export */   "defaults": () => (/* binding */ defaults),
/* harmony export */   "getDefaults": () => (/* binding */ getDefaults),
/* harmony export */   "lexer": () => (/* binding */ lexer),
/* harmony export */   "marked": () => (/* binding */ marked),
/* harmony export */   "options": () => (/* binding */ options),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseInline": () => (/* binding */ parseInline),
/* harmony export */   "parser": () => (/* binding */ parser),
/* harmony export */   "setOptions": () => (/* binding */ setOptions),
/* harmony export */   "use": () => (/* binding */ use),
/* harmony export */   "walkTokens": () => (/* binding */ walkTokens)
/* harmony export */ });
/**
 * marked v4.2.12 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}

/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
const getEscapeReplacement = ch => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

/**
 * @param {string} html
 */
function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}
const caret = /(^|[^\[])\^/g;

/**
 * @param {string | RegExp} regex
 * @param {string} opt
 */
function edit(regex, opt) {
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

/**
 * @param {boolean} sanitize
 * @param {string} base
 * @param {string} href
 */
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

/**
 * @param {string} base
 * @param {string} href
 */
function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];
  const relativeBase = base.indexOf(':') === -1;
  if (href.substring(0, 2) === '//') {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, '$1') + href;
  } else if (href.charAt(0) === '/') {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, '$1') + href;
  } else {
    return base + href;
  }
}
const noopTest = {
  exec: function noopTest() {}
};
function merge(obj) {
  let i = 1,
    target,
    key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
    cells = row.split(/ \|/);
  let i = 0;

  // First/last cell in a row cannot be empty if it has no leading/trailing pipe
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }
  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param {string} str
 * @param {string} c
 * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  let suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0,
    i = 0;
  for (; i < l; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

// copied from https://stackoverflow.com/a/5450113/806777
/**
 * @param {string} pattern
 * @param {number} count
 */
function repeatString(pattern, count) {
  if (count < 1) {
    return '';
  }
  let result = '';
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, '$1');
  if (cap[0].charAt(0) !== '!') {
    lexer.state.inLink = true;
    const token = {
      type: 'link',
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: 'image',
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split('\n').map(node => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join('\n');
}

/**
 * Tokenizer
 */
class Tokenizer {
  constructor(options) {
    this.options = options || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: 'space',
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, '');
      return {
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic ? rtrim(text, '\n') : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || '');
      return {
        type: 'code',
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, '#');
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
        }
      }
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: 'hr',
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, '');
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: 'blockquote',
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : '[*+-]';
      }

      // Get next list item
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);

      // Check if current bullet point can start a new List Item
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          // End list if bullet was actually HR (possibly move into itemRegex?)
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split('\n', 1)[0].replace(/^\t+/, t => ' '.repeat(3 * t.length));
        nextLine = src.split('\n', 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/); // Find first non-space char
          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          // Items begin with at most one blank line
          raw += nextLine + '\n';
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);

          // Check if following lines should be included in List Item
          while (src) {
            rawLine = src.split('\n', 1)[0];
            nextLine = rawLine;

            // Re-align to follow commonmark nesting rules
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
            }

            // End list item if found code fences
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new heading
            if (headingBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new bullet
            if (nextBulletRegex.test(nextLine)) {
              break;
            }

            // Horizontal rule found
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              // Dedent if possible
              itemContents += '\n' + nextLine.slice(indent);
            } else {
              // not enough indentation
              if (blankLine) {
                break;
              }

              // paragraph continuation unless last line was a different block level element
              if (line.search(/[^ ]/) >= 4) {
                // indented code block
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += '\n' + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              // Check if current line is blank
              blankLine = true;
            }
            raw += rawLine + '\n';
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          // If the previous item ended with a blank line, the list is loose
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }

        // Check for task list items
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== '[ ] ';
            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
          }
        }
        list.items.push({
          type: 'list_item',
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }

      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;

      // Item child tokens handled here at end because we needed to have the final item to trim it first
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          // Check if list should be loose
          const spacers = list.items[i].tokens.filter(t => t.type === 'space');
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }

      // Set all items to loose if list is loose
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: 'html',
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
      return {
        type: 'def',
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: 'table',
        header: splitCells(cap[1]).map(c => {
          return {
            text: c
          };
        }),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => {
            return {
              text: c
            };
          });
        }

        // parse child tokens inside headers and cells

        // header child tokens
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }

        // cell child tokens
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
      return {
        type: 'paragraph',
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? 'text' : 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        // commonmark requires matching angle brackets
        if (!/>$/.test(trimmedUrl)) {
          return;
        }

        // ending angle bracket cannot be escaped
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        // find closing parenthesis
        const lastParenIndex = findClosingBracket(cap[2], '()');
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf('!') === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
        }
      }
      let href = cap[2];
      let title = '';
      if (this.options.pedantic) {
        // split pedantic href and title
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: 'text',
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc) {
    let prevChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
    const nextChar = match[1] || match[2] || '';
    if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim,
        rLength,
        delimTotal = lLength,
        midDelimTotal = 0;
      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      // Clip maskedSrc to same section of string as src (move to lexer?)
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue; // skip single * in __abc*abc__

        rLength = rDelim.length;
        if (match[3] || match[4]) {
          // found another Left Delim
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
          }
        }

        delimTotal -= rLength;
        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // Remove extra characters. *a*** -> *a*
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

        // Create `em` if smallest delimiter has odd char count. *a***
        if (Math.min(lLength, rLength) % 2) {
          const text = raw.slice(1, -1);
          return {
            type: 'em',
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }

        // Create 'strong' if smallest delimiter has even char count. **a***
        const text = raw.slice(2, -2);
        return {
          type: 'strong',
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, ' ');
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: 'codespan',
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: 'br',
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: 'del',
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [{
          type: 'text',
          raw: text,
          text
        }]
      };
    }
  }
  url(src, mangle) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [{
          type: 'text',
          raw: text,
          text
        }]
      };
    }
  }
  inlineText(src, smartypants) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
      }
      return {
        type: 'text',
        raw: cap[0],
        text
      };
    }
  }
}

/**
 * Block-Level Grammar
 */
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: '^ {0,3}(?:' // optional indentation
  + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
  + '|comment[^\\n]*(\\n+|$)' // (2)
  + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
  + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
  + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
  + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
  + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
  + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
  + ')',
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  table: '^ *([^\\n ].*\\|.*)\\n' // Header
  + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
  + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
});

block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
.getRegex();
block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('table', block.gfm.table) // interrupt paragraphs with table
.replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge({}, block.normal, {
  html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
  + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
});

/**
 * Inline-Level Grammar
 */
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
  + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
  + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
  + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
  + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
  },

  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};

// list of punctuation marks from CommonMark spec
// without * and _ to handle the different emphasis markers * and _
inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
// lookbehind is not available on Safari as of version 16
// inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
});

/**
 * smartypants text replacement
 * @param {string} text
 */
function smartypants(text) {
  return text
  // em-dashes
  .replace(/---/g, '\u2014')
  // en-dashes
  .replace(/--/g, '\u2013')
  // opening singles
  .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
  // closing singles & apostrophes
  .replace(/'/g, '\u2019')
  // opening doubles
  .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
  // closing doubles
  .replace(/"/g, '\u201d')
  // ellipses
  .replace(/\.{3}/g, '\u2026');
}

/**
 * mangle email addresses
 * @param {string} text
 */
function mangle(text) {
  let out = '',
    i,
    ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }
  return out;
}

/**
 * Block Lexer
 */
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }

  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }

  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }

  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }

  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, '\n');
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }

  /**
   * Lexing
   */
  blockTokens(src) {
    let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (this.options.pedantic) {
      src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + '    '.repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(extTokenizer => {
        if (token = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // newline
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          // if there's a single \n as a spacer, it's terminating the last line,
          // so move it there so that we don't get unecessary paragraph tags
          tokens[tokens.length - 1].raw += '\n';
        } else {
          tokens.push(token);
        }
        continue;
      }

      // code
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        // An indented code block cannot interrupt a paragraph.
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // fences
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // heading
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // hr
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // blockquote
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // list
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // html
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // def
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }

      // table (gfm)
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // lheading
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // top-level paragraph
      // prevent paragraph consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function (getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === 'number' && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === 'paragraph') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }

      // text
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src) {
    let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    this.inlineQueue.push({
      src,
      tokens
    });
    return tokens;
  }

  /**
   * Lexing/Compiling
   */
  inlineTokens(src) {
    let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let token, lastToken, cutSrc;

    // String with links masked to avoid interference with em and strong
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;

    // Mask out reflinks
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    // Mask out other blocks
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }

    // Mask out escaped em & strong delimiters
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = '';
      }
      keepPrevChar = false;

      // extensions
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(extTokenizer => {
        if (token = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // escape
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // tag
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // link
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // reflink, nolink
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // em & strong
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // code
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // br
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // del (gfm)
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // autolink
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // url (gfm)
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // text
      // prevent inlineText consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function (getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === 'number' && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== '_') {
          // Track prevChar before string of ____ started
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}

/**
 * Renderer
 */
class Renderer {
  constructor(options) {
    this.options = options || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, '') + '\n';
    if (!lang) {
      return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
  }

  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  }
  html(html) {
    return html;
  }

  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>\n`;
    }

    // ignore IDs
    return `<h${level}>${text}</h${level}>\n`;
  }
  hr() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  }
  list(body, ordered, start) {
    const type = ordered ? 'ol' : 'ul',
      startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  }

  /**
   * @param {string} text
   */
  listitem(text) {
    return `<li>${text}</li>\n`;
  }
  checkbox(checked) {
    return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
  }

  /**
   * @param {string} text
   */
  paragraph(text) {
    return `<p>${text}</p>\n`;
  }

  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body) body = `<tbody>${body}</tbody>`;
    return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
  }

  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>\n${content}</tr>\n`;
  }
  tablecell(content, flags) {
    const type = flags.header ? 'th' : 'td';
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>\n`;
  }

  /**
   * span level renderer
   * @param {string} text
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }

  /**
   * @param {string} text
   */
  em(text) {
    return `<em>${text}</em>`;
  }

  /**
   * @param {string} text
   */
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? '<br/>' : '<br>';
  }

  /**
   * @param {string} text
   */
  del(text) {
    return `<del>${text}</del>`;
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  }
  text(text) {
    return text;
  }
}

/**
 * TextRenderer
 * returns only the textual part of the token
 */
class TextRenderer {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return '' + text;
  }
  image(href, title, text) {
    return '' + text;
  }
  br() {
    return '';
  }
}

/**
 * Slugger generates header id
 */
class Slugger {
  constructor() {
    this.seen = {};
  }

  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim()
    // remove html tags
    .replace(/<[!\/a-z].*?>/ig, '')
    // remove unwanted chars
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
  }

  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }

  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}

/**
 * Parsing & Compiling
 */
class Parser {
  constructor(options) {
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }

  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }

  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }

  /**
   * Parse Loop
   */
  parse(tokens) {
    let top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    let out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox,
      ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'space':
          {
            continue;
          }
        case 'hr':
          {
            out += this.renderer.hr();
            continue;
          }
        case 'heading':
          {
            out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
            continue;
          }
        case 'code':
          {
            out += this.renderer.code(token.text, token.lang, token.escaped);
            continue;
          }
        case 'table':
          {
            header = '';

            // header
            cell = '';
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                header: true,
                align: token.align[j]
              });
            }
            header += this.renderer.tablerow(cell);
            body = '';
            l2 = token.rows.length;
            for (j = 0; j < l2; j++) {
              row = token.rows[j];
              cell = '';
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                  header: false,
                  align: token.align[k]
                });
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
        case 'blockquote':
          {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
        case 'list':
          {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = '';
            for (j = 0; j < l2; j++) {
              item = token.items[j];
              checked = item.checked;
              task = item.task;
              itemBody = '';
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                      item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: 'text',
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
        case 'html':
          {
            // TODO parse inline content if parameter markdown=1
            out += this.renderer.html(token.text);
            continue;
          }
        case 'paragraph':
          {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
        case 'text':
          {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === 'text') {
              token = tokens[++i];
              body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
        default:
          {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  }

  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = '',
      i,
      token,
      ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'escape':
          {
            out += renderer.text(token.text);
            break;
          }
        case 'html':
          {
            out += renderer.html(token.text);
            break;
          }
        case 'link':
          {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
        case 'image':
          {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
        case 'strong':
          {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'em':
          {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'codespan':
          {
            out += renderer.codespan(token.text);
            break;
          }
        case 'br':
          {
            out += renderer.br();
            break;
          }
        case 'del':
          {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'text':
          {
            out += renderer.text(token.text);
            break;
          }
        default:
          {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  }
}

/**
 * Marked
 */
function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
  }
  if (typeof opt === 'function') {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function (err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length) return done();
    let pending = 0;
    marked.walkTokens(tokens, function (token) {
      if (token.type === 'code') {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function (err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  function onError(e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
    }
    throw e;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      if (opt.async) {
        return Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => {
          return Parser.parse(tokens, opt);
        }).catch(onError);
      }
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    onError(e);
  }
}

/**
 * Options
 */

marked.options = marked.setOptions = function (opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;

/**
 * Use Extension
 */

marked.use = function () {
  const extensions = marked.defaults.extensions || {
    renderers: {},
    childTokens: {}
  };
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach(pack => {
    // copy options to new object
    const opts = merge({}, pack);

    // set async to true if it was set to true before
    opts.async = marked.defaults.async || opts.async;

    // ==-- Parse "addon" extensions --== //
    if (pack.extensions) {
      pack.extensions.forEach(ext => {
        if (!ext.name) {
          throw new Error('extension name required');
        }
        if (ext.renderer) {
          // Renderer extensions
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            // Replace extension with func to run new extension but fall back if false
            extensions.renderers[ext.name] = function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              let ret = ext.renderer.apply(this, args);
              if (ret === false) {
                ret = prevRenderer.apply(this, args);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          // Tokenizer Extensions
          if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            // Function to check for start of token
            if (ext.level === 'block') {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === 'inline') {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          // Child tokens to be visited by walkTokens
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }

    // ==-- Parse "overwrite" extensions --== //
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        // Replace renderer with func to run extension, but fall back if false
        renderer[prop] = function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          let ret = pack.renderer[prop].apply(renderer, args);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        // Replace tokenizer with func to run extension, but fall back if false
        tokenizer[prop] = function () {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          let ret = pack.tokenizer[prop].apply(tokenizer, args);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }

    // ==-- Parse WalkTokens extensions --== //
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function (token) {
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens) {
          values = values.concat(walkTokens.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};

/**
 * Run callback for every token
 */

marked.walkTokens = function (tokens, callback) {
  let values = [];
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case 'table':
        {
          for (const cell of token.header) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
          for (const row of token.rows) {
            for (const cell of row) {
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
      case 'list':
        {
          values = values.concat(marked.walkTokens(token.items, callback));
          break;
        }
      default:
        {
          if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
            // Walk any extensions
            marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
              values = values.concat(marked.walkTokens(token[childTokens], callback));
            });
          } else if (token.tokens) {
            values = values.concat(marked.walkTokens(token.tokens, callback));
          }
        }
    }
  }
  return values;
};

/**
 * Parse Inline
 * @param {string} src
 */
marked.parseInline = function (src, opt) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked.parseInline(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
    }
    throw e;
  }
};

/**
 * Expose
 */
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const walkTokens = marked.walkTokens;
const parseInline = marked.parseInline;
const parse = marked;
const parser = Parser.parse;
const lexer = Lexer.lex;


/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayLikeToArray)
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithHoles)
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithoutHoles)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/extends.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArray)
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArrayLimit)
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableRest)
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableSpread)
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutProperties)
/* harmony export */ });
/* harmony import */ var _objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = (0,_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _slicedToArray)
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _taggedTemplateLiteral)
/* harmony export */ });
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toConsumableArray)
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _unsupportedIterableToArray)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "../../node_modules/react-select/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "../../node_modules/react-select/node_modules/@emotion/react/node_modules/@babel/runtime/helpers/esm/extends.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/react-select/node_modules/@emotion/react/node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_glideapps_glide-data-grid_dist_index_css-node_modules_glideapps_glide-da-1c06b4.chunk.js.map