(globalThis["webpackChunk_stlite_mountable"] = globalThis["webpackChunk_stlite_mountable"] || []).push([["vendors-node_modules_baseui_esm_slider_slider_js-node_modules_sprintf-js_src_sprintf_js"],{

/***/ "../../node_modules/baseui/esm/slider/slider.js":
/*!******************************************************!*\
  !*** ../../node_modules/baseui/esm/slider/slider.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-range */ "../../node_modules/react-range/lib/index.js");
/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_range__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_focusVisible__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/focusVisible */ "../../node_modules/baseui/esm/utils/focusVisible.js");
/* harmony import */ var _styled_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styled-components */ "../../node_modules/baseui/esm/slider/styled-components.js");
/* harmony import */ var _helpers_overrides__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/overrides */ "../../node_modules/baseui/esm/helpers/overrides.js");
/* harmony import */ var _styles_theme_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/theme-provider */ "../../node_modules/baseui/esm/styles/theme-provider.js");
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/







// value.length should not be bigger than two
// because our design doesn't support more than
// two thumbs
var limitValue = function limitValue(value) {
  if (value.length > 2 || value.length === 0) {
    throw new Error('the value prop represents positions of thumbs, so its length can be only one or two');
  }
  return value;
};
function Slider(_ref) {
  var _ref$overrides = _ref.overrides,
    overrides = _ref$overrides === void 0 ? {} : _ref$overrides,
    _ref$disabled = _ref.disabled,
    disabled = _ref$disabled === void 0 ? false : _ref$disabled,
    _ref$marks = _ref.marks,
    marks = _ref$marks === void 0 ? false : _ref$marks,
    _ref$onChange = _ref.onChange,
    _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
    _ref$onFinalChange = _ref.onFinalChange,
    _onFinalChange = _ref$onFinalChange === void 0 ? function () {} : _ref$onFinalChange,
    _ref$min = _ref.min,
    min = _ref$min === void 0 ? 0 : _ref$min,
    _ref$max = _ref.max,
    max = _ref$max === void 0 ? 100 : _ref$max,
    _ref$step = _ref.step,
    step = _ref$step === void 0 ? 1 : _ref$step,
    _ref$persistentThumb = _ref.persistentThumb,
    persistentThumb = _ref$persistentThumb === void 0 ? false : _ref$persistentThumb,
    _ref$valueToLabel = _ref.valueToLabel,
    valueToLabel = _ref$valueToLabel === void 0 ? function (label) {
      return label;
    } : _ref$valueToLabel,
    providedValue = _ref.value;
  var theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_styles_theme_provider__WEBPACK_IMPORTED_MODULE_2__.ThemeContext);
  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    isHovered0 = _React$useState2[0],
    setIsHovered0 = _React$useState2[1];
  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    isHovered1 = _React$useState4[0],
    setIsHovered1 = _React$useState4[1];
  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    isFocusVisible = _React$useState6[0],
    setIsFocusVisible = _React$useState6[1];
  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(-1),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    focusedThumbIndex = _React$useState8[0],
    setFocusedThumbIndex = _React$useState8[1];
  var handleFocus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {
    if ((0,_utils_focusVisible__WEBPACK_IMPORTED_MODULE_3__.isFocusVisible)(event)) {
      setIsFocusVisible(true);
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

    var index = event.target.parentNode.firstChild === event.target ? 0 : 1;
    setFocusedThumbIndex(index);
  }, []); // eslint-disable-next-line @typescript-eslint/no-unused-vars

  var handleBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {
    if (isFocusVisible !== false) {
      setIsFocusVisible(false);
    }
    setFocusedThumbIndex(-1);
  }, []);
  var value = limitValue(providedValue);
  var sharedProps = {
    $disabled: disabled,
    $step: step,
    $min: min,
    $max: max,
    $marks: marks,
    $value: value,
    $isFocusVisible: isFocusVisible
  };
  var _getOverrides = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Root, _styled_components__WEBPACK_IMPORTED_MODULE_5__.Root),
    _getOverrides2 = _slicedToArray(_getOverrides, 2),
    Root = _getOverrides2[0],
    rootProps = _getOverrides2[1];
  var _getOverrides3 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Track, _styled_components__WEBPACK_IMPORTED_MODULE_5__.Track),
    _getOverrides4 = _slicedToArray(_getOverrides3, 2),
    Track = _getOverrides4[0],
    trackProps = _getOverrides4[1];
  var _getOverrides5 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.InnerTrack, _styled_components__WEBPACK_IMPORTED_MODULE_5__.InnerTrack),
    _getOverrides6 = _slicedToArray(_getOverrides5, 2),
    InnerTrack = _getOverrides6[0],
    innerTrackProps = _getOverrides6[1];
  var _getOverrides7 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Thumb, _styled_components__WEBPACK_IMPORTED_MODULE_5__.Thumb),
    _getOverrides8 = _slicedToArray(_getOverrides7, 2),
    Thumb = _getOverrides8[0],
    thumbProps = _getOverrides8[1];
  var _getOverrides9 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.InnerThumb, _styled_components__WEBPACK_IMPORTED_MODULE_5__.InnerThumb),
    _getOverrides10 = _slicedToArray(_getOverrides9, 2),
    InnerThumb = _getOverrides10[0],
    innerThumbProps = _getOverrides10[1];
  var _getOverrides11 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.ThumbValue, _styled_components__WEBPACK_IMPORTED_MODULE_5__.ThumbValue),
    _getOverrides12 = _slicedToArray(_getOverrides11, 2),
    ThumbValue = _getOverrides12[0],
    thumbValueProps = _getOverrides12[1];
  var _getOverrides13 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Tick, _styled_components__WEBPACK_IMPORTED_MODULE_5__.Tick),
    _getOverrides14 = _slicedToArray(_getOverrides13, 2),
    Tick = _getOverrides14[0],
    tickProps = _getOverrides14[1];
  var _getOverrides15 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.TickBar, _styled_components__WEBPACK_IMPORTED_MODULE_5__.TickBar),
    _getOverrides16 = _slicedToArray(_getOverrides15, 2),
    TickBar = _getOverrides16[0],
    tickBarProps = _getOverrides16[1];
  var _getOverrides17 = (0,_helpers_overrides__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Mark, _styled_components__WEBPACK_IMPORTED_MODULE_5__.Mark),
    _getOverrides18 = _slicedToArray(_getOverrides17, 2),
    Mark = _getOverrides18[0],
    markProps = _getOverrides18[1];
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, _extends({
    "data-baseweb": "slider"
  }, sharedProps, rootProps, {
    onFocus: (0,_utils_focusVisible__WEBPACK_IMPORTED_MODULE_3__.forkFocus)(rootProps, handleFocus),
    onBlur: (0,_utils_focusVisible__WEBPACK_IMPORTED_MODULE_3__.forkBlur)(rootProps, handleBlur)
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_range__WEBPACK_IMPORTED_MODULE_1__.Range, _extends({
    step: step,
    min: min,
    max: max,
    values: value,
    disabled: disabled,
    onChange: function onChange(value) {
      return _onChange({
        value: value
      });
    },
    onFinalChange: function onFinalChange(value) {
      return _onFinalChange({
        value: value
      });
    },
    rtl: theme.direction === 'rtl',
    renderTrack: function renderTrack(_ref2) {
      var props = _ref2.props,
        children = _ref2.children,
        isDragged = _ref2.isDragged;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Track, _extends({
        onMouseDown: props.onMouseDown,
        onTouchStart: props.onTouchStart,
        $isDragged: isDragged
      }, sharedProps, trackProps), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerTrack, _extends({
        $isDragged: isDragged,
        ref: props.ref
      }, sharedProps, innerTrackProps), children));
    },
    renderThumb: function renderThumb(_ref3) {
      var props = _ref3.props,
        index = _ref3.index,
        isDragged = _ref3.isDragged;
      var displayLabel = persistentThumb ? persistentThumb : (!!index && isHovered1 || !index && isHovered0 || isDragged) && !disabled;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Thumb, _extends({}, props, {
        onMouseEnter: function onMouseEnter() {
          if (index === 0) {
            setIsHovered0(true);
          } else {
            setIsHovered1(true);
          }
        },
        onMouseLeave: function onMouseLeave() {
          if (index === 0) {
            setIsHovered0(false);
          } else {
            setIsHovered1(false);
          }
        },
        $thumbIndex: index,
        $isDragged: isDragged,
        style: _objectSpread({}, props.style)
      }, sharedProps, thumbProps, {
        $isFocusVisible: isFocusVisible && focusedThumbIndex === index
      }), displayLabel && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThumbValue, _extends({
        $thumbIndex: index,
        $isDragged: isDragged
      }, sharedProps, thumbValueProps), valueToLabel(value[index])), displayLabel && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerThumb, _extends({
        $thumbIndex: index,
        $isDragged: isDragged
      }, sharedProps, innerThumbProps)));
    }
  }, marks ? {
    // eslint-disable-next-line react/display-name
    renderMark: function renderMark(_ref4) {
      var props = _ref4.props,
        index = _ref4.index;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mark, _extends({
        $markIndex: index
      }, props, sharedProps, markProps));
    }
  } : {})), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(TickBar, _extends({}, sharedProps, tickBarProps), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tick, _extends({}, sharedProps, tickProps), valueToLabel(min)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tick, _extends({}, sharedProps, tickProps), valueToLabel(max))));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slider);

/***/ }),

/***/ "../../node_modules/baseui/esm/slider/styled-components.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/baseui/esm/slider/styled-components.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InnerThumb": () => (/* binding */ InnerThumb),
/* harmony export */   "InnerTrack": () => (/* binding */ InnerTrack),
/* harmony export */   "Mark": () => (/* binding */ Mark),
/* harmony export */   "Root": () => (/* binding */ Root),
/* harmony export */   "Thumb": () => (/* binding */ Thumb),
/* harmony export */   "ThumbValue": () => (/* binding */ ThumbValue),
/* harmony export */   "Tick": () => (/* binding */ Tick),
/* harmony export */   "TickBar": () => (/* binding */ TickBar),
/* harmony export */   "Track": () => (/* binding */ Track)
/* harmony export */ });
/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-range */ "../../node_modules/react-range/lib/index.js");
/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_range__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles */ "../../node_modules/baseui/esm/styles/styled.js");
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/


var Root = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', {
  position: 'relative',
  width: '100%'
});
Root.displayName = "Root";
Root.displayName = 'Root';
Root.displayName = 'StyledRoot';
var Track = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $theme = props.$theme,
    _props$$value = props.$value,
    $value = _props$$value === void 0 ? [] : _props$$value,
    $disabled = props.$disabled,
    $isDragged = props.$isDragged;
  var sizing = $theme.sizing;
  var cursor = 'inherit';
  if ($disabled) {
    cursor = 'not-allowed';
  } else if ($isDragged) {
    cursor = 'grabbing';
  } else if ($value.length === 1) {
    cursor = 'pointer';
  }
  return {
    paddingTop: sizing.scale600,
    paddingBottom: sizing.scale600,
    paddingRight: sizing.scale600,
    paddingLeft: sizing.scale600,
    display: 'flex',
    cursor: cursor,
    backgroundColor: $theme.colors.sliderTrackFill
  };
});
Track.displayName = "Track";
Track.displayName = 'Track';
Track.displayName = 'StyledTrack';
var InnerTrack = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $theme = props.$theme,
    _props$$value2 = props.$value,
    $value = _props$$value2 === void 0 ? [] : _props$$value2,
    $min = props.$min,
    $max = props.$max,
    $disabled = props.$disabled;
  var colors = $theme.colors,
    borders = $theme.borders,
    direction = $theme.direction;
  var borderRadius = $theme.borders.useRoundedCorners ? borders.radius100 : 0;
  return {
    borderTopLeftRadius: borderRadius,
    borderTopRightRadius: borderRadius,
    borderBottomRightRadius: borderRadius,
    borderBottomLeftRadius: borderRadius,
    background: (0,react_range__WEBPACK_IMPORTED_MODULE_0__.getTrackBackground)({
      values: $value,
      colors: $value.length === 1 ? [$disabled ? colors.borderOpaque : colors.primary, $disabled ? colors.backgroundSecondary : colors.borderOpaque] : [$disabled ? colors.backgroundSecondary : colors.borderOpaque, $disabled ? colors.borderOpaque : colors.primary, $disabled ? colors.backgroundSecondary : colors.borderOpaque],
      min: $min || 0,
      max: $max || 0,
      rtl: direction === 'rtl'
    }),
    height: '2px',
    width: '100%',
    alignSelf: 'center',
    cursor: $disabled ? 'not-allowed' : 'inherit'
  };
});
InnerTrack.displayName = "InnerTrack";
InnerTrack.displayName = 'InnerTrack';
InnerTrack.displayName = 'StyledInnerTrack';
var Mark = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  return {
    width: '4px',
    height: '2px',
    backgroundColor: props.$theme.colors.backgroundPrimary,
    marginLeft: '16px'
  };
});
Mark.displayName = "Mark";
Mark.displayName = 'Mark';
Mark.displayName = 'StyledMark';
var Tick = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  return _objectSpread(_objectSpread({}, props.$theme.typography.font200), {}, {
    color: props.$theme.colors.contentPrimary
  });
});
Tick.displayName = "Tick";
Tick.displayName = 'Tick';
Tick.displayName = 'StyledTick';
var TickBar = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $theme = props.$theme;
  var sizing = $theme.sizing;
  return {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: sizing.scale600,
    paddingLeft: sizing.scale600,
    paddingBottom: sizing.scale400
  };
});
TickBar.displayName = "TickBar";
TickBar.displayName = 'TickBar';
TickBar.displayName = 'StyledTickBar';
var Thumb = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $theme = props.$theme,
    _props$$value3 = props.$value,
    $value = _props$$value3 === void 0 ? [] : _props$$value3,
    $thumbIndex = props.$thumbIndex,
    $disabled = props.$disabled;
  var isLeft = $value.length === 2 && $thumbIndex === 0;
  var isRight = $value.length === 2 && $thumbIndex === 1;
  if ($theme.direction === 'rtl' && (isRight || isLeft)) {
    isLeft = !isLeft;
    isRight = !isRight;
  }
  return {
    height: '24px',
    width: '24px',
    borderTopLeftRadius: '24px',
    borderTopRightRadius: '24px',
    borderBottomLeftRadius: '24px',
    borderBottomRightRadius: '24px',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleFill,
    outline: 'none',
    boxShadow: props.$isFocusVisible ? "0 0 0 3px ".concat($theme.colors.accent) : '0 1px 4px rgba(0, 0, 0, 0.12)',
    cursor: $disabled ? 'not-allowed' : 'inherit'
  };
});
Thumb.displayName = "Thumb";
Thumb.displayName = 'Thumb';
Thumb.displayName = 'StyledThumb';
var InnerThumb = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $disabled = props.$disabled,
    $theme = props.$theme;
  return {
    position: 'absolute',
    top: '-16px',
    width: '4px',
    height: '20px',
    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleInnerFill
  };
});
InnerThumb.displayName = "InnerThumb";
InnerThumb.displayName = 'InnerThumb';
InnerThumb.displayName = 'StyledInnerThumb';
var ThumbValue = (0,_styles__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {
  var $disabled = props.$disabled,
    $theme = props.$theme;
  return _objectSpread(_objectSpread({
    position: 'absolute',
    top: "-".concat($theme.sizing.scale1400)
  }, $theme.typography.font200), {}, {
    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleInnerFill,
    color: $theme.colors.contentInversePrimary,
    paddingLeft: $theme.sizing.scale600,
    paddingRight: $theme.sizing.scale600,
    paddingTop: $theme.sizing.scale500,
    paddingBottom: $theme.sizing.scale500,
    borderBottomLeftRadius: '48px',
    borderBottomRightRadius: '48px',
    borderTopLeftRadius: '48px',
    borderTopRightRadius: '48px',
    whiteSpace: 'nowrap'
  });
});
ThumbValue.displayName = "ThumbValue";
ThumbValue.displayName = 'ThumbValue';
ThumbValue.displayName = 'StyledThumbValue';

/***/ }),

/***/ "../../node_modules/react-range/lib/Range.js":
/*!***************************************************!*\
  !*** ../../node_modules/react-range/lib/Range.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
  };
  return function (d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var React = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/react-range/lib/utils.js");
var types_1 = __webpack_require__(/*! ./types */ "../../node_modules/react-range/lib/types.js");
var INCREASE_KEYS = ['ArrowRight', 'ArrowUp', 'k', 'PageUp'];
var DECREASE_KEYS = ['ArrowLeft', 'ArrowDown', 'j', 'PageDown'];
var Range = /** @class */function (_super) {
  __extends(Range, _super);
  function Range(props) {
    var _this = _super.call(this, props) || this;
    _this.trackRef = React.createRef();
    _this.thumbRefs = [];
    _this.markRefs = [];
    _this.state = {
      draggedTrackPos: [-1, -1],
      draggedThumbIndex: -1,
      thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) {
        return i;
      }),
      isChanged: false,
      markOffsets: []
    };
    _this.getOffsets = function () {
      var _a = _this.props,
        direction = _a.direction,
        values = _a.values,
        min = _a.min,
        max = _a.max;
      var trackElement = _this.trackRef.current;
      var trackRect = trackElement.getBoundingClientRect();
      var trackPadding = utils_1.getPaddingAndBorder(trackElement);
      return _this.getThumbs().map(function (thumb, index) {
        var thumbOffsets = {
          x: 0,
          y: 0
        };
        var thumbRect = thumb.getBoundingClientRect();
        var thumbMargins = utils_1.getMargin(thumb);
        switch (direction) {
          case types_1.Direction.Right:
            thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;
            thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;
            thumbOffsets.x += trackRect.width * utils_1.relativeValue(values[index], min, max) - thumbRect.width / 2;
            return thumbOffsets;
          case types_1.Direction.Left:
            thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;
            thumbOffsets.y = ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;
            thumbOffsets.x += trackRect.width - trackRect.width * utils_1.relativeValue(values[index], min, max) - thumbRect.width / 2;
            return thumbOffsets;
          case types_1.Direction.Up:
            thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;
            thumbOffsets.y = -trackPadding.left;
            thumbOffsets.y += trackRect.height - trackRect.height * utils_1.relativeValue(values[index], min, max) - thumbRect.height / 2;
            return thumbOffsets;
          case types_1.Direction.Down:
            thumbOffsets.x = ((thumbRect.width - trackRect.width) / 2 + thumbMargins.left + trackPadding.left) * -1;
            thumbOffsets.y = -trackPadding.left;
            thumbOffsets.y += trackRect.height * utils_1.relativeValue(values[index], min, max) - thumbRect.height / 2;
            return thumbOffsets;
          default:
            return utils_1.assertUnreachable(direction);
        }
      });
    };
    _this.getThumbs = function () {
      if (_this.trackRef && _this.trackRef.current) {
        return Array.from(_this.trackRef.current.children).filter(function (el) {
          return el.hasAttribute('aria-valuenow');
        });
      }
      console.warn('No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?');
      return [];
    };
    _this.getTargetIndex = function (e) {
      return _this.getThumbs().findIndex(function (child) {
        return child === e.target || child.contains(e.target);
      });
    };
    _this.addTouchEvents = function (e) {
      document.addEventListener('touchmove', _this.schdOnTouchMove, {
        passive: false
      });
      document.addEventListener('touchend', _this.schdOnEnd, {
        passive: false
      });
      document.addEventListener('touchcancel', _this.schdOnEnd, {
        passive: false
      });
    };
    _this.addMouseEvents = function (e) {
      document.addEventListener('mousemove', _this.schdOnMouseMove);
      document.addEventListener('mouseup', _this.schdOnEnd);
    };
    _this.onMouseDownTrack = function (e) {
      var _a;
      if (e.button !== 0) return;
      e.persist();
      e.preventDefault();
      _this.addMouseEvents(e.nativeEvent);
      if (_this.props.values.length > 1 && _this.props.draggableTrack) {
        if (_this.thumbRefs.some(function (thumbRef) {
          var _a;
          return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);
        })) return;
        // handle dragging the whole track
        _this.setState({
          draggedTrackPos: [e.clientX, e.clientY]
        }, function () {
          return _this.onMove(e.clientX, e.clientY);
        });
      } else {
        // get the index of the thumb that is closest to the place where the track is clicked
        var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) {
          return t.current;
        }), e.clientX, e.clientY, _this.props.direction);
        // move the thumb which is closest to the place where the track is clicked
        (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();
        _this.setState({
          draggedThumbIndex: draggedThumbIndex
        }, function () {
          return _this.onMove(e.clientX, e.clientY);
        });
      }
    };
    _this.onResize = function () {
      utils_1.translateThumbs(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);
      _this.calculateMarkOffsets();
    };
    _this.onTouchStartTrack = function (e) {
      var _a;
      e.persist();
      _this.addTouchEvents(e.nativeEvent);
      if (_this.props.values.length > 1 && _this.props.draggableTrack) {
        if (_this.thumbRefs.some(function (thumbRef) {
          var _a;
          return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target);
        })) return;
        // handle dragging the whole track
        _this.setState({
          draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY]
        }, function () {
          return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);
        });
      } else {
        // get the index of the thumb that is closest to the place where the track is clicked
        var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) {
          return t.current;
        }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);
        // move the thumb which is closest to the place where the track is clicked
        (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();
        _this.setState({
          draggedThumbIndex: draggedThumbIndex
        }, function () {
          return _this.onMove(e.touches[0].clientX, e.touches[0].clientY);
        });
      }
    };
    _this.onMouseOrTouchStart = function (e) {
      if (_this.props.disabled) return;
      var isTouch = utils_1.isTouchEvent(e);
      if (!isTouch && e.button !== 0) return;
      var index = _this.getTargetIndex(e);
      if (index === -1) return;
      if (isTouch) {
        _this.addTouchEvents(e);
      } else {
        _this.addMouseEvents(e);
      }
      _this.setState({
        draggedThumbIndex: index,
        thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {
          if (i === index) {
            return Math.max.apply(Math, _this.state.thumbZIndexes);
          }
          return t <= _this.state.thumbZIndexes[index] ? t : t - 1;
        })
      });
    };
    _this.onMouseMove = function (e) {
      e.preventDefault();
      _this.onMove(e.clientX, e.clientY);
    };
    _this.onTouchMove = function (e) {
      e.preventDefault();
      _this.onMove(e.touches[0].clientX, e.touches[0].clientY);
    };
    _this.onKeyDown = function (e) {
      var _a = _this.props,
        values = _a.values,
        onChange = _a.onChange,
        step = _a.step,
        rtl = _a.rtl;
      var isChanged = _this.state.isChanged;
      var index = _this.getTargetIndex(e.nativeEvent);
      var inverter = rtl ? -1 : 1;
      if (index === -1) return;
      if (INCREASE_KEYS.includes(e.key)) {
        e.preventDefault();
        _this.setState({
          draggedThumbIndex: index,
          isChanged: true
        });
        onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] + inverter * (e.key === 'PageUp' ? step * 10 : step), index)));
      } else if (DECREASE_KEYS.includes(e.key)) {
        e.preventDefault();
        _this.setState({
          draggedThumbIndex: index,
          isChanged: true
        });
        onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] - inverter * (e.key === 'PageDown' ? step * 10 : step), index)));
      } else if (e.key === 'Tab') {
        _this.setState({
          draggedThumbIndex: -1
        }, function () {
          // If key pressed when thumb was moving, fire onFinalChange
          if (isChanged) {
            _this.fireOnFinalChange();
          }
        });
      } else {
        if (isChanged) {
          _this.fireOnFinalChange();
        }
      }
    };
    _this.onKeyUp = function (e) {
      var isChanged = _this.state.isChanged;
      _this.setState({
        draggedThumbIndex: -1
      }, function () {
        if (isChanged) {
          _this.fireOnFinalChange();
        }
      });
    };
    _this.onMove = function (clientX, clientY) {
      var _a = _this.state,
        draggedThumbIndex = _a.draggedThumbIndex,
        draggedTrackPos = _a.draggedTrackPos;
      var _b = _this.props,
        direction = _b.direction,
        min = _b.min,
        max = _b.max,
        onChange = _b.onChange,
        values = _b.values,
        step = _b.step,
        rtl = _b.rtl;
      if (draggedThumbIndex === -1 && draggedTrackPos[0] === -1 && draggedTrackPos[1] === -1) return null;
      var trackElement = _this.trackRef.current;
      // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()
      if (!trackElement) return null;
      var trackRect = trackElement.getBoundingClientRect();
      var trackLength = utils_1.isVertical(direction) ? trackRect.height : trackRect.width;
      if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {
        // calculate how much it moved since the last update
        var dX = clientX - draggedTrackPos[0];
        var dY = clientY - draggedTrackPos[1];
        // calculate the delta of the value
        var deltaValue = 0;
        switch (direction) {
          case types_1.Direction.Right:
          case types_1.Direction.Left:
            deltaValue = dX / trackLength * (max - min) + min;
            break;
          case types_1.Direction.Down:
          case types_1.Direction.Up:
            deltaValue = dY / trackLength * (max - min) + min;
            break;
          default:
            utils_1.assertUnreachable(direction);
        }
        // invert for RTL
        if (rtl) {
          deltaValue *= -1;
        }
        if (Math.abs(deltaValue) >= step / 2) {
          // adjust delta so it fits into the range
          for (var i = 0; i < _this.thumbRefs.length; i++) {
            if (values[i] === max && Math.sign(deltaValue) === 1 || values[i] === min && Math.sign(deltaValue) === -1) return;
            var thumbValue = values[i] + deltaValue;
            if (thumbValue > max) deltaValue = max - values[i];else if (thumbValue < min) deltaValue = min - values[i];
          }
          // add the delta to each thumb
          var newValues = values.slice(0);
          for (var i = 0; i < _this.thumbRefs.length; i++) {
            newValues = utils_1.replaceAt(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));
          }
          _this.setState({
            draggedTrackPos: [clientX, clientY]
          });
          onChange(newValues);
        }
      } else {
        var newValue = 0;
        switch (direction) {
          case types_1.Direction.Right:
            newValue = (clientX - trackRect.left) / trackLength * (max - min) + min;
            break;
          case types_1.Direction.Left:
            newValue = (trackLength - (clientX - trackRect.left)) / trackLength * (max - min) + min;
            break;
          case types_1.Direction.Down:
            newValue = (clientY - trackRect.top) / trackLength * (max - min) + min;
            break;
          case types_1.Direction.Up:
            newValue = (trackLength - (clientY - trackRect.top)) / trackLength * (max - min) + min;
            break;
          default:
            utils_1.assertUnreachable(direction);
        }
        // invert for RTL
        if (rtl) {
          newValue = max + min - newValue;
        }
        if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {
          onChange(utils_1.replaceAt(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));
        }
      }
    };
    _this.normalizeValue = function (value, index) {
      var _a = _this.props,
        min = _a.min,
        max = _a.max,
        step = _a.step,
        allowOverlap = _a.allowOverlap,
        values = _a.values;
      return utils_1.normalizeValue(value, index, min, max, step, allowOverlap, values);
    };
    _this.onEnd = function (e) {
      e.preventDefault();
      document.removeEventListener('mousemove', _this.schdOnMouseMove);
      document.removeEventListener('touchmove', _this.schdOnTouchMove);
      document.removeEventListener('mouseup', _this.schdOnEnd);
      document.removeEventListener('touchend', _this.schdOnEnd);
      document.removeEventListener('touchcancel', _this.schdOnEnd);
      if (_this.state.draggedThumbIndex === -1 && _this.state.draggedTrackPos[0] === -1 && _this.state.draggedTrackPos[1] === -1) return null;
      _this.setState({
        draggedThumbIndex: -1,
        draggedTrackPos: [-1, -1]
      }, function () {
        _this.fireOnFinalChange();
      });
    };
    _this.fireOnFinalChange = function () {
      _this.setState({
        isChanged: false
      });
      var _a = _this.props,
        onFinalChange = _a.onFinalChange,
        values = _a.values;
      if (onFinalChange) {
        onFinalChange(values);
      }
    };
    _this.calculateMarkOffsets = function () {
      if (!_this.props.renderMark || !_this.trackRef || _this.trackRef.current === null) return;
      var elStyles = window.getComputedStyle(_this.trackRef.current);
      var trackWidth = parseInt(elStyles.width, 10);
      var trackHeight = parseInt(elStyles.height, 10);
      var paddingLeft = parseInt(elStyles.paddingLeft, 10);
      var paddingTop = parseInt(elStyles.paddingTop, 10);
      var res = [];
      for (var i = 0; i < _this.numOfMarks + 1; i++) {
        var markHeight = 9999;
        var markWidth = 9999;
        if (_this.markRefs[i].current) {
          var markRect = _this.markRefs[i].current.getBoundingClientRect();
          markHeight = markRect.height;
          markWidth = markRect.width;
        }
        if (_this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right) {
          res.push([Math.round(trackWidth / _this.numOfMarks * i + paddingLeft - markWidth / 2), -Math.round((markHeight - trackHeight) / 2)]);
        } else {
          res.push([Math.round(trackHeight / _this.numOfMarks * i + paddingTop - markHeight / 2), -Math.round((markWidth - trackWidth) / 2)]);
        }
      }
      _this.setState({
        markOffsets: res
      });
    };
    _this.numOfMarks = (props.max - props.min) / _this.props.step;
    _this.schdOnMouseMove = utils_1.schd(_this.onMouseMove);
    _this.schdOnTouchMove = utils_1.schd(_this.onTouchMove);
    _this.schdOnEnd = utils_1.schd(_this.onEnd);
    _this.thumbRefs = props.values.map(function () {
      return React.createRef();
    });
    for (var i = 0; i < _this.numOfMarks + 1; i++) {
      _this.markRefs[i] = React.createRef();
    }
    if (!utils_1.isStepDivisible(props.min, props.max, props.step)) {
      console.warn('The difference of `max` and `min` must be divisible by `step`');
    }
    if (props.step === 0) {
      throw new Error('"step" property should be a positive number');
    }
    return _this;
  }
  Range.prototype.componentDidMount = function () {
    var _this = this;
    var _a = this.props,
      values = _a.values,
      min = _a.min,
      step = _a.step;
    this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(this.onResize) : {
      observe: function () {
        return window.addEventListener('resize', _this.onResize);
      },
      unobserve: function () {
        return window.removeEventListener('resize', _this.onResize);
      }
    };
    document.addEventListener('touchstart', this.onMouseOrTouchStart, {
      passive: false
    });
    document.addEventListener('mousedown', this.onMouseOrTouchStart, {
      passive: false
    });
    !this.props.allowOverlap && utils_1.checkInitialOverlap(this.props.values);
    this.props.values.forEach(function (value) {
      return utils_1.checkBoundaries(value, _this.props.min, _this.props.max);
    });
    this.resizeObserver.observe(this.trackRef.current);
    utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), this.props.rtl);
    this.calculateMarkOffsets();
    values.forEach(function (value) {
      if (!utils_1.isStepDivisible(min, value, step)) {
        console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');
      }
    });
  };
  Range.prototype.componentDidUpdate = function (prevProps) {
    utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), this.props.rtl);
  };
  Range.prototype.componentWillUnmount = function () {
    var options = {
      passive: false
    };
    document.removeEventListener('mousedown', this.onMouseOrTouchStart, options);
    // These need to be removed!!
    document.removeEventListener('mousemove', this.schdOnMouseMove);
    document.removeEventListener('touchmove', this.schdOnTouchMove);
    document.removeEventListener('touchstart', this.onMouseOrTouchStart);
    document.removeEventListener('mouseup', this.schdOnEnd);
    document.removeEventListener('touchend', this.schdOnEnd);
    this.resizeObserver.unobserve(this.trackRef.current);
  };
  Range.prototype.render = function () {
    var _this = this;
    var _a = this.props,
      renderTrack = _a.renderTrack,
      renderThumb = _a.renderThumb,
      _b = _a.renderMark,
      renderMark = _b === void 0 ? function () {
        return null;
      } : _b,
      values = _a.values,
      min = _a.min,
      max = _a.max,
      allowOverlap = _a.allowOverlap,
      disabled = _a.disabled;
    var _c = this.state,
      draggedThumbIndex = _c.draggedThumbIndex,
      thumbZIndexes = _c.thumbZIndexes,
      markOffsets = _c.markOffsets;
    return renderTrack({
      props: {
        style: {
          // creates stacking context that prevents z-index applied to thumbs
          // interfere with other elements
          transform: 'scale(1)',
          cursor: draggedThumbIndex > -1 ? 'grabbing' : this.props.draggableTrack ? utils_1.isVertical(this.props.direction) ? 'ns-resize' : 'ew-resize' : values.length === 1 && !disabled ? 'pointer' : 'inherit'
        },
        onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,
        onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,
        ref: this.trackRef
      },
      isDragged: this.state.draggedThumbIndex > -1,
      disabled: disabled,
      children: __spreadArrays(markOffsets.map(function (offset, index) {
        return renderMark({
          props: {
            style: _this.props.direction === types_1.Direction.Left || _this.props.direction === types_1.Direction.Right ? {
              position: 'absolute',
              left: offset[0] + "px",
              marginTop: offset[1] + "px"
            } : {
              position: 'absolute',
              top: offset[0] + "px",
              marginLeft: offset[1] + "px"
            },
            key: "mark" + index,
            ref: _this.markRefs[index]
          },
          index: index
        });
      }), values.map(function (value, index) {
        var isDragged = _this.state.draggedThumbIndex === index;
        return renderThumb({
          index: index,
          value: value,
          isDragged: isDragged,
          props: {
            style: {
              position: 'absolute',
              zIndex: thumbZIndexes[index],
              cursor: disabled ? 'inherit' : isDragged ? 'grabbing' : 'grab',
              userSelect: 'none',
              touchAction: 'none',
              WebkitUserSelect: 'none',
              MozUserSelect: 'none',
              msUserSelect: 'none'
            },
            key: index,
            tabIndex: disabled ? undefined : 0,
            'aria-valuemax': allowOverlap ? max : values[index + 1] || max,
            'aria-valuemin': allowOverlap ? min : values[index - 1] || min,
            'aria-valuenow': value,
            draggable: false,
            ref: _this.thumbRefs[index],
            role: 'slider',
            onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,
            onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp
          }
        });
      }))
    });
  };
  Range.defaultProps = {
    step: 1,
    direction: types_1.Direction.Right,
    rtl: false,
    disabled: false,
    allowOverlap: false,
    draggableTrack: false,
    min: 0,
    max: 100
  };
  return Range;
}(React.Component);
exports["default"] = Range;

/***/ }),

/***/ "../../node_modules/react-range/lib/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/react-range/lib/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var Range_1 = __importDefault(__webpack_require__(/*! ./Range */ "../../node_modules/react-range/lib/Range.js"));
exports.Range = Range_1.default;
var utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/react-range/lib/utils.js");
exports.getTrackBackground = utils_1.getTrackBackground;
exports.useThumbOverlap = utils_1.useThumbOverlap;
exports.relativeValue = utils_1.relativeValue;
var types_1 = __webpack_require__(/*! ./types */ "../../node_modules/react-range/lib/types.js");
exports.Direction = types_1.Direction;

/***/ }),

/***/ "../../node_modules/react-range/lib/types.js":
/*!***************************************************!*\
  !*** ../../node_modules/react-range/lib/types.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var Direction;
(function (Direction) {
  Direction["Right"] = "to right";
  Direction["Left"] = "to left";
  Direction["Down"] = "to bottom";
  Direction["Up"] = "to top";
})(Direction = exports.Direction || (exports.Direction = {}));

/***/ }),

/***/ "../../node_modules/react-range/lib/utils.js":
/*!***************************************************!*\
  !*** ../../node_modules/react-range/lib/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var react_1 = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
var types_1 = __webpack_require__(/*! ./types */ "../../node_modules/react-range/lib/types.js");
exports.getStepDecimals = function (step) {
  var decimals = step.toString().split('.')[1];
  return decimals ? decimals.length : 0;
};
function isTouchEvent(event) {
  return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;
}
exports.isTouchEvent = isTouchEvent;
function isStepDivisible(min, max, step) {
  var res = (max - min) / step;
  return parseInt(res.toString(), 10) === res;
}
exports.isStepDivisible = isStepDivisible;
function normalizeValue(value, index, min, max, step, allowOverlap, values) {
  var BIG_NUM = 10e10;
  value = Math.round(value * BIG_NUM) / BIG_NUM;
  if (!allowOverlap) {
    var prev = values[index - 1];
    var next = values[index + 1];
    if (prev && prev > value) return prev;
    if (next && next < value) return next;
  }
  if (value > max) return max;
  if (value < min) return min;
  // `remainder` is a difference between the given value and a full step value
  // that is closest lower to the given value and is in the range between the min value
  // and the given value
  var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);
  var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));
  var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;
  // Values with a remainder `< step/2` are rounded to the closest lower value
  // while values with a remainder `= > step/2` are rounded to the closest bigger value
  var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;
  var decimalPlaces = exports.getStepDecimals(step);
  return parseFloat(res.toFixed(decimalPlaces));
}
exports.normalizeValue = normalizeValue;
function relativeValue(value, min, max) {
  return (value - min) / (max - min);
}
exports.relativeValue = relativeValue;
function isVertical(direction) {
  return direction === types_1.Direction.Up || direction === types_1.Direction.Down;
}
exports.isVertical = isVertical;
function checkBoundaries(value, min, max) {
  if (min >= max) {
    throw new RangeError("min (" + min + ") is equal/bigger than max (" + max + ")");
  }
  if (value < min) {
    throw new RangeError("value (" + value + ") is smaller than min (" + min + ")");
  }
  if (value > max) {
    throw new RangeError("value (" + value + ") is bigger than max (" + max + ")");
  }
}
exports.checkBoundaries = checkBoundaries;
function checkInitialOverlap(values) {
  if (values.length < 2) return;
  if (!values.slice(1).every(function (item, i) {
    return values[i] <= item;
  })) {
    throw new RangeError("values={[" + values + "]} needs to be sorted when allowOverlap={false}");
  }
}
exports.checkInitialOverlap = checkInitialOverlap;
function getMargin(element) {
  var style = window.getComputedStyle(element);
  return {
    top: parseInt(style['margin-top'], 10),
    bottom: parseInt(style['margin-bottom'], 10),
    left: parseInt(style['margin-left'], 10),
    right: parseInt(style['margin-right'], 10)
  };
}
exports.getMargin = getMargin;
function getPaddingAndBorder(element) {
  var style = window.getComputedStyle(element);
  return {
    top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),
    bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),
    left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),
    right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10)
  };
}
exports.getPaddingAndBorder = getPaddingAndBorder;
function translateThumbs(elements, offsets, rtl) {
  var inverter = rtl ? -1 : 1;
  elements.forEach(function (element, index) {
    return translate(element, inverter * offsets[index].x, offsets[index].y);
  });
}
exports.translateThumbs = translateThumbs;
/**
 * Util function for calculating the index of the thumb that is closes to a given position
 * @param thumbs - array of Thumb element to calculate the distance from
 * @param clientX - target x position (mouse/touch)
 * @param clientY - target y position (mouse/touch)
 * @param direction - the direction of the track
 */
function getClosestThumbIndex(thumbs, clientX, clientY, direction) {
  var thumbIndex = 0;
  var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);
  for (var i = 1; i < thumbs.length; i++) {
    var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);
    if (thumbDistance < minThumbDistance) {
      minThumbDistance = thumbDistance;
      thumbIndex = i;
    }
  }
  return thumbIndex;
}
exports.getClosestThumbIndex = getClosestThumbIndex;
function translate(element, x, y) {
  element.style.transform = "translate(" + x + "px, " + y + "px)";
}
exports.translate = translate;
// adapted from https://github.com/alexreardon/raf-schd
exports.schd = function (fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function () {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  return wrapperFn;
};
function replaceAt(values, index, value) {
  var ret = values.slice(0);
  ret[index] = value;
  return ret;
}
exports.replaceAt = replaceAt;
function getTrackBackground(_a) {
  var values = _a.values,
    colors = _a.colors,
    min = _a.min,
    max = _a.max,
    _b = _a.direction,
    direction = _b === void 0 ? types_1.Direction.Right : _b,
    _c = _a.rtl,
    rtl = _c === void 0 ? false : _c;
  if (rtl && direction === types_1.Direction.Right) {
    direction = types_1.Direction.Left;
  } else if (rtl && types_1.Direction.Left) {
    direction = types_1.Direction.Right;
  }
  // sort values ascending
  var progress = values.slice(0).sort(function (a, b) {
    return a - b;
  }).map(function (value) {
    return (value - min) / (max - min) * 100;
  });
  var middle = progress.reduce(function (acc, point, index) {
    return acc + ", " + colors[index] + " " + point + "%, " + colors[index + 1] + " " + point + "%";
  }, '');
  return "linear-gradient(" + direction + ", " + colors[0] + " 0%" + middle + ", " + colors[colors.length - 1] + " 100%)";
}
exports.getTrackBackground = getTrackBackground;
function voidFn() {}
exports.voidFn = voidFn;
function assertUnreachable(x) {
  throw new Error("Didn't expect to get here");
}
exports.assertUnreachable = assertUnreachable;
/**
 * Util function for grabbing the true largest width of a thumb
 * including the label
 * @param thumbEl - Thumb element to grab the largest width from
 * @param value - Thumb value, not label value
 * @param separator - Label separator value
 */
var getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {
  if (valueToLabel === void 0) {
    valueToLabel = function (value) {
      return value;
    };
  }
  var width = Math.ceil(__spreadArrays([thumbEl], Array.from(thumbEl.children)).reduce(function (width, el) {
    var elWidth = Math.ceil(el.getBoundingClientRect().width);
    /**
     * If a label contains a merged label value, it won't return the true
     * label width for that Thumb. Clone the label and change the value
     * to that individual Thumb value in order to grab the true width.
     */
    if (el.innerText && el.innerText.includes(separator) && el.childElementCount === 0) {
      var elClone = el.cloneNode(true);
      elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));
      elClone.style.visibility = 'hidden';
      document.body.appendChild(elClone);
      elWidth = Math.ceil(elClone.getBoundingClientRect().width);
      document.body.removeChild(elClone);
    }
    return elWidth > width ? elWidth : width;
  }, thumbEl.getBoundingClientRect().width));
  return width;
};
/**
 * Bulk of logic for thumb overlaps
 * Consider a scenario with 5 thumbs;
 * Thumb 1 overlaps with thumb 0 and thumb 2
 * Thumb 2 overlaps with thumb 3
 * We need an array that contains [0, 1, 2, 3]
 * The function needs to return the directly overlapping thumbs
 * and all thumbs overlapping linked to those and so on
 * @param index - Thumb index calculating overlaps for
 * @param offsets - Current Array of Thumb offsets for Range
 * @param thumbs - Array of Thumb elements
 * @param values - Array of Thumb values
 * @param separator - String separator for merged label values
 * @returns overlaps - Array of all overlapping thumbs from the index
 */
var getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {
  if (valueToLabel === void 0) {
    valueToLabel = function (value) {
      return value;
    };
  }
  var overlaps = [];
  /**
   * Recursive function for building the overlaps Array
   * If an overlap is found, find the overlaps for that overlap
   * @param thumbIndex current Thumb index to find overlaps from
   */
  var buildOverlaps = function (thumbIndex) {
    var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);
    var thumbX = offsets[thumbIndex].x;
    /**
     * Iterate through the Thumb offsets, if there is a match
     * add the thumbIndex and siblingIndex to the overlaps Array
     *
     * Then build overlaps from the overlapping siblingIndex
     */
    offsets.forEach(function (_a, siblingIndex) {
      var siblingX = _a.x;
      var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);
      if (thumbIndex !== siblingIndex && (thumbX >= siblingX && thumbX <= siblingX + siblingWidth || thumbX + thumbXWidth >= siblingX && thumbX + thumbXWidth <= siblingX + siblingWidth)) {
        if (!overlaps.includes(siblingIndex)) {
          overlaps.push(thumbIndex);
          overlaps.push(siblingIndex);
          overlaps = __spreadArrays(overlaps, [thumbIndex, siblingIndex]);
          buildOverlaps(siblingIndex);
        }
      }
    });
  };
  buildOverlaps(index);
  // Sort and remove duplicates from the built overlaps
  return Array.from(new Set(overlaps.sort()));
};
/**
 * A custom React Hook for calculating whether a thumb overlaps
 * another and whether labels could/should merge.
 * @param rangeRef - React ref value of Range component
 * @param values - current Range values Array
 * @param index - thumb index
 * @param step - step value, used to calculate the number of decimal places
 * @param separator - string to separate thumb values
 * @returns label value + styling for thumb label
 */
exports.useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {
  if (step === void 0) {
    step = 0.1;
  }
  if (separator === void 0) {
    separator = ' - ';
  }
  if (valueToLabel === void 0) {
    valueToLabel = function (value) {
      return value;
    };
  }
  var decimalPlaces = exports.getStepDecimals(step);
  // Create initial label style and value. Label value defaults to thumb value
  var _a = react_1.useState({}),
    labelStyle = _a[0],
    setLabelStyle = _a[1];
  var _b = react_1.useState(valueToLabel(values[index].toFixed(decimalPlaces))),
    labelValue = _b[0],
    setLabelValue = _b[1];
  // When the rangeRef or values change, update the Thumb label values and styling
  react_1.useEffect(function () {
    if (rangeRef) {
      var thumbs = rangeRef.getThumbs();
      if (thumbs.length < 1) return;
      var newStyle = {};
      var offsets_1 = rangeRef.getOffsets();
      /**
       * Get any overlaps for the given Thumb index. This must return all linked
       * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are
       * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get
       * 2, 3 and 4 also.
       */
      var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);
      // Set a default label value of the Thumb value
      var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));
      /**
       * If there are overlaps for the Thumb, we need to calculate the correct
       * Label value along with the relevant styling. We only want to show a Label
       * for the left most Thumb in an overlapping set.
       * All other Thumbs will be set to display: none.
       */
      if (overlaps.length) {
        /**
         * Get an Array of the offsets for the overlapping Thumbs
         * This is so we can determine if the Thumb we are looking at
         * is the left most thumb in an overlapping set
         */
        var offsetsX = overlaps.reduce(function (a, c, i, s) {
          return a.length ? __spreadArrays(a, [offsets_1[s[i]].x]) : [offsets_1[s[i]].x];
        }, []);
        /**
         * If our Thumb is the left most Thumb, we can build a Label value
         * and set the style for that Label
         */
        if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {
          /**
           * First calculate the Label value. To do this,
           * grab all the values for the Thumbs in our overlaps.
           * Then convert that to a Set and sort it whilst removing duplicates.
           */
          var labelValues_1 = [];
          overlaps.forEach(function (thumb) {
            labelValues_1.push(values[thumb].toFixed(decimalPlaces));
          });
          /**
           *  Update the labelValue with the resulting Array
           *  joined by our defined separator
           */
          labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) {
            return parseFloat(a) - parseFloat(b);
          }))).map(valueToLabel).join(separator);
          /**
           * Lastly, build the label styling. The label styling will
           * position the label and apply a transform so that it's centered.
           * We want the center point between the left edge of the left most Thumb
           * and the right edge of the right most Thumb.
           */
          var first = Math.min.apply(Math, offsetsX);
          var last = Math.max.apply(Math, offsetsX);
          var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;
          newStyle.left = Math.abs(first - (last + lastWidth)) / 2 + "px";
          newStyle.transform = 'translate(-50%, 0)';
        } else {
          // If the Thumb isn't the left most Thumb, hide the Label!
          newStyle.visibility = 'hidden';
        }
      }
      // Update the label value and style
      setLabelValue(labelValue_1);
      setLabelStyle(newStyle);
    }
  }, [rangeRef, values]);
  return [labelValue, labelStyle];
};
/**
 * Util function for calculating the distance of the center of a thumb
 * form a given mouse/touch target's position
 * @param thumbEl - Thumb element to calculate the distance from
 * @param clientX - target x position (mouse/touch)
 * @param clientY - target y position (mouse/touch)
 * @param direction - the direction of the track
 */
function getThumbDistance(thumbEl, clientX, clientY, direction) {
  var _a = thumbEl.getBoundingClientRect(),
    x = _a.x,
    y = _a.y,
    width = _a.width,
    height = _a.height;
  return isVertical(direction) ? Math.abs(clientY - (y + height / 2)) : Math.abs(clientX - (x + width / 2));
}

/***/ }),

/***/ "../../node_modules/sprintf-js/src/sprintf.js":
/*!****************************************************!*\
  !*** ../../node_modules/sprintf-js/src/sprintf.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */

!function () {
  'use strict';

  var re = {
    not_string: /[^s]/,
    not_bool: /[^t]/,
    not_type: /[^T]/,
    not_primitive: /[^v]/,
    number: /[diefg]/,
    numeric_arg: /[bcdiefguxX]/,
    json: /[j]/,
    not_json: /[^j]/,
    text: /^[^\x25]+/,
    modulo: /^\x25{2}/,
    placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
    key: /^([a-z_][a-z_\d]*)/i,
    key_access: /^\.([a-z_][a-z_\d]*)/i,
    index_access: /^\[(\d+)\]/,
    sign: /^[+-]/
  };
  function sprintf(key) {
    // `arguments` is not an array, but should be fine for this call
    return sprintf_format(sprintf_parse(key), arguments);
  }
  function vsprintf(fmt, argv) {
    return sprintf.apply(null, [fmt].concat(argv || []));
  }
  function sprintf_format(parse_tree, argv) {
    var cursor = 1,
      tree_length = parse_tree.length,
      arg,
      output = '',
      i,
      k,
      ph,
      pad,
      pad_character,
      pad_length,
      is_positive,
      sign;
    for (i = 0; i < tree_length; i++) {
      if (typeof parse_tree[i] === 'string') {
        output += parse_tree[i];
      } else if (typeof parse_tree[i] === 'object') {
        ph = parse_tree[i]; // convenience purposes only
        if (ph.keys) {
          // keyword argument
          arg = argv[cursor];
          for (k = 0; k < ph.keys.length; k++) {
            if (arg == undefined) {
              throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
            }
            arg = arg[ph.keys[k]];
          }
        } else if (ph.param_no) {
          // positional argument (explicit)
          arg = argv[ph.param_no];
        } else {
          // positional argument (implicit)
          arg = argv[cursor++];
        }
        if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
          arg = arg();
        }
        if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
          throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
        }
        if (re.number.test(ph.type)) {
          is_positive = arg >= 0;
        }
        switch (ph.type) {
          case 'b':
            arg = parseInt(arg, 10).toString(2);
            break;
          case 'c':
            arg = String.fromCharCode(parseInt(arg, 10));
            break;
          case 'd':
          case 'i':
            arg = parseInt(arg, 10);
            break;
          case 'j':
            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
            break;
          case 'e':
            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
            break;
          case 'f':
            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
            break;
          case 'g':
            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
            break;
          case 'o':
            arg = (parseInt(arg, 10) >>> 0).toString(8);
            break;
          case 's':
            arg = String(arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 't':
            arg = String(!!arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'T':
            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'u':
            arg = parseInt(arg, 10) >>> 0;
            break;
          case 'v':
            arg = arg.valueOf();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'x':
            arg = (parseInt(arg, 10) >>> 0).toString(16);
            break;
          case 'X':
            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
            break;
        }
        if (re.json.test(ph.type)) {
          output += arg;
        } else {
          if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
            sign = is_positive ? '+' : '-';
            arg = arg.toString().replace(re.sign, '');
          } else {
            sign = '';
          }
          pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
          pad_length = ph.width - (sign + arg).length;
          pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
          output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
        }
      }
    }
    return output;
  }
  var sprintf_cache = Object.create(null);
  function sprintf_parse(fmt) {
    if (sprintf_cache[fmt]) {
      return sprintf_cache[fmt];
    }
    var _fmt = fmt,
      match,
      parse_tree = [],
      arg_names = 0;
    while (_fmt) {
      if ((match = re.text.exec(_fmt)) !== null) {
        parse_tree.push(match[0]);
      } else if ((match = re.modulo.exec(_fmt)) !== null) {
        parse_tree.push('%');
      } else if ((match = re.placeholder.exec(_fmt)) !== null) {
        if (match[2]) {
          arg_names |= 1;
          var field_list = [],
            replacement_field = match[2],
            field_match = [];
          if ((field_match = re.key.exec(replacement_field)) !== null) {
            field_list.push(field_match[1]);
            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else {
                throw new SyntaxError('[sprintf] failed to parse named argument key');
              }
            }
          } else {
            throw new SyntaxError('[sprintf] failed to parse named argument key');
          }
          match[2] = field_list;
        } else {
          arg_names |= 2;
        }
        if (arg_names === 3) {
          throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
        }
        parse_tree.push({
          placeholder: match[0],
          param_no: match[1],
          keys: match[2],
          sign: match[3],
          pad_char: match[4],
          align: match[5],
          width: match[6],
          precision: match[7],
          type: match[8]
        });
      } else {
        throw new SyntaxError('[sprintf] unexpected placeholder');
      }
      _fmt = _fmt.substring(match[0].length);
    }
    return sprintf_cache[fmt] = parse_tree;
  }

  /**
   * export to either browser or node.js
   */
  /* eslint-disable quote-props */
  if (true) {
    exports.sprintf = sprintf;
    exports.vsprintf = vsprintf;
  }
  if (typeof window !== 'undefined') {
    window['sprintf'] = sprintf;
    window['vsprintf'] = vsprintf;
    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return {
          'sprintf': sprintf,
          'vsprintf': vsprintf
        };
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
  /* eslint-enable quote-props */
}(); // eslint-disable-line

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_baseui_esm_slider_slider_js-node_modules_sprintf-js_src_sprintf_js.chunk.js.map